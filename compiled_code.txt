===================================================== 
NUMBERBLOCKS GAME - COMPLETE CODE COMPILATION 
===================================================== 
 
===================================================== 
FILE: README.md 
===================================================== 
 
# Numberblocks Game

A 3D multiplayer browser-based game inspired by the Numberblocks educational show. Players control Numberblock characters and interact with operators in a fun mathematical environment.

## Project Structure

```
Root
├── index.html
├── package.json
├── README.md
├── assets
│   ├── images
│   ├── models
│   └── sounds
├── css
│   └── styles.css
├── js
│   ├── main.js
│   ├── controls.js
│   ├── player.js
│   ├── operators.js
│   ├── network-core.js
│   ├── hud.js
│   └── gameModes.js
└── lib
    └── three.min.js
```

## Tech Stack

- **Front-End**: HTML5, CSS3, JavaScript (ES6+), Three.js, Web Audio API
- **Back-End**: Node.js, Socket.io
- **Development Tools**: Git, Local Server, Jest (Optional)
- **Hosting**: Heroku (or similar platforms)

## Game Modes

- **Target Number Mode**: Race to reach a target number
- **Elimination Mode**: Avoid reaching zero or below
- **Score-Based Mode**: Earn points for each operation

## Implementation Progress

- [x] Step 1: Set up basic project structure
- [ ] Step 2: Create a basic 3D scene
- [ ] Step 3: Implement first-person camera controls
- [ ] Step 4: Create a basic Numberblock model
- [ ] Step 5: Implement player movement
- [ ] Step 6: Add operator spawning
- [ ] Step 7: Implement operator collection
- [ ] Step 8: Implement bumping interaction
- [ ] Step 9: Update Numberblock model based on number
- [ ] Step 10: Implement basic HUD
- [ ] Step 11: Add multiple players (multiplayer)
- [ ] Step 12: Implement game objectives
- [ ] Step 13: Add more game modes
- [ ] Step 14: Polish and optimize
- [ ] Step 15: Add advanced features (optional)
 
 
===================================================== 
SECTION: MEMORY BANK 
===================================================== 
 
----------------------------------------------------- 
FILE: memory bank\architecture.md 
----------------------------------------------------- 
 
# Numberblocks Game - Architecture

## Overview
The Numberblocks game is a 3D web-based educational game built with Three.js and Colyseus, utilizing a client-server architecture for multiplayer functionality. Players control customizable Numberblock characters that can interact with mathematical operators and other Numberblocks in a colorful 3D environment.

## Core Components

### 1. Server (server.js)
**Technology:** Built with Node.js and Colyseus.

**Responsibilities:**
- Manages game rooms and player connections/disconnections
- Maintains the authoritative game state, including player positions, Numberblock values, and static Numberblocks
- Processes player inputs (e.g., movement, operator collection, Numberblock collisions)
- Broadcasts state updates to all connected clients
- Handles operator spawning and lifecycle management

**Key Features:**
- Room-based multiplayer with session persistence
- State synchronization using Colyseus schema
- Server-authoritative position tracking
- Dynamic operator spawning system

### 2. Client (/client)
The client is responsible for rendering the game, handling user inputs, and communicating with the server.

**Key files:**
- **main-fixed.js:**
  - Initializes the Three.js scene, renderer, and camera
  - Sets up player controls and world objects
  - Manages view modes (first-person and third-person)
  - Updates visual components based on server state

- **network-core.js:**
  - Establishes and maintains WebSocket connection to the server via Colyseus
  - Sends player actions to the server (movement, operator collection, collisions)
  - Processes state updates from the server
  - Handles player joining/leaving events

- **numberblock.js:**
  - Defines the Numberblock class for rendering player characters
  - Creates dynamic block stacks based on numeric value
  - Manages visual elements (face, arms, feet, colors)
  - Handles value-based visual updates

- **operator.js:**
  - Manages mathematical operators (addition, subtraction)
  - Handles visual representation and animation
  - Provides collision detection support

- **controls.js:**
  - Handles player movement and camera controls
  - Supports both first-person and third-person view modes
  - Manages input handling for keyboard and mouse
  - Implements quaternion-based rotation for smooth camera movement

- **collision.js:**
  - Implements collision detection between game entities
  - Supports player-operator and player-numberblock interactions

- **Entity.js, Player.js, NPC.js, EntityFactory.js:**
  - Implements entity component system architecture
  - Provides base classes for all game entities
  - Manages entity tracking, creation, and removal
  - Handles entity refreshing when browser tabs regain focus

### 3. Networking Architecture
**Technology:** Colyseus for WebSocket-based real-time multiplayer.

**Implementation:**
- Server maintains authoritative game state using Colyseus Schema
- Client sends player actions to the server at regular intervals
- Server validates actions, updates game state, and broadcasts to all clients
- Efficient state synchronization with delta updates

**Key Features:**
- Session persistence with reconnection support
- Room-based multiplayer with shared state
- Message-based communication for game events
- Schema-based state synchronization with type annotations
- Player list UI showing all connected players
- Visibility change detection for inactive browser tabs
- Comprehensive entity refresh system for reactivated tabs

**Schema Implementation:**
- Proper MapSchema collections for players, operators, and static objects
- Type annotations for all schema properties
- Structured synchronization patterns for consistent state updates
- Multiple client-side approaches to handle schema data access
- Robust fallback methods for handling different Colyseus schema implementations

## File Structure
```
/
├── client/                  # Client-side code and assets
│   ├── index.html           # Main HTML entry point
│   ├── css/
│   │   └── styles.css       # Game styling
│   └── js/
│       ├── main-fixed.js    # Core game logic and rendering
│       ├── network-core.js  # Networking and state synchronization
│       ├── numberblock.js   # Numberblock entity implementation
│       ├── operator.js      # Mathematical operator implementation
│       ├── controls.js      # Player movement and camera controls
│       ├── collision.js     # Collision detection system
│       ├── Entity.js        # Base entity class
│       ├── Player.js        # Player entity implementation
│       ├── NPC.js           # Non-player character implementation
│       └── EntityFactory.js # Entity management system
├── server.js                # Server implementation with Colyseus
├── package.json             # Project dependencies
└── memory bank/             # Project documentation
    ├── architecture.md      # This file
    └── progress.md          # Development progress
```

## Communication Flow
1. **Initialization:**
   - Server starts and creates a game room
   - Client connects to server and joins the room
   - Server assigns a session ID and initializes player state

2. **Gameplay Loop:**
   - Client captures user inputs (movement, view changes)
   - Client sends inputs to server at regular intervals
   - Server validates and processes inputs
   - Server updates game state (player positions, operator spawning, etc.)
   - Server broadcasts updated state to all clients
   - Each client renders the updated game state

3. **Interactions:**
   - Client detects local collisions (player-operator, player-numberblock)
   - Client sends interaction events to server
   - Server validates interaction and updates game state accordingly
   - Server broadcasts the updated state to all clients

## Key Features
- **Dual View Modes:** First-person and third-person camera options
- **Dynamic Numberblocks:** Visual representation changes based on numeric value
- **Mathematical Interactions:** Addition and subtraction operators affect Numberblock values
- **Multiplayer Support:** Multiple players can join the same game world
- **Persistence:** Session reconnection support
- **Browser Tab Synchronization:** Automatically updates game state when inactive tabs become active
- **Entity Component System:** Flexible architecture for game entity management

## Future Enhancements
- Advanced operator types (multiplication, division)
- Cooperative puzzle challenges
- Enhanced visual effects and animations
- Mobile device support
- User accounts and progression tracking
 
 
----------------------------------------------------- 
FILE: memory bank\game design document.md 
----------------------------------------------------- 
 
Numberblocks FPS Game Design Document
Introduction
This document outlines the design for a multiplayer, browser-based, first-person perspective game inspired by the Numberblocks TV show. Players take on the role of Numberblocks, collect mathematical operators, and interact with other players to change their numerical values, aiming to achieve specific objectives in a fun and engaging way.
Overview
In this game, players navigate a colorful 3D world as Numberblocks, each representing a number. By collecting floating plus (+) and minus (-) operators and bumping into other players, they can add or subtract the other player's number from their own, altering their value. The game offers various modes, such as reaching a target number or eliminating opponents by reducing them to zero.
Core Mechanics
Player Movement
Players move in a first-person perspective with standard FPS controls:
WASD or arrow keys: Move forward, backward, left, and right.

Mouse: Look around.

Spacebar: Jump 

Operator Collection
Plus (+) and minus (-) operators spawn randomly across the game world.

Players collect an operator by running into it and can hold only one at a time.

Operators are visually distinct (e.g., a glowing "+" or "−") and float slightly above the ground.

Bumping Interaction
When a player with an operator bumps into another player, the operator is applied:
Plus Operator (+): The initiating player's number becomes their current number plus the other player's number (e.g., 3 + 2 = 5).

Minus Operator (-): The initiating player's number becomes their current number minus the other player's number (e.g., 3 - 2 = 1).

The other player's number remains unchanged.

The operator is consumed after use, requiring the player to collect a new one.

Number Changes
As a player's number changes, their character model updates:
Larger numbers grow in size (e.g., a Numberblock of 10 is bigger than one of 1).  The player's avatar is blocks that amount to their number.

Optional balancing: Larger numbers move slower but resist displacement, while smaller numbers are faster but more vulnerable.

Game World
Visual Style
The environment is bright, blocky, and inspired by the Numberblocks aesthetic.

Features include platforms, ramps, hiding spots, and open areas for player interaction.

Maps
Multiple themed maps:
Number Forest: Trees and terrain shaped like numbers.

Block City: A city of colorful block buildings.

Mathematical Playground: A playful area with slides and obstacles.

Maps encourage exploration and strategic positioning.

Interactive Elements
Some areas may require a specific number to access (e.g., a gate that opens only for players ≥ 10).

Player Characters
Appearance
Players are Numberblocks, with a block count matching their current number.  Their shape may be straight up, or rows of several blocks, or even arms and legs as the numbers get bigger.  But they are always made of blocks and their number is always visible.

The model dynamically adjusts as the number changes (e.g., growing from 1 block to 10 blocks).

Size and Speed (Optional)
Larger Numbers: Slower movement speed, harder to push.

Smaller Numbers: Faster movement, easier to displace.

This adds a layer of strategy to growing or shrinking.

Operators
Spawning
Operators appear at random intervals and locations on the map.

Spawn rates are balanced to ensure availability without overwhelming players.

Collection
Players collect an operator by touching it.

Collecting a new operator replaces the current one if the player is already holding one.

Usage
Operators activate automatically upon bumping into another player.

After use, the operator is consumed.

Game Objectives
The game supports multiple modes:
1. Target Number Mode
Objective: Reach a specific number (e.g., 100) by adding to your value.

The first player to hit the target wins.

2. Elimination Mode
Objective: Reduce other players to zero or below using the minus operator.

Players at zero or negative are eliminated; the last one standing wins.

3. Score-Based Mode
Objective: Earn points for each operation performed (e.g., +1 point per addition/subtraction).

The player with the most points at the end wins, tracked via a leaderboard.

Multiplayer Features

The Numberblocks game features a comprehensive multiplayer system with support for both local split-screen and online networked play, allowing for flexible and varied play experiences.

### Core Multiplayer Architecture

- **Client-Server Model**: Uses Colyseus for WebSocket communication, providing a server-authoritative game state
- **Room-Based Gameplay**: Players join game rooms with unique session IDs and synchronized state
- **Cross-Platform Support**: Play on various devices and browsers with consistent experience

### Local Split-Screen Multiplayer

- **Player Count**: Supports 2-4 players on a single device
- **Screen Division**:
  - 2 players: Horizontal split (top/bottom) or vertical split (left/right)
  - 3-4 players: Quadrant-based division with each player assigned a section of the screen
- **Input Management**:
  - Primary player: WASD movement, mouse look, spacebar jump
  - Secondary player(s): Arrow key movement, numpad look, enter jump
  - Gamepad support for all players with standard mapping
- **Visual Distinction**:
  - Unique colors/patterns for each player's Numberblock
  - Player names or icons displayed in their viewport
  - HUD customization per viewport showing player-specific info

### Online Multiplayer

- **Player Connection**: Connect to game servers via unique room codes or matchmaking
- **Persistence**: Session reconnection support if temporarily disconnected
- **Latency Management**:
  - Client-side prediction for responsive gameplay
  - Server reconciliation to maintain game state integrity
  - Position interpolation for smooth movement of other players
- **Player Limit**: Up to 10 players per online game room
- **Social Features**:
  - Player names and optional customization
  - Simple chat system or emoji-based communication
  - Friend invites and private rooms

### Hybrid Multiplayer

- **Local + Online**: Combine local split-screen with online play
  - Example: Two players on one device can join an online room with other remote players
- **Scaling**:
  - Game difficulty and operator spawning adjusts based on player count
  - Maps expand or contract to maintain optimal player density
- **Fairness**:
  - Equal operator distribution across the map
  - Spawn protection to prevent immediate targeting of new players
  - Optional balancing mechanics for teams with uneven player counts

### Gameplay Modes

- **Free-for-All**: Every player competes individually
- **Team Play**:
  - Form teams of 2-3 players
  - Combined team score or cooperative objectives
  - Team-based visual identity (color schemes)
- **Specialized Modes**:
  - Capture the Flag: Teams attempt to capture numbered flags
  - King of the Hill: Control zones to accumulate points
  - Math Race: Race through checkpoints solving math problems

### Player Interaction

- **Core Bumping Mechanics**: Apply operators to other players through collision
- **Cooperative Actions**:
  - Stand close to allies to combine numbers temporarily
  - Form "number trains" for enhanced movement or special abilities
  - Share operators with teammates
- **Competitive Actions**:
  - Block opponents from reaching operators
  - Strategic positioning to access high-value areas
  - Tactical operator usage to manipulate opponent numbers

### Networking Considerations

- **Bandwidth Optimization**:
  - Efficient state synchronization with delta updates
  - Interest management to prioritize nearby players
- **Cross-Device Performance**:
  - Adaptive rendering quality based on device capabilities
  - Optional graphic settings to maintain performance
- **Connection Quality**:
  - Visual indicators for network status
  - Graceful handling of high-latency situations

### Split-Screen Technical Implementation

- **Renderer Management**: Multiple Three.js renderers for each viewport
- **Camera Control**: Independent camera instances for each local player
- **Resource Sharing**: Optimized asset sharing for memory efficiency
- **Performance Considerations**:
  - Simplified lighting in multi-viewport mode
  - Reduced draw distance for split-screen to maintain frame rate
  - Level of detail adjustments based on viewport size

This comprehensive multiplayer system ensures the Numberblocks game is enjoyable whether playing with friends on the same device or connecting with players around the world.

Handling Edge Cases
Zero or Negative Numbers
If a player's number reaches zero or below:
Respawn Option: They are out for 10 seconds, then return as 1.

Elimination Option: They are removed from the round (used in Elimination Mode).

Maximum Number Limit
A cap (e.g., 100) prevents excessive growth.

Optional: Larger numbers face rarer plus operators to slow their progress.

User Interface (UI)
Heads-Up Display (HUD)
Shows:
Player's current number.

Held operator (if any).

Optional: Score or mini-map.

Menus
Main Menu: Choose game mode, map, and settings.

Lobby: Join or create multiplayer matches.

Controls
Movement: WASD or arrow keys.

Look: Mouse.

Jump: Spacebar (if implemented).

Interact: Automatic via bumping.

Audio
Background Music: Upbeat, Numberblocks-inspired tunes.

Sound Effects:
Operator collection (e.g., a cheerful "ding").

Bumping (e.g., a soft "thud").

Number change (e.g., a growing/shrinking sound).

Technical Considerations
Platform
Browser-based, using WebGL for 3D rendering (e.g., Three.js).

Networking
Real-time multiplayer requires server-side syncing of:
Player positions. 

Numbers.

Operator states and spawns.

Optimization
Must run smoothly on various devices/browsers.

Efficient collision detection is key for bumping mechanics.

Future Features
Power-Ups: Shields (block operators) or speed boosts.

Advanced Operators: Multiplication/division for complexity (optional).

Customization: Unlockable colors or accessories for Numberblocks.

Educational Mode: Single-player math puzzles for kids.

Conclusion
This game combines the playful, educational charm of Numberblocks with dynamic FPS gameplay. Its simple mechanics make it accessible to children, while strategic depth and multiplayer fun appeal to all ages. With proper balancing and optimization, it can become an entertaining and educational browser-based experience.
 
 
----------------------------------------------------- 
FILE: memory bank\implementation plan.md 
----------------------------------------------------- 
 
Step 1: Set up the basic project structure
Task: Create a new project and set up the files needed for a Three.js-based game.

Details: 
Create an index.html file with a canvas element.

Add a styles.css file for basic styling (e.g., full-screen canvas).

Create a main.js file for JavaScript code.

Include the Three.js library via a CDN (e.g., <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>).

Test: 
Open the project in a browser.

Check that there are no console errors and a blank canvas appears.

Step 2: Create a basic 3D scene
Task: Set up a simple 3D scene with a ground plane and a camera.

Details: 
In main.js, create a Three.js scene, camera, and renderer.

Add a flat plane (e.g., a large box) as the ground.

Position the camera above the ground and render the scene.

Test: 
Open the project in a browser.

See the ground plane rendered from the camera’s perspective.

Step 3: Implement first-person camera controls
Task: Add first-person movement controls to the camera.

Details: 
Use Three.js’s FirstPersonControls or a custom controller.

Enable WASD keys for movement and mouse for looking around.

Test: 
Use WASD keys to move and the mouse to look around.

Confirm the controls are smooth and responsive.

Step 4: Create a basic Numberblock model
Task: Add a simple Numberblock model to the scene.

Details: 
Create a single cube to represent a Numberblock with the number 1.

Position it slightly above the ground in the scene.

Test: 
Open the project and see the cube in the scene.

Ensure it’s correctly positioned relative to the ground.

Step 5: Implement player movement
Task: Attach the Numberblock model to the camera and add basic movement.

Details: 
Link the cube’s position to the camera so it moves with it.

Add jumping (spacebar) and gravity to prevent falling through the ground.

Test: 
Move with WASD keys and see the cube move.

Press spacebar to jump and watch the cube rise and fall back to the ground.

Step 6: Add operator spawning
Task: Create and spawn plus (+) and minus (-) operators in the scene.

Details: 
Make simple 3D models (e.g., spheres) for operators, colored differently (e.g., green for +, red for -).

Write a function to spawn them randomly on the ground every few seconds.

Test: 
See operators appear over time at different spots.

Verify they sit on the ground, not floating or underground.

Step 7: Implement operator collection
Task: Allow the player to collect operators by touching them.

Details: 
Detect when the player’s Numberblock collides with an operator.

Remove the operator from the scene and store it as the player’s held operator (limit to one).

Test: 
Walk into an operator and see it disappear.

Confirm the player holds it (e.g., log it to the console or show it on-screen).

Step 8: Implement bumping interaction
Task: Enable bumping into another Numberblock to apply the operator.

Details: 
Add a second, static Numberblock with a fixed number (e.g., 2).

Detect collision with it; if the player has an operator, apply it (e.g., 1 + 2 = 3).

Remove the operator after use.

Test: 
Bump into the static Numberblock with an operator.

Check that the player’s number updates (e.g., from 1 to 3) and the operator is consumed.

Step 9: Update Numberblock model based on number
Task: Change the Numberblock model when its number changes.

Details: 
Write a function to stack cubes vertically based on the player’s number (e.g., 3 cubes for 3).

Update the model after a number change.

Test: 
After bumping and changing the number, see the model update (e.g., from 1 cube to 3).

Ensure it doesn’t clip through the ground.

Step 10 / 11: MULTIPLAYER AND CONTROLLER SUPPORT

SEE MULTIPLAYER AND CONTROLLER FEATURE.MD

Step 12: Implement game objectives
Task: Add the Target Number Mode.

Details: 
Set a target number (e.g., 10).

Display a win message when a player reaches it.

Test: 
Play and reach the target number.

See a win message appear when achieved.

Step 13: Add more game modes
Task: Implement Elimination Mode and Score-Based Mode.

Details: 
Elimination Mode: Remove players whose number reaches zero or below.

Score-Based Mode: Award points for each operation, shown on a leaderboard.

Test: 
Test Elimination Mode: Reach zero and get removed or respawn.

Test Score-Based Mode: Perform operations and see points increase.

Step 14: Polish and optimize
Task: Enhance visuals, add audio, and improve performance.

Details: 
Add basic textures or colors to models.

Include sound effects (e.g., “ding” for collecting operators).

Optimize rendering for smooth gameplay.

Test: 
Play and ensure no lag or glitches.

Hear sound effects and see improved visuals.

Step 15: Add advanced features (optional)
Task: Introduce power-ups or advanced operators.

Details: 
Add a power-up (e.g., speed boost) that spawns like operators.

Optionally, include multiplication operators (e.g., ×2).

Test: 
Collect a power-up and see its effect (e.g., faster movement).

Use an advanced operator and verify the number change.

Conclusion
This implementation plan provides a clear, step-by-step roadmap to develop the Numberblocks FPS game. Each step is simple enough to be handled with a single prompt in the Windsurf IDE, and the accompanying tests ensure that each feature works before moving forward. By following this plan, you can progressively build a fully functional browser-based multiplayer game that aligns with the game design document’s vision.

 
 
----------------------------------------------------- 
FILE: memory bank\progress.md 
----------------------------------------------------- 
 
# Numberblocks Game - Progress Log

## March 15, 2025
- Completed Step 1 of implementation plan: Set up basic project structure
  - Created index.html with canvas element
  - Added styles.css for basic styling (full-screen canvas)
  - Created main.js for JavaScript code
  - Included Three.js library via CDN
  - Created directory structure following the architecture document
  - Verified that the project loads in browser with no console errors
- Created comprehensive README.md file
- Set up Git repository and GitHub remote
- Added .gitignore file for the project
- Completed Step 2 of implementation plan: Created a basic 3D scene
  - Implemented Three.js scene, camera, and renderer in main.js
  - Added a flat green plane as the ground
  - Positioned the camera above the ground
  - Added proper lighting (ambient and directional)
  - Implemented window resize handling
  - Set up the animation loop
- Completed Step 3 of implementation plan: Implemented first-person camera controls
  - Created controls.js for camera movement functionality
  - Implemented Three.js PointerLockControls for first-person view
  - Added WASD and arrow key movement
  - Implemented jumping with spacebar
  - Added controls info overlay for user guidance
  - Added appropriate styles for the overlay UI
  - Implemented robust fallback mechanism for environments where Pointer Lock API is unavailable
  - Added error handling with try-catch blocks for browser API compatibility
  - Created mockControls object that mimics the PointerLockControls interface for seamless operation
  - Enhanced FPS camera controls:
    - Added parent-child object hierarchy for proper camera rotation
    - Separated yaw (horizontal) and pitch (vertical) rotations for natural camera movement
    - Implemented pitch clamping to prevent camera flipping
    - Added mouse locking within the game window using CSS and event handling
    - Ensured proper cursor disengagement when ESC key is pressed
    - Implemented proper event listener cleanup for complete mouse control disengagement
  - Updated RULES.md with browser API considerations based on implementation experience
- Completed Step 4 of implementation plan: Created a basic Numberblock model
  - Implemented Numberblock class in numberblock.js with all required features:
    - Created a stack of blocks representing the Numberblock's value
    - Added face with eyes and mouth to the top block
    - Added arms on the sides (positioned based on number of blocks)
    - Added feet to the bottom block
    - Added a number tag on top showing the Numberblock's value
  - Used appropriate colors matching the Numberblocks TV show aesthetic
  - Integrated the Numberblock model with the main game:
    - Added the Numberblock to follow the player's movement
    - Positioned it in front of the camera for a first-person view
    - Implemented smooth interpolation for natural movement
    - Added HTML/CSS-based number display that follows the 3D model
  - Added helper functions for creating and updating Numberblocks
  - Added proper resource cleanup methods to prevent memory leaks
- Completed Step 5 of implementation plan: Implemented player movement (partial collision)
  - Added getHeight method to Numberblock class for accurate height calculation
  - Improved jumping mechanics with physically accurate jump formula
  - Implemented basic ground collision detection to prevent falling through the ground
  - Created true first-person view where camera positioned from Numberblock's perspective
  - Ensured perfect synchronization between camera and Numberblock during all movements
  - Implemented two-way position binding to maintain consistent camera-Numberblock relationship
  - Note: Full collision system with other objects not implemented yet
- Completed Step 6 of implementation plan: Added operator spawning
  - Created Operator and OperatorManager classes
  - Implemented operator spawning system
  - Added proper positioning and rotation
  - Integrated with player controls
  - Fixed movement controls after operator integration
  - Ensured proper initialization order
- Completed Step 7 of implementation plan: Implemented operator collection
  - Added collision detection between player's Numberblock and operators
  - Created visual attachment system to make operators attach to Numberblock's hand
  - Modified Numberblock.createArm method to name hand objects for reference
  - Enhanced OperatorManager.setHeldOperator to attach operators to the Numberblock
  - Created smaller version (40% scale) of operator for holding
  - Added robust error handling in collision detection to prevent game freezes
  - Properly integrated collision.js with the rest of the codebase
  - Implemented fallback collision functions for improved stability
- Completed Step 8 of implementation plan: Implemented bumping interaction
  - Added a second static Numberblock to the scene with value 2
  - Implemented collision detection between player and static Numberblock
  - Created logic to apply held operators (plus/minus) when collision occurs
  - Added mathematical operations based on operator type:
    - Plus operator: player.value += staticNumberblock.value
    - Minus operator: player.value -= staticNumberblock.value (with minimum value check)
  - Added visual feedback with immediate Numberblock reconstruction
  - Implemented operator consumption after successful application
  - Added player pushback to prevent continuous collisions
  - Enhanced UI feedback with console logs and visual updates
  - Added error handling for collision detection to prevent game freezes

### Step 9: Update Numberblock Model & Add HUD (Completed March 15, 2025)
- **Updated Numberblock Model**
  - Verified that the Numberblock model correctly updates its visual representation after mathematical operations
  - Enhanced the camera positioning to dynamically adjust based on Numberblock size
  - Fixed visual artifacts and rendering issues with number tags
  - Implemented double-sided transparent materials for better visibility
  
- **Added Basic HUD**
  - Created a heads-up display showing the player's current number in the top-right corner
  - Styled the HUD with semi-transparent background and clear typography
  - Ensured the HUD updates in real-time when the player's number changes
  - Made the HUD non-intrusive with pointer-events set to none

## March 16, 2025
- Improved HUD display:
  - Added clear number display in top-left that changes color based on Numberblock value
  - Added operator display in top-right showing "+ Add" or "- Subtract"
  - Added semi-transparent backgrounds and text shadows for better visibility
  - Removed duplicate displays for cleaner UI
- Fixed Numberblock positioning:
  - All Numberblocks now properly stand on the ground
  - Fixed positioning for random shapes and objects
  - Improved Y-position calculations for consistent placement
- Removed redundant number tags from Numberblocks since value is shown in HUD
- Enhanced control system:
  - Added Q and E key functionality for turning left and right in first-person view
  - Set appropriate rotation speed for smooth turning experience
  - Maintained backward compatibility with mouse controls
- Expanded game world:
  - Increased ground size from 50x50 to 200x200 units (16x larger play area)
  - Added more decorative objects (from 30 to 120) to maintain visual density
  - Increased trees from 10 to 40 for better landmarks
  - Expanded spawn protection area for better player experience
- Implemented third-person camera and controls:
  - Added toggle between first-person and third-person views with the V key
  - Implemented camera positioning behind the player with proper height and distance
  - Created smooth camera transition when changing views
  - Developed camera-relative movement in third-person mode
  - Added Q/E rotation controls for the player character in third-person mode
  - Ensured player character rotation matches movement direction when WASD keys are used
  - Implemented proper cursor handling in both view modes
  - Fixed THREE.js error related to camera parenting during view transitions

## March 16, 2025 (continued)
- Implemented client-server architecture for multiplayer functionality:
  - Created server.js using Node.js and Colyseus for WebSocket communication
  - Migrated from single-player to a networked multiplayer architecture
  - Implemented room-based gameplay with Colyseus schema for state synchronization
  - Added player session management with reconnection support
  - Enhanced network communication between client and server
  - Modified main.js to support server-synchronized gameplay
  - Implemented server-authoritative position tracking and collision detection
  - Added player joining/leaving events with real-time UI updates
  
- Major code reorganization:
  - Moved all client-side code to a dedicated /client directory
  - Updated file references and paths throughout the codebase
  - Removed outdated test and debug files
  - Consolidated CSS and other assets into appropriate directories
  - Created a streamlined development workflow with npm scripts

- Enhanced multiplayer features:
  - Added static numberblocks with server-managed state
  - Implemented operator spawning controlled by the server
  - Created player list UI showing all connected players
  - Added visual representations of other players in the game world
  - Fixed camera view switching to maintain proper position synchronization
  - Improved network code to handle view transitions seamlessly

- Fixed critical bugs:
  - Resolved issue with static numberblocks floating above ground
  - Fixed position synchronization issues when switching camera views
  - Corrected operator collection and interaction logic in multiplayer context
  - Improved error handling for network-related operations

## March 16, 2025 (evening)
- Fixed critical Colyseus schema synchronization issues:
  - Updated schema definitions to use proper MapSchema initialization instead of regular objects
  - Added proper type annotations for all schema properties
  - Fixed player list functionality to correctly display connected players
  - Implemented proper methods for player management (MapSchema .set() and .delete())
  - Added verification and fallback mechanisms for player data access
  - Enhanced logging for better debugging of multiplayer state
  - Improved error handling for schema operations

- Added robust player list UI improvements:
  - Implemented expandable/collapsible player list with Tab key
  - Added color indicators matching player Numberblock colors
  - Improved display with player names and values
  - Created multiple player data access methods to ensure compatibility
  - Added real-time updating based on schema changes
  - Fixed visual formatting and styling of player entries

## March 17, 2025
- Fixed entity management after refactoring:
  - Improved camera controls for first-person mode:
    - Corrected camera rotation implementation to allow full 360-degree rotation
    - Fixed the rotation limitation that previously restricted the view to about 90 degrees
    - Updated quaternion handling to maintain proper camera orientation
    - Explicitly set camera rotation order to 'YXZ' to prevent gimbal lock
  - Enhanced player list update mechanism:
    - Implemented visibility change event listener to detect when inactive tabs become active
    - Created comprehensive entity refresh system to update all entities from current room state
    - Added robust methods to handle different Colyseus schema implementations for maximum compatibility
    - Enhanced error handling for network state synchronization
    - Implemented fallback methods for obtaining player data when primary methods fail
  - Improved entity architecture:
    - Enhanced EntityFactory class with new refreshAllEntities method for comprehensive state updates
    - Added helper methods for refreshing specific entity types (_refreshPlayerEntity, _refreshOperatorEntity)
    - Optimized entity tracking to ensure consistent visual representation
    - Fixed tracking of player entities between camera view changes

## Next Steps
- Add customizable player names and colors
- Implement additional operator types (multiplication, division)
- Create cooperative math challenges
- Add game statistics and leaderboard
- Enhance visual effects for multiplayer interactions 
 
----------------------------------------------------- 
FILE: memory bank\RULES.md 
----------------------------------------------------- 
 
# Development Rules and Notes

## Server Management

### Restarting the Numberblocks Server
When testing changes, you'll need to properly stop and restart the Node.js server:

```powershell
# STEP 1: Kill all Node.js processes (safer and more reliable method)
taskkill /F /IM node.exe

# STEP 2: Start the server using npm
npm start
```

> NOTE: The previous method using `Get-Process -Name "node" -ErrorAction SilentlyContinue | Stop-Process -Force` 
> has been found to be unreliable and may cause issues.

### Directory Creation
- When creating multiple directories at once with PowerShell's `mkdir` command, you must use quotes when specifying paths with spaces or multiple directories:
  ```
  # INCORRECT (will fail):
  mkdir css js assets assets\images assets\models assets\sounds
  
  # CORRECT (individual commands):
  mkdir css
  mkdir js
  mkdir assets
  mkdir "assets\images"
  mkdir "assets\models"
  mkdir "assets\sounds"
  ```

- PowerShell's `mkdir` doesn't support multiple directory arguments like in Linux/macOS. Create directories one by one or use a loop.


## Three.js Implementation Notes

- Always include the Three.js library before your own JavaScript files in the HTML
- When testing, make sure to run a local HTTP server rather than opening the HTML file directly due to CORS restrictions with resource loading
- Use a thin BoxGeometry instead of PlaneGeometry for the ground to ensure proper lighting on both sides
- Always implement window resize handling for responsive design (update camera aspect ratio and renderer size)
- For better performance, set renderer.setPixelRatio to match the device's pixel ratio

## Browser API Considerations

- The Pointer Lock API (used by PointerLockControls) may not work in some environments, especially in embedded preview browsers or when served through certain proxies
- Always implement a fallback mechanism for critical browser APIs in case they fail
- Use try-catch blocks around browser API calls that might not be supported in all environments
- Check browser console for API-related errors when testing in different environments
- When implementing mouse controls:
  - Proper event listener management is essential (add/remove listeners appropriately)
  - Always provide visual feedback when controls are locked/unlocked
  - Ensure complete disengagement of controls when user presses ESC

## JavaScript Considerations

- When using event handlers, store references to them for proper removal later to prevent memory leaks
- For event-based systems (like controls), implement a proper event dispatcher mechanism
- Use class-based or module patterns for complex components to keep code organized
- When dealing with 3D rotations:
  - Separate axes of rotation (yaw, pitch, roll) to prevent gimbal lock issues
  - Always clamp vertical rotation (pitch) to prevent camera flipping

## Git Workflow

- Always update the progress.md file after completing each implementation step
- Keep commit messages descriptive and related to the implementation plan steps

## Project Structure

- Follow the architecture document precisely to ensure consistency
- New JavaScript files should be placed in the js/ directory and then linked in index.html as needed

## class structure
- keep classes modular - each class should have a single responsibility
- use classes to group related functionality
 
 
----------------------------------------------------- 
FILE: memory bank\tech stack.md 
----------------------------------------------------- 
 
# Numberblocks Game - Tech Stack

## Front-End
- **HTML5:** Provides the structure for the game, including the canvas element for 3D rendering and UI components like the heads-up display (HUD) and menus.

- **CSS3:** Styles the UI elements, such as the HUD, player stats, and overlays, ensuring they look polished and are positioned correctly over the game canvas.

- **JavaScript (ES6+):** Drives the client-side game logic, handling player input, visual rendering, and network communication.

- **Three.js:** A JavaScript library that simplifies WebGL for 3D rendering, used to create the game world, dynamic Numberblock models, and environmental elements.

- **Web Audio API:** Manages audio, including sound effects for actions like bumping into players or collecting operators, and background music.

## Back-End
- **Node.js:** Server-side JavaScript runtime that hosts the game server, manages player connections, and maintains the authoritative game state.

- **Colyseus:** Framework for multiplayer game server development that handles room-based multiplayer, state synchronization, and client message processing.

- **Colyseus Schema:** Provides efficient state synchronization between server and clients with binary encoding and delta updates.

## Networking
- **WebSockets:** Underlying protocol for real-time bidirectional communication between clients and server.

- **Client-Server Architecture:** Maintains authoritative game state on the server to prevent cheating and ensure consistent gameplay.

- **Room-Based Multiplayer:** Organizes players into game rooms with shared state and scoped communication.

## Development Tools
- **Git:** Version control system to track changes and manage the project's codebase.

- **npm:** Package manager for JavaScript, used to manage dependencies and run scripts.

- **Nodemon:** Development utility that monitors server.js changes and automatically restarts the server during development.

- **ESLint:** JavaScript linter that helps maintain code quality and consistency.

## Project Organization
- **Client-Server Separation:** Distinct code organization with `/client` directory for front-end and root-level server code.

- **Modular Design:** Separate JavaScript modules for different game systems (networking, rendering, game logic).

- **Build Process:** Custom scripts to compile and bundle client code for production deployment.

## Deployment
- **Node.js Hosting:** Server deployed on Node.js compatible hosting platforms (e.g., Heroku, AWS, DigitalOcean).

- **Static Asset Serving:** Client-side assets (HTML, CSS, JS) served by the Node.js server.

## Why This Stack?

- **Three.js:** Provides powerful 3D rendering capabilities with a manageable learning curve, ideal for creating the Numberblock characters and interactive 3D environment.

- **Colyseus:** Purpose-built for multiplayer games with efficient state synchronization and room management, simplifying networked gameplay implementation.

- **Client-Server Model:** Ensures fair gameplay by maintaining authoritative state on the server, preventing client-side cheating.

- **Node.js:** Enables JavaScript throughout the stack, reducing context switching and allowing code sharing between client and server when appropriate.

This tech stack supports all core gameplay mechanics of Numberblocks, including the dynamic character models, mathematical interactions, and multiplayer functionality, while providing a solid foundation for future enhancements.
 
 
----------------------------------------------------- 
FILE: memory bank\X MULTIPLAYER REFACTOR.md 
----------------------------------------------------- 
 
Revised Implementation Plan to Ensure Server Authority and Enable Server-Coordinated Player Movement

# PRIMARY GOAL: GET A WORKING PROTOTYPE WHERE PLAYERS CAN RUN AROUND AND SEE OTHER PLAYERS

## Overview
The goal is to ensure the server (via Colyseus) has full authority over all player positions, and the client only sends inputs and renders based on server state. We'll focus on implementing this core functionality first to create a minimal viable prototype where players can move around and see each other.

## Implementation Steps (Prioritized for Working Prototype)

### Step 1: Implement Input State Handling in Client
Goal: Convert client movement from direct position updates to input state transmission.

Files to Modify:
- client/js/controls.js
- client/js/main-fixed.js

Implementation:
1. In controls.js, create an input state object that tracks key presses and mouse movements:
```javascript
// In controls.js - Add at the top of the file
window.inputState = {
  keys: { w: false, a: false, s: false, d: false, space: false },
  mouseDelta: { x: 0, y: 0 }
};

// Update key handlers to set inputState
function onKeyDown(event) {
  switch (event.code) {
    case 'ArrowUp':
    case 'KeyW':
      window.inputState.keys.w = true;
      window.moveForward = true;
      break;
    case 'ArrowLeft':
    case 'KeyA':
      window.inputState.keys.a = true;
      window.moveLeft = true;
      break;
    case 'ArrowDown':
    case 'KeyS':
      window.inputState.keys.s = true;
      window.moveBackward = true;
      break;
    case 'ArrowRight':
    case 'KeyD':
      window.inputState.keys.d = true;
      window.moveRight = true;
      break;
    case 'Space':
      window.inputState.keys.space = true;
      if (window.canJump) {
        window.velocity.y = Math.sqrt(window.jumpHeight * 2 * 9.8);
        window.canJump = false;
      }
      break;
  }
}

function onKeyUp(event) {
  switch (event.code) {
    case 'ArrowUp':
    case 'KeyW':
      window.inputState.keys.w = false;
      window.moveForward = false;
      break;
    case 'ArrowLeft':
    case 'KeyA':
      window.inputState.keys.a = false;
      window.moveLeft = false;
      break;
    case 'ArrowDown':
    case 'KeyS':
      window.inputState.keys.s = false;
      window.moveBackward = false;
      break;
    case 'ArrowRight':
    case 'KeyD':
      window.inputState.keys.d = false;
      window.moveRight = false;
      break;
    case 'Space':
      window.inputState.keys.space = false;
      break;
  }
}

// Add mouse movement tracking
document.addEventListener('mousemove', (event) => {
  if (document.pointerLockElement) {
    window.inputState.mouseDelta.x += event.movementX;
    window.inputState.mouseDelta.y += event.movementY;
  }
});
```

2. In main-fixed.js, add code to send input state to the server periodically:
```javascript
// In main-fixed.js - Add within the init() function after networking is initialized
function sendInputUpdates() {
  if (window.room && window.inputState) {
    window.room.send("input", window.inputState);
    
    // Reset mouse delta after sending
    window.inputState.mouseDelta.x = 0;
    window.inputState.mouseDelta.y = 0;
  }
}

// Set up input sending interval (30Hz)
setInterval(sendInputUpdates, 1000 / 30);
```

### Step 2: Update Server to Process Input States
Goal: Make the server calculate player positions based on input states.

File to Modify:
- server.js

Implementation:
1. Add input state handling to the server:
```javascript
// In server.js - Add to Player schema
class Player extends Schema {
  constructor() {
    super();
    this.x = 0;
    this.y = 1;
    this.z = 5;
    this.value = 1;
    this.rotationY = 0;
    this.pitch = 0;
    this.operator = null;
    this.color = "#FFFFFF";
    this.name = "";
    this.velocityY = 0;
    this.input = null;
  }
}

// Register input as a schema type
type("*")(Player.prototype, "input");  // Using * type for the complex object

// In onCreate method, add input message handler
this.onMessage("input", (client, input) => {
  const player = this.state.players.get(client.sessionId);
  if (player) {
    player.input = input;
  }
});
```

2. Process inputs in the update method:
```javascript
// In server.js - Update the update() method
update() {
  // Calculate delta time (assuming 30fps if not available)
  const deltaTime = 1/30;
  const speed = 5.0 * deltaTime;
  
  // Process player inputs
  this.state.players.forEach((player, sessionId) => {
    if (player.input) {
      // Handle rotation from mouse movement
      const sensitivity = 0.002;
      player.rotationY += (player.input.mouseDelta?.x || 0) * sensitivity;
      player.pitch += (player.input.mouseDelta?.y || 0) * sensitivity;
      player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.pitch));
      
      // Handle movement
      let dx = 0, dz = 0;
      if (player.input.keys.w) {
        dx += Math.sin(player.rotationY) * speed;
        dz += Math.cos(player.rotationY) * speed;
      }
      if (player.input.keys.s) {
        dx -= Math.sin(player.rotationY) * speed;
        dz -= Math.cos(player.rotationY) * speed;
      }
      if (player.input.keys.a) {
        dx += Math.sin(player.rotationY - Math.PI/2) * speed;
        dz += Math.cos(player.rotationY - Math.PI/2) * speed;
      }
      if (player.input.keys.d) {
        dx += Math.sin(player.rotationY + Math.PI/2) * speed;
        dz += Math.cos(player.rotationY + Math.PI/2) * speed;
      }
      
      // Apply movement
      player.x += dx;
      player.z += dz;
      
      // Handle jumping
      if (player.input.keys.space && player.y === 1) {
        player.velocityY = 0.2; // Jump velocity
      }
      
      // Apply gravity
      player.velocityY += -0.01; // Simple gravity
      player.y += player.velocityY;
      
      // Floor collision
      if (player.y < 1) {
        player.y = 1;
        player.velocityY = 0;
      }
    }
  });
  
  // Continue with existing operator spawning code
  this.spawnTimer += deltaTime;
  if (this.spawnTimer >= this.spawnInterval && Object.keys(this.state.operators).length < this.maxOperators) {
    this.spawnOperator();
    this.spawnTimer = 0;
    this.spawnInterval = this.getRandomSpawnInterval();
  }
}
```

### Step 3: Update Client Rendering Based on Server State
Goal: Render player positions from server data only.

File to Modify:
- client/js/main-fixed.js

Implementation:
```javascript
// In main-fixed.js - Modify the animate function
function animate() {
  requestAnimationFrame(animate);
  
  // Get current player state from server
  if (window.room && window.room.state && window.room.state.players) {
    const player = window.room.state.players.get(window.room.sessionId);
    
    if (player && playerNumberblock && playerNumberblock.mesh) {
      // Update local player position and rotation based on server state
      playerNumberblock.mesh.position.lerp(new THREE.Vector3(player.x, player.y, player.z), 0.3);
      playerNumberblock.mesh.rotation.y = player.rotationY;
      
      // Update camera based on view mode
      if (window.isFirstPerson) {
        camera.position.set(player.x, player.y + 1.6, player.z);
        camera.rotation.x = player.pitch;
        camera.rotation.y = player.rotationY;
        playerNumberblock.mesh.visible = false;
      } else {
        // Third-person camera
        const offset = new THREE.Vector3(0, 2, 5)
          .applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotationY);
        camera.position.set(player.x + offset.x, player.y + offset.y, player.z + offset.z);
        camera.lookAt(player.x, player.y, player.z);
        playerNumberblock.mesh.visible = true;
      }
      
      // Update player value if needed
      if (player.value !== playerNumberblock.value) {
        playerNumberblock.setValue(player.value);
      }
    }
  }
  
  // Render scene
  renderer.render(scene, camera);
}
```

### Step 4: Add Basic Debug Tools (Optional - Only if problems arise)
Goal: Implement minimal debug tools to help with troubleshooting.

File to Create:
- client/js/debug.js

Implementation:
```javascript
// Debug flag - set to true during development, false in production
window.DEBUG = false;

// Debug logging function
window.debugLog = function(...args) {
  if (window.DEBUG) console.log(...args);
};

// Toggle debug mode with F1 key
document.addEventListener('keydown', (e) => {
  if (e.key === 'F1') {
    window.DEBUG = !window.DEBUG;
    console.log("Debug mode:", window.DEBUG ? "ON" : "OFF");
  }
});

// Create debug overlay
const debugOverlay = document.createElement('div');
debugOverlay.style.position = 'absolute';
debugOverlay.style.top = '10px';
debugOverlay.style.left = '10px';
debugOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
debugOverlay.style.color = 'white';
debugOverlay.style.padding = '10px';
debugOverlay.style.fontFamily = 'monospace';
debugOverlay.style.fontSize = '12px';
debugOverlay.style.display = 'none';
document.body.appendChild(debugOverlay);

// Update debug overlay
window.updateDebugOverlay = function() {
  if (!window.DEBUG) {
    debugOverlay.style.display = 'none';
    return;
  }
  
  debugOverlay.style.display = 'block';
  
  let content = '';
  
  // Add player position info
  if (window.room && window.room.state && window.room.state.players) {
    const player = window.room.state.players.get(window.room.sessionId);
    if (player && window.playerNumberblock) {
      const clientPos = window.playerNumberblock.mesh.position;
      content += `Position:<br>`;
      content += `Client: x=${clientPos.x.toFixed(2)}, y=${clientPos.y.toFixed(2)}, z=${clientPos.z.toFixed(2)}<br>`;
      content += `Server: x=${player.x.toFixed(2)}, y=${player.y.toFixed(2)}, z=${player.z.toFixed(2)}<br>`;
      content += `<br>Rotation:<br>`;
      content += `Y: ${player.rotationY.toFixed(2)}<br>`;
      content += `Pitch: ${player.pitch.toFixed(2)}<br>`;
    }
  }
  
  // Add input state info
  if (window.inputState) {
    content += `<br>Input:<br>`;
    content += `W: ${window.inputState.keys.w}, `;
    content += `A: ${window.inputState.keys.a}, `;
    content += `S: ${window.inputState.keys.s}, `;
    content += `D: ${window.inputState.keys.d}<br>`;
    content += `Mouse: x=${window.inputState.mouseDelta.x.toFixed(0)}, y=${window.inputState.mouseDelta.y.toFixed(0)}`;
  }
  
  debugOverlay.innerHTML = content;
};

// Call updateDebugOverlay in the animation loop
```

## Progress Tracking

### Completed Items
✅ Updated implementation plan to focus on minimal viable prototype
✅ Outlined critical steps needed for server authority
✅ Removed redundant network.js references
✅ Prepared code snippets for immediate implementation

### Next Steps
🔲 Implement input state handling in client (controls.js, main-fixed.js)
🔲 Update server to process inputs and calculate positions
🔲 Modify client rendering to use server state
🔲 Test multiplayer movement with multiple browsers
🔲 Add debug tools if problems arise during testing

### Testing Checklist
🔲 Single player can move around with server-calculated position
🔲 Multiple players can see each other moving
🔲 Camera works in both first-person and third-person views
🔲 Player position stays synchronized across clients
🔲 Rotations and jumping work correctly
 
 
===================================================== 
FILE: server.js 
===================================================== 
 
// Import required modules
const http = require('http');
const express = require('express');
const { Server } = require('colyseus');
const { Room } = require("colyseus");
const { Schema, MapSchema, type } = require("@colyseus/schema");
const path = require('path');

// Define the InputState schema
class InputState extends Schema {
    constructor() {
        super();
        // Default initialization for input state
        this.keys = { w: false, a: false, s: false, d: false, space: false };
        this.mouseDelta = { x: 0, y: 0 };
        this.viewMode = "third-person"; // Default view mode
    }
}

// Define the state schema for Colyseus
class Player extends Schema {
    constructor() {
        super();
        this.x = 0;
        this.y = 1;
        this.z = 5;
        this.value = 1;
        this.rotationY = 0;
        this.pitch = 0;
        this.operator = ""; // Changed from null to empty string
        this.color = "#FFFFFF";
        this.name = "";
        this.velocityY = 0; // Add velocity for physics
        this.input = new InputState();  // Initialize with InputState schema
    }
}

class Operator extends Schema {
    constructor() {
        super();
        this.id = "";
        this.type = ""; // 'plus' or 'minus'
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }
}

// Create a dedicated schema for static numberblocks
class StaticNumberblock extends Schema {
    constructor() {
        super();
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.value = 1;
        this.color = "#FFFFFF";
    }
}

// Add schemas for other entities
class Tree extends Schema {
    constructor() {
        super();
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.scale = 1;
    }
}

class Rock extends Schema {
    constructor() {
        super();
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.scale = 1;
    }
}

class GameState extends Schema {
    constructor() {
        super();
        this.players = new MapSchema();
        this.operators = new MapSchema();
        this.staticNumberblocks = new MapSchema();
        this.trees = new MapSchema();
        this.rocks = new MapSchema();
    }
}

// Register schema types for InputState
type("boolean")(InputState.prototype, "keys.w");
type("boolean")(InputState.prototype, "keys.a");
type("boolean")(InputState.prototype, "keys.s");
type("boolean")(InputState.prototype, "keys.d");
type("boolean")(InputState.prototype, "keys.space");
type("number")(InputState.prototype, "mouseDelta.x");
type("number")(InputState.prototype, "mouseDelta.y");
type("string")(InputState.prototype, "viewMode");

// Register schema types for Player
type("number")(Player.prototype, "x");
type("number")(Player.prototype, "y");
type("number")(Player.prototype, "z");
type("number")(Player.prototype, "value");
type("number")(Player.prototype, "rotationY");
type("number")(Player.prototype, "pitch");
type("string")(Player.prototype, "operator");
type("string")(Player.prototype, "color");
type("string")(Player.prototype, "name");
type("number")(Player.prototype, "velocityY");
type(InputState)(Player.prototype, "input"); // Use InputState type instead of wildcard

// Register schema types for Operator
type("string")(Operator.prototype, "id");
type("string")(Operator.prototype, "type");
type("number")(Operator.prototype, "x");
type("number")(Operator.prototype, "y");
type("number")(Operator.prototype, "z");

// Register schema types for StaticNumberblock
type("number")(StaticNumberblock.prototype, "x");
type("number")(StaticNumberblock.prototype, "y");
type("number")(StaticNumberblock.prototype, "z");
type("number")(StaticNumberblock.prototype, "value");
type("string")(StaticNumberblock.prototype, "color");

// Register schema types for Tree
type("number")(Tree.prototype, "x");
type("number")(Tree.prototype, "y");
type("number")(Tree.prototype, "z");
type("number")(Tree.prototype, "scale");

// Register schema types for Rock
type("number")(Rock.prototype, "x");
type("number")(Rock.prototype, "y");
type("number")(Rock.prototype, "z");
type("number")(Rock.prototype, "scale");

// Register schema types for GameState
type({ map: Player })(GameState.prototype, "players");
type({ map: Operator })(GameState.prototype, "operators");
type({ map: StaticNumberblock })(GameState.prototype, "staticNumberblocks"); // Updated to use StaticNumberblock
type({ map: Tree })(GameState.prototype, "trees");
type({ map: Rock })(GameState.prototype, "rocks");

// Define the game room
class NumberblocksRoom extends Room {
    onCreate(options) {
        console.log("NumberblocksRoom created!", options);
        
        // Initialize room state
        this.setState(new GameState());
        
        // Set maximum number of clients
        this.maxClients = 4;
        
        // Set frequency of patches to send
        this.setPatchRate(1000 / 30); // 30 fps
        
        // Set simulation interval for server-side logic
        this.setSimulationInterval(() => this.update());
        
        // Setup operator spawning system
        this.spawnTimer = 0;
        this.spawnInterval = this.getRandomSpawnInterval();
        this.maxOperators = 10;
        
        // Setup static numberblocks
        this.createStaticNumberblock("static1", 2, 0, 0, -5);
        this.createStaticNumberblock("static2", 3, 5, 0, -5);
        this.createStaticNumberblock("static3", 4, -5, 0, -5);
        this.createStaticNumberblock("static4", 5, 0, 0, -10);
        this.createStaticNumberblock("static5", 1, 5, 0, -10);
        
        console.log("Room initialized with GameState:", this.state);
        
        // Listen for input messages from clients
        this.onMessage("input", (client, message) => {
            // Check for version 2 (new input-based system)
            if (!message.version || message.version < 2) {
                return; // Ignore old messages
            }
            
            const player = this.state.players.get(client.sessionId);
            if (player && player.input) {
                // Update the InputState schema with the incoming data
                player.input.keys.w = message.keys.w || false;
                player.input.keys.a = message.keys.a || false;
                player.input.keys.s = message.keys.s || false;
                player.input.keys.d = message.keys.d || false;
                player.input.keys.space = message.keys.space || false;
                
                if (message.mouseDelta) {
                    player.input.mouseDelta.x = message.mouseDelta.x || 0;
                    player.input.mouseDelta.y = message.mouseDelta.y || 0;
                }
                
                // Update view mode if provided
                if (message.viewMode) {
                    player.input.viewMode = message.viewMode;
                }
                
                console.log(`Received input from player ${client.sessionId}:`, 
                    player.input.keys.w ? "W" : "", 
                    player.input.keys.a ? "A" : "", 
                    player.input.keys.s ? "S" : "", 
                    player.input.keys.d ? "D" : "");
            }
        });
        
        // Keep the existing move message handler for backward compatibility
        this.onMessage("move", (client, message) => {
            const player = this.state.players.get(client.sessionId);
            if (player) {
                // Validate movement with speed limit
                const speedLimit = 5.0 * (1/30); // moveSpeed * delta
                const dx = message.x - player.x;
                const dz = message.z - player.z;
                
                // Simple distance check for speed hacking prevention
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance <= speedLimit * 2) { // Allow some flexibility with speed
                    player.x = message.x;
                    player.y = message.y;
                    player.z = message.z;
                    player.rotationY = message.rotationY;
                    player.pitch = message.pitch;
                    
                    // Debug log occasional position updates (every 5 seconds)
                    if (Math.random() < 0.01) {
                        console.log(`Player ${client.sessionId} at position: (${player.x.toFixed(2)}, ${player.y.toFixed(2)}, ${player.z.toFixed(2)})`);
                    }
                } else {
                    console.log(`Rejected movement from ${client.sessionId}: too fast (${distance.toFixed(2)} > ${speedLimit.toFixed(2)})`);
                    // Send correction message
                    client.send("correction", {
                        x: player.x,
                        y: player.y,
                        z: player.z
                    });
                }
            }
        });
        
        this.onMessage("collectOperator", (client, message) => {
            const player = this.state.players.get(client.sessionId);
            const operator = this.state.operators.get(message.id);
            
            if (player && operator) {
                // Set the player's operator explicitly
                player.operator = operator.type;
                
                // Apply operator effect
                if (operator.type === "plus") {
                    player.value++;
                } else if (operator.type === "minus" && player.value > 1) {
                    player.value--;
                }
                
                // Remove operator from state
                this.state.operators.delete(operator.id);
                console.log(`Player ${client.sessionId} collected ${operator.type} operator`);
            }
        });
        
        this.onMessage("numberblockCollision", (client, message) => {
            const player = this.state.players.get(client.sessionId);
            const targetId = message.targetId;
            let target;
            
            // Check if target is another player or a static numberblock
            if (this.state.players.has(targetId)) {
                target = this.state.players.get(targetId);
            } else if (this.state.staticNumberblocks.has(targetId)) {
                target = this.state.staticNumberblocks.get(targetId);
            }
            
            if (player && target) {
                // Handle the collision based on operator
                if (player.operator === "plus") {
                    player.value += target.value;
                    player.operator = null;
                } else if (player.operator === "minus" && player.value > target.value) {
                    player.value -= target.value;
                    player.operator = null;
                }
                
                // If target was a static numberblock, we don't change it
                // If target was another player, we'd need additional logic here
            }
        });
    }
    
    update() {
        // Calculate delta time (assuming 30fps)
        const deltaTime = 1/30;
        
        // Process player inputs and update positions
        this.state.players.forEach((player, sessionId) => {
            // Skip if no input data
            if (!player.input) return;
            
            // Handle player movement based on input state
            this.updatePlayerFromInput(player, deltaTime);
        });
        
        // Spawn operators periodically
        this.spawnTimer += deltaTime;
        if (this.spawnTimer >= this.spawnInterval && Object.keys(this.state.operators).length < this.maxOperators) {
            this.spawnOperator();
            this.spawnTimer = 0;
            this.spawnInterval = this.getRandomSpawnInterval();
        }
    }
    
    // Update player position based on input state
    updatePlayerFromInput(player, deltaTime) {
        // Skip if no input
        if (!player.input || !player.input.keys) return;
        
        const input = player.input;
        const speed = 5.0 * deltaTime;
        
        // Handle rotation from mouse movement
        if (input.mouseDelta) {
            const sensitivity = 0.002;
            player.rotationY += input.mouseDelta.x * sensitivity;
            
            // Only update pitch in first-person mode
            if (input.viewMode === "first-person") {
                player.pitch += input.mouseDelta.y * sensitivity;
                // Clamp pitch to prevent flipping
                player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.pitch));
            }
        }
        
        // Handle movement
        let dx = 0, dz = 0;
        if (input.keys.w) {
            dx += Math.sin(player.rotationY) * speed;
            dz += Math.cos(player.rotationY) * speed;
        }
        if (input.keys.s) {
            dx -= Math.sin(player.rotationY) * speed;
            dz -= Math.cos(player.rotationY) * speed;
        }
        if (input.keys.a) {
            dx += Math.sin(player.rotationY - Math.PI/2) * speed;
            dz += Math.cos(player.rotationY - Math.PI/2) * speed;
        }
        if (input.keys.d) {
            dx += Math.sin(player.rotationY + Math.PI/2) * speed;
            dz += Math.cos(player.rotationY + Math.PI/2) * speed;
        }
        
        // Apply movement
        player.x += dx;
        player.z += dz;
        
        // Handle Q/E rotation
        if (input.keys.q) {
            player.rotationY += 2.0 * deltaTime; // Turn left
        }
        if (input.keys.e) {
            player.rotationY -= 2.0 * deltaTime; // Turn right
        }
        
        // Handle jumping
        if (input.keys.space && player.y === 1) {
            player.velocityY = 0.2; // Jump velocity
        }
        
        // Apply gravity
        player.velocityY += -0.01; // Simple gravity
        player.y += player.velocityY;
        
        // Floor collision
        if (player.y < 1) {
            player.y = 1;
            player.velocityY = 0;
        }
    }
    
    // Get a random spawn interval between 5-10 seconds
    getRandomSpawnInterval() {
        return 5 + Math.random() * 5; // 5-10 seconds
    }
    
    // Spawn a new operator
    spawnOperator() {
        const id = `op_${Math.floor(Math.random() * 10000)}`;
        const type = Math.random() > 0.5 ? "plus" : "minus";
        
        // Create operator with random position
        const operator = new Operator();
        operator.id = id;
        operator.type = type;
        
        // Set random position (40x40 map)
        const mapSize = 40;
        operator.x = (Math.random() * mapSize) - (mapSize / 2);
        operator.y = 0.6; // Slightly above ground
        operator.z = (Math.random() * mapSize) - (mapSize / 2);
        
        // Add to state
        this.state.operators[id] = operator;
        console.log(`Spawned ${type} operator at (${operator.x.toFixed(2)}, ${operator.y}, ${operator.z.toFixed(2)})`);
    }
    
    // Create a static numberblock (for players to interact with)
    createStaticNumberblock(id, value, x, y, z) {
        const staticBlock = new StaticNumberblock();
        staticBlock.value = value;
        staticBlock.x = x;
        // Set Y position to 0 (ground level)
        staticBlock.y = 0;
        staticBlock.z = z;
        
        this.state.staticNumberblocks[id] = staticBlock;
        console.log(`Created static numberblock with ID ${id}, value ${value} at (${x}, ${staticBlock.y}, ${z})`);
    }
    
    onJoin(client, options) {
        console.log(`Client joined: ${client.sessionId}`);
        
        // Create a new player instance
        const player = new Player();
        
        // Set initial player position
        player.x = 0;
        player.y = 1;
        player.z = 5; // Start slightly behind origin
        
        // Set player value and other properties
        player.value = 1;
        // Use client ID as the player name for now
        player.name = client.sessionId;
        player.color = this.getColorForPlayer(Object.keys(this.state.players).length);
        
        // Add player to game state - using .set() method for MapSchema
        this.state.players.set(client.sessionId, player);
        
        console.log(`Player ${player.name} (${client.sessionId}) joined with color ${player.color}`);
        console.log(`Current players in room:`, JSON.stringify(this.state.players));
        console.log(`Total players:`, this.state.players.size);
    }
    
    onLeave(client, consented) {
        console.log(`${client.sessionId} left the game`);
        
        // Remove player from room state - use delete() method for MapSchema
        this.state.players.delete(client.sessionId);
        
        console.log(`Player ${client.sessionId} removed. Remaining players: ${this.state.players.size}`);
    }
    
    // Get a distinct color for each player
    getColorForPlayer(index) {
        const colors = [
            "#FF0000", // Red
            "#00FF00", // Green
            "#0000FF", // Blue
            "#FFFF00"  // Yellow
        ];
        return colors[index % colors.length];
    }
}

// Create Express app and HTTP server
const app = express();
const server = http.createServer(app);

// Set up static file serving
app.use(express.static(path.join(__dirname, 'client')));

// Serve the main index.html
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'client', 'index.html'));
});

// Create and attach Colyseus server
const gameServer = new Server({
    server,
    express: app
});

// Define room handlers
gameServer.define("numberblocks", NumberblocksRoom);

// Start server
const port = process.env.PORT || 3000;
server.listen(port, () => {
    console.log(`Numberblocks game server is running on http://localhost:${port}`);
});
 
 
===================================================== 
FILE: package.json 
===================================================== 
 
{
  "name": "numberblocks",
  "version": "1.0.0",
  "description": "A 3D multiplayer browser-based game inspired by the Numberblocks educational show. Players control Numberblock characters and interact with operators in a fun mathematical environment.",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "colyseus": "^0.16.3",
    "express": "^4.21.2"
  },
  "devDependencies": {
    "nodemon": "^3.1.9"
  }
}
 
 
===================================================== 
FILE: client\index.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numberblocks Game</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        #game-canvas { display: block; width: 100vw; height: 100vh; }
        #lock-instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 999;
        }
        #game-hud {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            z-index: 100;
        }
        .hud-value {
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
            text-align: right;
        }
        #multiplayer-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 5px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            width: 120px;
            z-index: 999;
            font-size: 12px;
            display: block;
            transition: all 0.3s ease;
        }
        #player-list-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #player-list-header h3 {
            margin: 0;
            padding: 0;
            font-size: 14px;
        }
        #player-list {
            margin-top: 5px;
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            transition: height 0.3s ease;
        }
        .player-entry {
            padding: 3px;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            font-size: 11px;
            background-color: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        .player-color {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
            flex-shrink: 0;
        }
        .player-info {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #collapse-icon {
            transition: transform 0.3s ease;
        }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    
    <div id="lock-instructions">
        <h2>Numberblocks Game</h2>
        <p>Click anywhere to enable controls</p>
        <ul>
            <li>Move: WASD or Arrow Keys</li>
            <li>Jump: Space</li>
            <li>Look: Mouse</li>
            <li>Turn: Q & E Keys</li>
        </ul>
    </div>
    
    <!-- Multiplayer panel - Players List -->
    <div id="multiplayer-panel">
        <div id="player-list-header">
            <h3>Players <span id="player-count">(0)</span></h3>
            <span id="collapse-icon">▼</span>
        </div>
        <div id="player-list"></div>
    </div>
    
    <!-- Game HUD -->
    <div id="game-hud"></div>
    
    <!-- Three.js library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/renderers/CSS2DRenderer.js"></script>
    
    <!-- Colyseus client library -->
    <script src="https://unpkg.com/colyseus.js@^0.16.3/dist/colyseus.js"></script>
    
    <!-- Numberblocks game scripts -->
    <script src="js/collision.js"></script>
    <script src="js/numberblock.js"></script>
    <script src="js/operator.js"></script>
    
    <!-- Entity System -->
    <script src="js/Entity.js"></script>
    <script src="js/Player.js"></script>
    <script src="js/NPC.js"></script>
    <script src="js/EntityFactory.js"></script>
    
    <!-- Network System (Modular) -->
    <script src="js/network-core.js"></script>
    <script src="js/player-sync.js"></script>
    <script src="js/entity-sync.js"></script>
    <script src="js/player-ui.js"></script>
    
    <script src="js/controls.js"></script>
    <script src="js/main-fixed.js"></script>
</body>
</html>
 
 
===================================================== 
FILE: client\css\styles.css 
===================================================== 
 
/* Reset default margins and padding */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
}

body, html {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background-color: #000;
}

/* Make the canvas fill the entire screen */
#game-canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* Fix for horizontal bar issue - ensuring no elements create unwanted artifacts */
canvas {
    position: fixed;
    top: 0;
    left: 0;
    outline: none;
}

/* Controls info overlay */
.overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    z-index: 100;
}

.overlay h2 {
    margin-bottom: 10px;
}

.overlay p {
    margin-bottom: 15px;
}

.overlay ul {
    list-style-type: none;
    text-align: left;
    margin: 0 auto;
    display: inline-block;
}

.overlay ul li {
    margin-bottom: 5px;
}

/* Game HUD */
.hud {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 10;
    color: white;
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.8);
    background-color: rgba(0, 0, 0, 0.5);
    padding: 10px 15px;
    border-radius: 8px;
    pointer-events: none; /* Allow clicking through the HUD */
}

#player-number-display {
    display: flex;
    align-items: center;
    justify-content: flex-end;
}

#player-value {
    margin-left: 5px;
    font-size: 32px;
}

/* Ensure no overflow elements */
body, html, canvas {
    overflow: hidden;
}
 
 
===================================================== 
FILE: client\js\collision.js 
===================================================== 
 
/**
 * Numberblocks AABB Collision System
 * Uses Axis-Aligned Bounding Boxes for efficient collision detection
 */

// Collection of collidable objects
let collidableObjects = [];
let debugMode = true; // Set to true to see debug logging

// Initialize collision system and collect collidable objects from the scene
function initCollisionSystem(scene) {
    console.log("Initializing collision system...");
    collidableObjects = [];
    
    // Traverse the scene to find all collidable objects
    scene.traverse((object) => {
        if (object.isMesh && object.userData && object.userData.collidable === true) {
            collidableObjects.push(object);
            if (debugMode) console.log(`Added collidable object: ${object.name || 'unnamed object'}`);
        }
    });
    
    console.log(`Collision system initialized with ${collidableObjects.length} collidable objects`);
    return collidableObjects.length;
}

// Add a single object to the collidable objects list
function addCollidableObject(object) {
    if (!object || !(object.isMesh || object.isGroup)) return;
    
    // Mark the object as collidable
    object.userData = object.userData || {};
    object.userData.collidable = true;
    
    // Add a name if it doesn't have one for easier debugging
    if (!object.name) {
        object.name = `collidable_${collidableObjects.length}`;
    }
    
    // Only add if not already in the list
    if (!collidableObjects.includes(object)) {
        collidableObjects.push(object);
        if (debugMode) console.log(`Added collidable object: ${object.name}`);
        
        // If it's a group, also make all children collidable
        if (object.isGroup && object.children) {
            object.children.forEach(child => {
                if (child.isMesh) {
                    child.userData = child.userData || {};
                    child.userData.collidable = true;
                    collidableObjects.push(child);
                    if (debugMode) console.log(`Added child collidable object: ${child.name || 'unnamed child'}`);
                }
            });
        }
    }
}

// Create or update a bounding box for a mesh
function updateAABB(mesh) {
    if (!mesh) return null;
    
    // Use Three.js Box3 to create a bounding box from the mesh
    const box = new THREE.Box3().setFromObject(mesh);
    return box;
}

// Check if two bounding boxes intersect
function checkCollision(boxA, boxB) {
    if (!boxA || !boxB) return false;
    return boxA.intersectsBox(boxB);
}

// Get the minimum translation vector to resolve a collision
function getCollisionResponse(boxA, boxB) {
    // Create a box that represents the intersection
    const intersection = new THREE.Box3();
    intersection.copy(boxA).intersect(boxB);
    
    // Get the size of the intersection
    const size = intersection.getSize(new THREE.Vector3());
    
    // Find the minimum penetration axis (x, y, or z)
    let axis, minSize;
    
    if (size.x <= size.y && size.x <= size.z) {
        axis = 'x';
        minSize = size.x;
    } else if (size.y <= size.x && size.y <= size.z) {
        axis = 'y';
        minSize = size.y;
    } else {
        axis = 'z';
        minSize = size.z;
    }
    
    // Return the direction and amount to move
    const response = {
        axis: axis,
        depth: minSize,
        direction: new THREE.Vector3()
    };
    
    // Calculate the direction to move (away from the obstacle)
    const centerA = boxA.getCenter(new THREE.Vector3());
    const centerB = boxB.getCenter(new THREE.Vector3());
    
    if (axis === 'x') {
        response.direction.x = centerA.x < centerB.x ? -1 : 1;
    } else if (axis === 'y') {
        response.direction.y = centerA.y < centerB.y ? -1 : 1;
    } else {
        response.direction.z = centerA.z < centerB.z ? -1 : 1;
    }
    
    return response;
}

// Check collisions for the player against all collidable objects
function checkPlayerCollisions(playerMesh, controlsObject) {
    if (!playerMesh || !controlsObject || collidableObjects.length === 0) {
        return { collision: false, grounded: false };
    }
    
    // Update player bounding box
    const playerBox = updateAABB(playerMesh);
    let hasCollision = false;
    let isGrounded = false;
    
    // Check against all collidable objects
    for (const obstacle of collidableObjects) {
        // Skip player's own mesh
        if (obstacle === playerMesh) continue;
        
        const obstacleBox = updateAABB(obstacle);
        if (checkCollision(playerBox, obstacleBox)) {
            hasCollision = true;
            if (debugMode) console.log(`Collision detected with ${obstacle.name || 'unnamed object'}`);
            
            // Handle the collision and check if we're standing on something
            const collisionResult = handleCollision(playerBox, obstacleBox, controlsObject);
            if (collisionResult.landedOnTop) {
                isGrounded = true;
            }
        }
    }
    
    return { collision: hasCollision, grounded: isGrounded };
}

// Apply collision response and return collision info
function handleCollision(playerBox, obstacleBox, controlsObject) {
    const response = getCollisionResponse(playerBox, obstacleBox);
    
    // Apply a small buffer to prevent getting stuck
    const buffer = 0.1;
    let landedOnTop = false;
    
    // Apply the collision response to the controls object
    if (response.axis === 'x') {
        controlsObject.position.x += (response.depth + buffer) * response.direction.x;
    } else if (response.axis === 'y') {
        // For Y-axis collisions, we need to determine if we landed on top
        if (response.direction.y > 0) {
            // We hit the bottom of something
            controlsObject.position.y += (response.depth + buffer) * response.direction.y;
        } else {
            // We landed on top of something
            controlsObject.position.y += (response.depth + buffer) * response.direction.y;
            landedOnTop = true;
            
            // Stop any downward velocity if we're using physics
            if (controlsObject.userData && controlsObject.userData.velocity) {
                controlsObject.userData.velocity.y = 0;
            }
        }
    } else {
        controlsObject.position.z += (response.depth + buffer) * response.direction.z;
    }
    
    return { landedOnTop };
}

// Mark objects in the scene as collidable
function markAllObjectsAsCollidable(scene) {
    scene.traverse(object => {
        // Skip the player, camera, lights, and ground
        if (object.name === 'ground' || 
            object.name === 'player' || 
            object.isLight || 
            object.isCamera) {
            return;
        }
        
        // Mark all meshes that aren't the player, lights, or ground as collidable
        if (object.isMesh) {
            object.userData = object.userData || {};
            object.userData.collidable = true;
            
            // Add it to our collidable objects array if not already there
            if (!collidableObjects.includes(object)) {
                collidableObjects.push(object);
                if (debugMode) console.log(`Auto-marked as collidable: ${object.name || 'unnamed mesh'}`);
            }
        }
    });
    
    console.log(`Total collidable objects after auto-marking: ${collidableObjects.length}`);
}

// No modules export - functions are accessible globally for traditional script inclusion
 
 
===================================================== 
FILE: client\js\controls.js 
===================================================== 
 
// Numberblocks game - First-person controls implementation

// Global variables
window.moveForward = false;
window.moveBackward = false;
window.moveLeft = false;
window.moveRight = false;
window.turnLeft = false;    // New variable for Q key turning
window.turnRight = false;   // New variable for E key turning
window.canJump = false;
// isFirstPerson is a global variable attached to the window object in main-fixed.js
window.prevTime = performance.now();
window.velocity = new THREE.Vector3();
window.direction = new THREE.Vector3();

// Add input state object for server-based movement
window.inputState = {
  keys: { w: false, a: false, s: false, d: false, space: false, q: false, e: false },
  mouseDelta: { x: 0, y: 0 }
};

// Player settings
window.playerHeight = 2.0;             // Height of camera from ground
window.moveSpeed = 50.0;                // Units per second
window.turnSpeed = 2.0;                // Rotation speed for Q/E turning
window.jumpHeight = 2.0;               // Jump height in units
window.jumpPressed = false;            // Track jump button press

// Add variable for third person camera
window.thirdPersonCameraAngle = 0;  // Angle for the third person camera (in radians)
window.thirdPersonCameraDistance = 5;  // Distance for the third person camera

// Initialize controls for the camera
window.initControls = function(camera, domElement) {
    console.log("Initializing PointerLockControls properly...");

    const controls = new THREE.PointerLockControls(camera, domElement);

    domElement.addEventListener('click', () => {
        controls.lock();
    });

    controls.addEventListener('lock', () => {
        if (window.isFirstPerson) {
            document.getElementById('controls-info').style.display = 'none';
        }
        // Always hide cursor when locked, regardless of view mode
        document.body.style.cursor = 'none';
    });

    controls.addEventListener('unlock', () => {
        if (window.isFirstPerson) {
            document.getElementById('controls-info').style.display = 'block';
        }
        // Always show cursor when unlocked, regardless of view mode
        document.body.style.cursor = 'auto';
    });

    // Keyboard listeners for movement remain as-is
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    
    // Add mouse movement tracking for input state
    document.addEventListener('mousemove', (event) => {
        if (document.pointerLockElement) {
            window.inputState.mouseDelta.x += event.movementX;
            window.inputState.mouseDelta.y += event.movementY;
        }
    });

    return controls;
}

// Key down event handler
function onKeyDown(event) {
    // Skip if we're in an input field or textarea
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
        return;
    }
    
    // Map key code to action
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            window.moveForward = true;
            window.inputState.keys.w = true;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            window.moveLeft = true;
            window.inputState.keys.a = true;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            window.moveBackward = true;
            window.inputState.keys.s = true;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            window.moveRight = true;
            window.inputState.keys.d = true;
            break;
            
        case 'KeyQ':
            window.turnLeft = true;
            window.inputState.keys.q = true;
            break;
            
        case 'KeyE':
            window.turnRight = true;
            window.inputState.keys.e = true;
            break;
            
        case 'Space':
            window.inputState.keys.space = true;
            if (window.canJump) {
                // Apply a physically accurate jump velocity
                window.velocity.y = Math.sqrt(window.jumpHeight * 2 * 9.8);
                window.canJump = false;
            }
            break;
    }
}

// Key up event handler
function onKeyUp(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            window.moveForward = false;
            window.inputState.keys.w = false;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            window.moveLeft = false;
            window.inputState.keys.a = false;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            window.moveBackward = false;
            window.inputState.keys.s = false;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            window.moveRight = false;
            window.inputState.keys.d = false;
            break;
            
        case 'KeyQ':
            window.turnLeft = false;
            window.inputState.keys.q = false;
            break;
            
        case 'KeyE':
            window.turnRight = false;
            window.inputState.keys.e = false;
            break;
            
        case 'Space':
            window.inputState.keys.space = false;
            break;
    }
}

// Update controls - call this in the animation loop
window.updateControls = function(controls, delta) {
    if (!controls.isLocked) return;

    // Update controls is still needed for local movement
    // But actual position updates will now be driven by the server
    
    // Handle directional movement
    if (window.moveForward) controls.moveForward(window.moveSpeed * delta);
    if (window.moveBackward) controls.moveForward(-window.moveSpeed * delta);
    if (window.moveLeft) controls.moveRight(-window.moveSpeed * delta);
    if (window.moveRight) controls.moveRight(window.moveSpeed * delta);
    
    // Handle turning with Q/E keys
    if (window.turnLeft || window.turnRight) {
        // Create rotation quaternion for Q/E rotation around Y axis
        const rotationAngle = (window.turnLeft ? 1 : -1) * window.turnSpeed * delta;
        const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(0, 1, 0), // Rotate around y-axis only
            rotationAngle
        );
        
        // Apply rotation to the camera's quaternion directly
        controls.getObject().quaternion.multiply(rotationQuaternion);
    }

    // Apply gravity
    window.velocity.y -= 9.8 * delta;
    controls.getObject().position.y += window.velocity.y * delta;

    // Ground collision
    if (controls.getObject().position.y < window.playerHeight) {
        window.velocity.y = 0;
        controls.getObject().position.y = window.playerHeight;
        window.canJump = true;
    }
}
 
 
===================================================== 
FILE: client\js\entity-sync.js 
===================================================== 
 
// Numberblocks game - Entity synchronization module
// Handles entity synchronization (operators, static numberblocks)

// Helper functions for visual management
function createOperatorVisual(operator, operatorId) {
    try {
        const visual = new OperatorsVisual(operator);
        if (!visuals.operators) visuals.operators = {};
        visuals.operators[operatorId] = visual;
        
        if (window.scene) {
            window.scene.add(visual.group || visual.mesh);
        }
        
        // Setup change listener
        operator.onChange(() => {
            if (visuals.operators[operatorId]) {
                visuals.operators[operatorId].update(operator);
            }
        });
    } catch (error) {
        console.error(`Error creating operator visual (${operatorId}):`, error);
    }
}

function removeOperatorVisual(operatorId) {
    try {
        if (visuals.operators && visuals.operators[operatorId]) {
            if (window.scene) {
                window.scene.remove(visuals.operators[operatorId].group || 
                                  visuals.operators[operatorId].mesh);
            }
            delete visuals.operators[operatorId];
        }
    } catch (error) {
        console.error(`Error removing operator visual (${operatorId}):`, error);
    }
}

function createStaticNumberblockVisual(block, blockId) {
    try {
        const visual = new StaticNumberblocksVisual(block);
        if (!visuals.staticNumberblocks) visuals.staticNumberblocks = {};
        visuals.staticNumberblocks[blockId] = visual;
        
        if (window.scene) {
            window.scene.add(visual.group || visual.mesh);
        }
        
        // Setup change listener
        block.onChange(() => {
            if (visuals.staticNumberblocks[blockId]) {
                visuals.staticNumberblocks[blockId].update(block);
            }
        });
    } catch (error) {
        console.error(`Error creating static numberblock visual (${blockId}):`, error);
    }
}

function removeStaticNumberblockVisual(blockId) {
    try {
        if (visuals.staticNumberblocks && visuals.staticNumberblocks[blockId]) {
            if (window.scene) {
                window.scene.remove(visuals.staticNumberblocks[blockId].group || 
                                  visuals.staticNumberblocks[blockId].mesh);
            }
            delete visuals.staticNumberblocks[blockId];
        }
    } catch (error) {
        console.error(`Error removing static numberblock visual (${blockId}):`, error);
    }
}

// Setup room listeners
function setupRoomListeners() {
    if (!window.room) {
        console.error("No room available!");
        return;
    }

    window.room.onStateChange.once((state) => {
        console.log("✅ State synchronized, setting up listeners.");

        // Confirm 'players' is a MapSchema before adding listeners
        if (state.players && typeof state.players.onAdd === 'function') {
            state.players.onAdd((player, sessionId) => {
                console.log(`Player ${sessionId} joined.`);
                setupPlayerListeners(player, sessionId);
            });

            state.players.onRemove((player, sessionId) => {
                console.log(`Player ${sessionId} left.`);
                removePlayerVisual(sessionId);
            });

            state.players.forEach((player, sessionId) => {
                console.log(`Existing player: ${sessionId}`);
                setupPlayerListeners(player, sessionId);
            });
        } else {
            console.error("❌ state.players is not a valid MapSchema");
        }

        // Operators collection listeners
        if (state.operators && typeof state.operators.onAdd === 'function') {
            state.operators.onAdd((operator, operatorId) => {
                createOperatorVisual(operator, operatorId);
            });

            state.operators.onRemove((operator, operatorId) => {
                removeOperatorVisual(operatorId);
            });

            state.operators.forEach((operator, operatorId) => {
                createOperatorVisual(operator, operatorId);
            });
        } else {
            console.error("❌ state.operators is not a valid MapSchema");
        }

        // Static Numberblocks listeners
        if (state.staticNumberblocks && typeof state.staticNumberblocks.onAdd === 'function') {
            state.staticNumberblocks.onAdd((block, blockId) => {
                createStaticNumberblockVisual(block, blockId);
            });

            state.staticNumberblocks.onRemove((block, blockId) => {
                removeStaticNumberblockVisual(blockId);
            });

            state.staticNumberblocks.forEach((block, blockId) => {
                createStaticNumberblockVisual(block, blockId);
            });
        } else {
            console.error("❌ state.staticNumberblocks is not a valid MapSchema");
        }

        console.log("✅ Room listeners fully set up.");
    });
}

// Define Operators Visual class
window.OperatorsVisual = class OperatorsVisual {
    constructor(operatorData) {
        // Store operator data
        this.id = operatorData.id;
        this.type = operatorData.type === "plus" ? "plus" : "minus";
        
        // Use the OperatorManager to create the operator instead of creating meshes directly
        if (window.operatorManager) {
            this.operator = window.operatorManager.createOperatorFromServer(
                this.id,
                this.type,
                operatorData.x || 0,
                operatorData.y || 0.6,
                operatorData.z || 0
            );
            
            // Use the operator's group as our visual representation
            this.group = this.operator.group || this.operator.mesh;
        } else {
            console.error("OperatorManager not available - can't create operator visual");
            // Create a fallback visual so we don't crash
            this.createFallbackMesh(this.type === "plus" ? 0x00ff00 : 0xff0000);
        }
    }
    
    // Create a simple fallback mesh if operatorManager is not available
    createFallbackMesh(color) {
        this.group = new THREE.Group();
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const material = new THREE.MeshBasicMaterial({ color });
        this.mesh = new THREE.Mesh(geometry, material);
        this.group.add(this.mesh);
    }
    
    update(operatorData) {
        if (!operatorData) return;
        
        // Use the OperatorManager to update the operator's position
        if (window.operatorManager && this.id) {
            window.operatorManager.updateOperatorFromServer(
                this.id,
                operatorData.x,
                operatorData.y,
                operatorData.z
            );
        } else if (this.group) {
            // Fallback update directly if OperatorManager not available
            this.group.position.set(
                operatorData.x,
                operatorData.y,
                operatorData.z
            );
        }
        
        // Update type if changed
        if (operatorData.type !== undefined && this.type !== operatorData.type) {
            this.type = operatorData.type;
            console.log(`Operator ${this.id} type changed to ${this.type}`);
            // Currently we don't handle type changes - would need to remove and recreate
        }
    }
    
    // Method called when this operator is removed
    remove() {
        if (window.operatorManager && this.id) {
            window.operatorManager.removeOperatorByServerId(this.id);
        } else if (this.group && this.group.parent) {
            this.group.parent.remove(this.group);
        }
    }
};

// Define StaticNumberblocks Visual class
window.StaticNumberblocksVisual = class StaticNumberblocksVisual {
    constructor(blockData) {
        this.group = new THREE.Group();
        this.id = blockData.id;
        this.value = blockData.value || 1;
        
        // Create numberblock mesh
        this.createNumberblockMesh();
        
        // Set initial position
        this.update(blockData);
    }
    
    createNumberblockMesh() {
        try {
            // Get color based on value
            const color = window.getColorForValue(this.value);
            
            // Create basic geometry
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshBasicMaterial({ color });
            
            // Create blocks
            const totalHeight = this.value;
            for (let i = 0; i < this.value; i++) {
                const cube = new THREE.Mesh(geometry, material);
                cube.position.y = i;
                this.group.add(cube);
            }
            
            // Add number label (simplified)
            const labelGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.1);
            const labelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const label = new THREE.Mesh(labelGeometry, labelMaterial);
            label.position.y = totalHeight + 0.3;
            label.position.z = 0.6;
            this.group.add(label);
        } catch (error) {
            console.error("Error creating numberblock mesh:", error);
        }
    }
    
    update(blockData) {
        if (!blockData) return;
        
        // Update position
        if (blockData.x !== undefined && 
            blockData.y !== undefined && 
            blockData.z !== undefined) {
            this.group.position.set(
                blockData.x,
                blockData.y,
                blockData.z
            );
        }
        
        // Update value if changed
        if (blockData.value !== undefined && this.value !== blockData.value) {
            this.value = blockData.value;
            
            // Clear group
            while (this.group.children.length > 0) {
                this.group.remove(this.group.children[0]);
            }
            
            // Recreate mesh with new value
            this.createNumberblockMesh();
        }
    }
};

// Make functions available globally
window.setupRoomListeners = setupRoomListeners;
window.createOperatorVisual = createOperatorVisual;
window.removeOperatorVisual = removeOperatorVisual;
window.createStaticNumberblockVisual = createStaticNumberblockVisual;
window.removeStaticNumberblockVisual = removeStaticNumberblockVisual;
 
 
===================================================== 
FILE: client\js\Entity.js 
===================================================== 
 
// Numberblocks game - Base Entity class for all game entities

class Entity {
    constructor({id, name, value, color, x, y, z, rotationY, type}) {
        this.id = id;
        this.name = name || id;
        this.value = value || 1;
        this.color = color; 
        this.type = type; // Type of visual representation ("numberblock", "letterblock", "operator")
        this.x = x || 0;
        this.y = y || 1;
        this.z = z || 0;
        this.rotationY = rotationY || 0;
        
        // Create the mesh - this should be implemented by subclasses
        this.mesh = this.createMesh();
        if (this.mesh) {
            this.mesh.position.set(this.x, this.y, this.z);
            this.mesh.rotation.y = this.rotationY;
            
            // Store a reference to this entity in the mesh's userData
            this.mesh.userData.entity = this;
        }
    }

    // Create the visual representation (mesh) for this entity
    createMesh() {
        let visual = null;
        
        switch (this.type) {
            case 'numberblock':
                // Create a new numberblock visual
                visual = new window.Numberblock(this.value, this.color, this.name);
                return visual.mesh;
                
            case 'operator':
                // Create a new operator visual
                if (typeof window.OperatorsVisual === 'function') {
                    visual = new window.OperatorsVisual(this.value, window.scene);
                    return visual.mesh;
                } else if (typeof window.Operator === 'function') {
                    visual = new window.Operator(this.value, window.scene);
                    return visual.mesh;
                } else {
                    console.warn('Operator class not found');
                    return null;
                }
                
            // Add other entity types here
            default:
                console.warn(`Unknown entity type: ${this.type}`);
                return null;
        }
    }

    // Update the entity's position and rotation
    updatePosition({ x, y, z, rotationY }) {
        if (this.mesh) {
            if (x !== undefined) {
                this.x = x;
                this.mesh.position.x = x;
            }
            
            if (y !== undefined) {
                this.y = y;
                this.mesh.position.y = y;
            }
            
            if (z !== undefined) {
                this.z = z;
                this.mesh.position.z = z;
            }
            
            if (rotationY !== undefined) {
                this.rotationY = rotationY;
                this.mesh.rotation.y = rotationY;
            }
        }
    }

    // Update the entity's value and rebuild the mesh if needed
    updateValue(newValue) {
        if (this.value === newValue) return;
        
        this.value = newValue;
        
        // Remove the old mesh and create a new one
        if (this.mesh && this.mesh.parent) {
            this.mesh.parent.remove(this.mesh);
        }
        
        this.mesh = this.createMesh();
        
        if (this.mesh) {
            this.mesh.position.set(this.x, this.y, this.z);
            this.mesh.rotation.y = this.rotationY;
            this.mesh.userData.entity = this;
            
            // Add to scene if possible
            if (window.scene) {
                window.scene.add(this.mesh);
            }
        }
    }

    // Update the entity's color
    updateColor(newColor) {
        this.color = newColor;
        
        // If the entity is a numberblock, update its color
        if (this.mesh && this.mesh.userData.numberblock) {
            this.mesh.userData.numberblock.updateColor(newColor);
        }
    }

    // Remove entity from scene when destroyed
    destroy() {
        if (this.mesh && this.mesh.parent) {
            this.mesh.parent.remove(this.mesh);
        }
    }
}

// Export to window object for access in other scripts
if (typeof window !== 'undefined') {
    window.Entity = Entity;
}
 
 
===================================================== 
FILE: client\js\EntityFactory.js 
===================================================== 
 
// Numberblocks game - Entity Factory for creating game entities

class EntityFactory {
    constructor() {
        // Registry of visual types
        this.visualRegistry = {
            'players': {
                'numberblock': window.Numberblock,
                // Future types: 'letterblock', etc.
            },
            'npcs': {
                'numberblock': window.Numberblock,
                'operator': window.OperatorsVisual,
                // Future types: 'letterblock', etc.
            }
        };
        
        // Global tracking objects for entity instances
        this.entities = {
            players: {},
            npcs: {},
            staticNumberblocks: {}
        };
    }
    
    // Create an entity from schema data
    createEntity(entityData, entityCategory, options = {}) {
        // Normalize data from schema to entity constructor format
        const params = {
            id: entityData.id || options.id,
            name: entityData.name,
            value: entityData.value,
            color: entityData.color,
            x: entityData.x,
            y: entityData.y,
            z: entityData.z,
            rotationY: entityData.rotationY,
            type: options.type || 'numberblock', // Default visual type
            ...options // Any additional options
        };
        
        let entity;
        
        // Create the appropriate entity type
        switch (entityCategory) {
            case 'players':
                entity = new window.Player(params);
                break;
                
            case 'operators':
                // Handle operators as NPCs with operator type
                params.type = 'operator';
                entity = new window.NPC(params);
                break;
                
            case 'staticNumberblocks':
                // Static numberblocks are NPCs with isStatic=true
                params.isStatic = true;
                entity = new window.NPC(params);
                break;
                
            default:
                // Default to NPC for unknown types
                entity = new window.NPC(params);
                break;
        }
        
        // Store in tracking object
        this.trackEntity(entity, entityCategory, entityData.id || options.id);
        
        return entity;
    }
    
    // Track an entity in the appropriate collection
    trackEntity(entity, category, id) {
        // Determine which collection to use based on category
        let collection;
        
        if (category === 'players') {
            collection = this.entities.players;
        } else if (category === 'operators') {
            collection = this.entities.npcs;
        } else if (category === 'staticNumberblocks') {
            collection = this.entities.staticNumberblocks;
        } else {
            console.warn(`Unknown entity category: ${category}`);
            return;
        }
        
        // Store the entity
        collection[id] = entity;
    }
    
    // Remove an entity from tracking
    removeEntity(category, id) {
        // Determine which collection to use
        let collection;
        
        if (category === 'players') {
            collection = this.entities.players;
        } else if (category === 'operators') {
            collection = this.entities.npcs;
        } else if (category === 'staticNumberblocks') {
            collection = this.entities.staticNumberblocks;
        } else {
            console.warn(`Unknown entity category: ${category}`);
            return;
        }
        
        // Get the entity
        const entity = collection[id];
        
        // If entity exists, destroy it
        if (entity) {
            entity.destroy();
            delete collection[id];
        }
    }
    
    // Get an entity by category and ID
    getEntity(category, id) {
        // Determine which collection to use
        let collection;
        
        if (category === 'players') {
            collection = this.entities.players;
        } else if (category === 'operators') {
            collection = this.entities.npcs;
        } else if (category === 'staticNumberblocks') {
            collection = this.entities.staticNumberblocks;
        } else {
            console.warn(`Unknown entity category: ${category}`);
            return null;
        }
        
        return collection[id] || null;
    }
    
    // Get all entities of a category
    getAllEntities(category) {
        if (category === 'players') {
            return this.entities.players;
        } else if (category === 'operators') {
            return this.entities.npcs;
        } else if (category === 'staticNumberblocks') {
            return this.entities.staticNumberblocks;
        } else {
            console.warn(`Unknown entity category: ${category}`);
            return {};
        }
    }
    
    // Remove an entity from tracking
    removeEntity(category, id) {
        // Determine which collection to use
        let collection;
        
        if (category === 'players') {
            collection = this.entities.players;
        } else if (category === 'operators') {
            collection = this.entities.npcs;
        } else if (category === 'staticNumberblocks') {
            collection = this.entities.staticNumberblocks;
        } else {
            console.warn(`Unknown entity category: ${category}`);
            return;
        }
        
        // If the entity exists in the collection
        if (collection[id]) {
            // Clean up if it has a mesh
            if (collection[id].mesh && window.scene) {
                window.scene.remove(collection[id].mesh);
            }
            
            // Remove from tracking
            delete collection[id];
            return true;
        }
        
        return false;
    }
    
    // Get all entities of a specific category
    getAllEntities(category) {
        if (category === 'players') {
            return this.entities.players;
        } else if (category === 'operators') {
            return this.entities.npcs;
        } else if (category === 'staticNumberblocks') {
            return this.entities.staticNumberblocks;
        }
        
        return {};
    }
    
    // Get a specific entity
    getEntity(category, id) {
        const entities = this.getAllEntities(category);
        return entities[id];
    }
    
    // Force refresh all entities from current room state
    refreshAllEntities(state) {
        console.log("Refreshing all entities from current state");
        
        if (!state) {
            console.error("No state provided for entity refresh");
            return;
        }
        
        // Refresh players
        if (state.players) {
            try {
                // Try different methods to iterate through players
                if (typeof state.players.forEach === 'function') {
                    state.players.forEach((player, id) => {
                        this._refreshPlayerEntity(player, id);
                    });
                } else if (typeof state.players.entries === 'function') {
                    for (const [id, player] of state.players.entries()) {
                        this._refreshPlayerEntity(player, id);
                    }
                } else {
                    const playersObj = state.players.toJSON ? state.players.toJSON() : state.players;
                    for (const id in playersObj) {
                        if (playersObj.hasOwnProperty(id)) {
                            this._refreshPlayerEntity(playersObj[id], id);
                        }
                    }
                }
            } catch (error) {
                console.error("Error refreshing players:", error);
            }
        }
        
        // Refresh operators
        if (state.operators) {
            try {
                // Similar pattern for operators
                if (typeof state.operators.forEach === 'function') {
                    state.operators.forEach((operator, id) => {
                        this._refreshOperatorEntity(operator, id);
                    });
                } else if (typeof state.operators.entries === 'function') {
                    for (const [id, operator] of state.operators.entries()) {
                        this._refreshOperatorEntity(operator, id);
                    }
                } else {
                    const operatorsObj = state.operators.toJSON ? state.operators.toJSON() : state.operators;
                    for (const id in operatorsObj) {
                        if (operatorsObj.hasOwnProperty(id)) {
                            this._refreshOperatorEntity(operatorsObj[id], id);
                        }
                    }
                }
            } catch (error) {
                console.error("Error refreshing operators:", error);
            }
        }
        
        // Update player list UI as well
        if (window.updatePlayerListUI) {
            window.updatePlayerListUI();
        }
    }
    
    // Helper method to refresh a player entity
    _refreshPlayerEntity(player, id) {
        // Skip local player
        if (window.room && id === window.room.sessionId) {
            return;
        }
        
        const entity = this.getEntity('players', id);
        if (entity) {
            // Update existing entity
            entity.updatePosition({
                x: player.x,
                y: player.y,
                z: player.z,
                rotationY: player.rotationY
            });
            entity.updateValue(player.value);
            entity.updateColor(player.color);
        } else {
            // Create new entity if it doesn't exist
            console.log(`Creating entity for player ${id} during refresh`);
            const entityOptions = { id: id, type: 'numberblock' };
            const newEntity = this.createEntity(player, 'players', entityOptions);
            
            // Add to scene
            if (newEntity && newEntity.mesh && window.scene) {
                window.scene.add(newEntity.mesh);
            }
        }
    }
    
    // Helper method to refresh an operator entity
    _refreshOperatorEntity(operator, id) {
        const entity = this.getEntity('operators', id);
        if (entity) {
            // Update existing entity
            entity.updatePosition({
                x: operator.x,
                y: operator.y,
                z: operator.z,
                rotationY: operator.rotationY
            });
        } else {
            // Create new entity if it doesn't exist
            console.log(`Creating entity for operator ${id} during refresh`);
            const entityOptions = { 
                id: id, 
                type: 'operator',
                value: operator.type 
            };
            const newEntity = this.createEntity(operator, 'operators', entityOptions);
            
            // Add to scene
            if (newEntity && newEntity.mesh && window.scene) {
                window.scene.add(newEntity.mesh);
            }
        }
    }
}

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.EntityFactory = EntityFactory;
    // Initialize global entity factory
    window.entityFactory = new EntityFactory();
}

if (typeof module !== 'undefined') {
    module.exports = { EntityFactory };
}
 
 
===================================================== 
FILE: client\js\main-fixed.js 
===================================================== 
 
// Numberblocks game - Main game logic

// Debug support
const DEBUG = false;

function debug(message, isError = false) {
    if (!DEBUG) return;
    
    // Log to console only when debug is enabled
    if (isError) {
        console.error(`[ERROR] ${message}`);
    } else {
        console.log(`[DEBUG] ${message}`);
    }
}

// Game variables
let scene, camera, renderer, controls;
let playerNumberblock;
let operatorManager;
let playerValue = 1;

// Add operator tracking without redeclaring variables
let heldOperator = null;
let lastOperatorSpawn = 0;

// Rotation variables for Q/E keys
let rotationQuaternion = new THREE.Quaternion();
let worldUp = new THREE.Vector3(0, 1, 0);
let rotationAxis = new THREE.Vector3();

// Add global variable for tracking view mode
window.isFirstPerson = true;

// HUD elements
const gameHUD = document.getElementById('game-hud');

// Global variables and UI elements
let viewToggleBtn = null; // Global reference for the view toggle button

// Initialize networking variables
let lastSentPosition = new THREE.Vector3();
let lastSentRotation = 0;
let positionUpdateInterval = 100; // ms between position updates
let lastPositionUpdate = 0;
let inputUpdateInterval = 1000 / 30; // 30Hz input updates
let lastInputUpdate = 0;

// Initialize physics variables and flags
function initPhysics() {
    try {
        debug('Initializing physics');
        
        // Basic physics setup
        window.velocity = new THREE.Vector3(0, 0, 0);
        window.direction = new THREE.Vector3(0, 0, 0);
        window.canJump = false;
        
        // Setup movement flags
        window.moveForward = false;
        window.moveBackward = false;
        window.moveLeft = false;
        window.moveRight = false;
        window.turnLeft = false;
        window.turnRight = false;
        
        // Setup rotation utilities
        window.worldUp = new THREE.Vector3(0, 1, 0);
        window.rotationAxis = new THREE.Vector3();
        window.rotationQuaternion = new THREE.Quaternion();
        
        debug('Physics initialized successfully');
    } catch (error) {
        debug(`Error initializing physics: ${error.message}`, true);
    }
}

// Initialize the floor
function initFloor() {
    try {
        debug('Creating floor');
        
        // Create a larger green floor with darker color
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x114411,
            roughness: 0.8, 
            metalness: 0.2 
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        
        // Rotate and position the floor
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Add a grid helper for visual reference
        const gridHelper = new THREE.GridHelper(100, 100, 0x000000, 0x444444);
        scene.add(gridHelper);
        
        debug('Floor created successfully');
    } catch (error) {
        debug(`Error creating floor: ${error.message}`, true);
    }
}

// Initialize the game
window.onload = function() {
    debug('Window loaded, initializing game...');
    
    // Add view toggle button
    addViewToggleButton();
    
    init();
};

// Add view toggle button to switch between first and third person
function addViewToggleButton() {
    try {
        // Create button if it doesn't exist
        viewToggleBtn = document.getElementById('view-toggle');
        
        if (!viewToggleBtn) {
            viewToggleBtn = document.createElement('button');
            viewToggleBtn.id = 'view-toggle';
            viewToggleBtn.textContent = 'Third Person View';
            viewToggleBtn.style.position = 'absolute';
            viewToggleBtn.style.bottom = '20px';
            viewToggleBtn.style.left = '20px';
            viewToggleBtn.style.zIndex = '100';
            viewToggleBtn.style.padding = '8px 12px';
            viewToggleBtn.style.backgroundColor = '#4CAF50';
            viewToggleBtn.style.color = 'white';
            viewToggleBtn.style.border = 'none';
            viewToggleBtn.style.borderRadius = '4px';
            viewToggleBtn.style.cursor = 'pointer';
            document.body.appendChild(viewToggleBtn);
        }
        
        // Add click event listener
        viewToggleBtn.addEventListener('click', toggleCameraView);
        
        debug('View toggle button added');
    } catch (error) {
        debug(`Error adding view toggle button: ${error.message}`, true);
    }
}

// Toggle between first and third person views
function toggleCameraView() {
    window.isFirstPerson = !window.isFirstPerson;
    
    const viewToggleBtn = document.getElementById('view-toggle');
    if (viewToggleBtn) {
        viewToggleBtn.innerText = window.isFirstPerson ? 'Switch to Third Person' : 'Switch to First Person';
    }
    
    // Store the current position before switching views to ensure consistency
    const currentPosition = playerNumberblock ? playerNumberblock.mesh.position.clone() : null;
    const currentRotation = playerNumberblock ? playerNumberblock.mesh.rotation.y : 0;
    
    if (window.isFirstPerson) {
        debug('Switched to first-person view');
        switchToFirstPersonView();
    } else {
        debug('Switched to third-person view');
        switchToThirdPersonView();
    }
    
    // After switching views, ensure position consistency
    if (currentPosition && playerNumberblock) {
        playerNumberblock.mesh.position.copy(currentPosition);
        playerNumberblock.mesh.rotation.y = currentRotation;
        
        // If in first-person mode, also update controls position
        if (window.isFirstPerson && controls) {
            controls.getObject().position.set(
                currentPosition.x,
                currentPosition.y + 1.0, // Adjust for eye height
                currentPosition.z
            );
        }
        
        // Force a position update to the server to ensure sync
        if (typeof window.room !== 'undefined' && window.room) {
            window.room.send("move", {
                x: playerNumberblock.mesh.position.x,
                y: playerNumberblock.mesh.position.y,
                z: playerNumberblock.mesh.position.z,
                rotation: playerNumberblock.mesh.rotation.y
            });
        }
    }
}

// Switch to first-person view
function switchToFirstPersonView() {
    try {
        debug('Switched to first-person view');
        
        // Set global flag
        window.isFirstPerson = true;
        
        // Check if camera is already a child of controls
        // First make sure we're not trying to add camera as a child of itself
        if (camera.parent !== controls.getObject() && camera !== controls.getObject()) {
            // Remove camera from any previous parent
            if (camera.parent) {
                camera.parent.remove(camera);
            }
            
            // Add camera to controls (only if not already there)
            controls.getObject().add(camera);
        }
        
        // Reset camera position relative to controls
        camera.position.set(0, 0, 0);
        
        // Update button text
        if (viewToggleBtn) {
            viewToggleBtn.textContent = 'Third Person View';
        }
    } catch (error) {
        debug(`Error switching to first-person view: ${error.message}`, true);
    }
}

// Switch to third-person view
function switchToThirdPersonView() {
    try {
        debug('Switched to third-person view');
        
        // Set global flag
        window.isFirstPerson = false;
        
        // Remove camera from controls
        if (camera.parent) {
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            camera.parent.remove(camera);
            
            // Add camera directly to scene
            scene.add(camera);
            
            // Maintain world position
            camera.position.copy(cameraWorldPosition);
        }
        
        // Set up third-person mouse handler if it doesn't exist
        if (!window.thirdPersonMouseHandler) {
            window.thirdPersonMouseHandler = function(event) {
                // Only process if we're in third-person mode and pointer is locked
                if (!window.isFirstPerson && controls.isLocked) {
                    // Skip processing extremely small movements to prevent drift
                    if (Math.abs(event.movementX) > 0.5) {
                        window.thirdPersonCameraAngle -= event.movementX * 0.002;
                    }
                }
            };
        }
        
        // Add mouse movement handler
        document.addEventListener('mousemove', window.thirdPersonMouseHandler);
        
        // Initialize camera angle if it's not set yet
        if (typeof window.thirdPersonCameraAngle === 'undefined') {
            window.thirdPersonCameraAngle = playerNumberblock.mesh.rotation.y + Math.PI;
        }
        
        // Update button text
        if (viewToggleBtn) {
            viewToggleBtn.textContent = 'First Person View';
        }
    } catch (error) {
        debug(`Error switching to third-person view: ${error.message}`, true);
    }
}

// Main initialization function
function init() {
    try {
        debug('Initializing game');
        
        // Create the scene first
        initScene();
        
        // Initialize physics variables and flags
        initPhysics();
        
        // Create the camera
        debug('Creating camera');
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5); // Start a bit back to see the player
        window.camera = camera; // Make globally available
        
        // Setup renderer
        debug('Setting up renderer');
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding; // Better color representation
        renderer.gammaFactor = 2.2; // Standard gamma correction
        
        // Add renderer to document
        document.body.appendChild(renderer.domElement);
        window.renderer = renderer; // Make globally available
        
        // Initialize the floor
        initFloor();
        
        // Setup controls for player movement
        setupPointerLockControls();
        
        // Initialize the player
        initPlayerNumberblock();
        
        // Add static numberblocks
        addStaticNumberblocks();
        
        // Add decorative objects
        addDecorativeObjects();
        
        // Initialize networking for multiplayer
        initNetworkingSystem();
        
        // Add resize event listener
        window.addEventListener('resize', onWindowResize, false);
        
        // Make key handlers available for player movement
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        
        // Make sure global variables are properly declared
        window.scene = scene;
        window.camera = camera;
        window.renderer = renderer;
        window.controls = controls;
        window.playerNumberblock = playerNumberblock;
        window.playerValue = playerValue;
        window.isFirstPerson = true;
        
        // Start the animation loop
        requestAnimationFrame(animate);
        
        debug('Game successfully initialized');
    } catch (error) {
        debug(`Full initialization error: ${error.message}`, true);
        console.error('Full initialization error:', error);
    }
}

// Initialize the scene
function initScene() {
    try {
        debug('Creating scene');
        
        // Create the scene
        scene = new THREE.Scene();
        
        // Make scene globally available
        window.scene = scene;
        
        // Set background color
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        
        // Add fog for depth perception
        scene.fog = new THREE.Fog(0x87CEEB, 10, 100);
        
        // Add proper lighting with reduced intensity
        // Ambient light - provides overall illumination to the scene
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Reduced from 0.8
        scene.add(ambientLight);
        
        // Directional light - mimics sunlight
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reduced from 1.0
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Hemisphere light - for natural outdoor lighting (sky/ground gradient)
        const hemisphereLight = new THREE.HemisphereLight(0xddeeff, 0x3e2200, 0.4); // Reduced from 0.7
        scene.add(hemisphereLight);
        
        // Initialize operator manager and make it globally available
        operatorManager = new OperatorManager(scene);
        window.operatorManager = operatorManager;
        
        debug('Scene created successfully with softer lighting');
    } catch (error) {
        debug(`Error creating scene: ${error.message}`, true);
    }
}

// Setup PointerLock controls
function setupPointerLockControls() {
    debug('Setting up PointerLock controls');
    
    try {
        // Create controls
        controls = new THREE.PointerLockControls(camera, document.body);
        
        // Use the existing instructions element from HTML
        let instructions = document.getElementById('lock-instructions');
        
        // Create instructions if it doesn't exist
        if (!instructions) {
            console.warn('Lock instructions element not found, creating one');
            instructions = document.createElement('div');
            instructions.id = 'lock-instructions';
            instructions.style.position = 'absolute';
            instructions.style.width = '100%';
            instructions.style.height = '100%';
            instructions.style.top = '0';
            instructions.style.left = '0';
            instructions.style.display = 'flex';
            instructions.style.flexDirection = 'column';
            instructions.style.justifyContent = 'center';
            instructions.style.alignItems = 'center';
            instructions.style.color = '#ffffff';
            instructions.style.textAlign = 'center';
            instructions.style.backgroundColor = 'rgba(0,0,0,0.5)';
            instructions.style.cursor = 'pointer';
            instructions.style.zIndex = '1000';
            instructions.innerHTML = '<p>Click to enable controls</p>';
            document.body.appendChild(instructions);
        }
        
        // Function to handle pointer lock change
        function onPointerLockChange() {
            if (document.pointerLockElement === document.body || 
                document.mozPointerLockElement === document.body ||
                document.webkitPointerLockElement === document.body) {
                
                debug('Pointer is now locked');
                if (instructions) {
                    instructions.style.display = 'none';
                }
                
                // Set document focused state
                document.body.classList.add('controls-enabled');
                
                // Set physics flag
                window.canJump = true;
                
                // Set control movement flags
                window.isControlsEnabled = true;
                
                // Start the game loop if not already running
                if (!window.isAnimating) {
                    window.isAnimating = true;
                    animate();
                }
            } else {
                // Only show instructions if we're not in preview mode
                if (!window.previewControlsMode && instructions) {
                    instructions.style.display = 'block';
                }
                debug('Pointer is unlocked');
            }
        }
        
        // Event handler click to lock
        if (instructions) {
            instructions.addEventListener('click', function() {
                controls.lock();
            }, false);
        }
        
        // Add pointer lock events
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        document.addEventListener('mozpointerlockchange', onPointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', onPointerLockChange, false);
        
        // Add error handler
        document.addEventListener('pointerlockerror', function() {
            debug('Pointer lock error', true);
        }, false);
        
        // Add controls to scene
        scene.add(controls.getObject());
        
        // Set first/third person flag
        window.isFirstPerson = true;
        
        // Add keyboard event listeners
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        
        debug('PointerLock controls setup complete');
    } catch (error) {
        debug(`Error setting up PointerLock controls: ${error.message}`, true);
    }
}

// Update player movement physics
function updatePlayerPhysics(delta) {
    if (!controls || !scene || !controls.isLocked) return;
    
    const controlsObject = controls.getObject();
    let playerMoved = false;
    
    // Get current player state from server if available
    if (window.room && window.room.state && window.room.state.players) {
        const player = window.room.state.players.get(window.room.sessionId);
        if (player) {
            // Update the player's position based on the server position
            // This ensures server authority while allowing client-side prediction
            const lerpFactor = 0.2; // Lower value = smoother but more latent transition
            
            // Smoothly interpolate to the server position
            controlsObject.position.x = THREE.MathUtils.lerp(
                controlsObject.position.x, 
                player.x, 
                lerpFactor
            );
            
            controlsObject.position.z = THREE.MathUtils.lerp(
                controlsObject.position.z, 
                player.z, 
                lerpFactor
            );
            
            // Only use server Y position if it's significantly different
            if (Math.abs(controlsObject.position.y - player.y) > 0.5) {
                controlsObject.position.y = player.y;
            }
            
            // If there's a significant desync, instantly correct position
            const distanceSquared = 
                Math.pow(controlsObject.position.x - player.x, 2) + 
                Math.pow(controlsObject.position.z - player.z, 2);
                
            if (distanceSquared > 25) { // More than 5 units away
                controlsObject.position.x = player.x;
                controlsObject.position.z = player.z;
                controlsObject.position.y = player.y;
                console.log("Significant position correction applied");
            }
            
            // Update the player's velocity
            velocity.y = player.velocityY;
            
            // Update Numberblock position and scale to match player value
            updatePlayerNumberblock(player.value);
        }
    }
    
    // Also update UI if the player was observed
    if (playerMoved) {
        // Update game UI elements
        updateGameUI();
    }
}

// Main animation loop
function animate() {
    try {
        // Request next animation frame 
        requestAnimationFrame(animate);
        
        // Calculate delta time
        const time = performance.now();
        const delta = Math.min((time - prevTime) / 1000, 0.1); // Cap delta to avoid large jumps
        
        // Update player movement based on view mode
        if (window.isFirstPerson) {
            updatePlayerPhysics(delta);
        } else {
            updatePlayerPositionThirdPerson(time, delta);
            updateThirdPersonCamera();
        }
        
        // Send input state to server at regular intervals
        if (time - lastInputUpdate > inputUpdateInterval) {
            sendInputUpdate();
            lastInputUpdate = time;
        }
        
        // Force position updates periodically for network
        if (time - lastPositionUpdate > positionUpdateInterval) {
            sendRegularPositionUpdate();
            lastPositionUpdate = time;
        }
        
        // Update remote player representations
        if (window.updateRemotePlayers) {
            window.updateRemotePlayers();
        }
        
        // Update operators
        updateOperators();
        
        // Check for collisions
        if (playerNumberblock) {
            checkCollisions();
        }
        
        // Update debug overlay if it exists
        if (window.DEBUG && window.updateDebugOverlay) {
            window.updateDebugOverlay();
        }
        
        // Render the scene
        renderer.render(scene, camera);
        
        // Update game loop vars
        prevTime = time;
    } catch (error) {
        debug(`Error in animate loop: ${error.message}`, true);
    }
}

// Send input state to the server
function sendInputUpdate() {
    try {
        // Make sure room is available and connected before sending
        if (!window.room || !window.room.connection || window.room.connection.readyState !== WebSocket.OPEN || !window.inputState) {
            if (window.debugOverlay && window.debugOverlay.visible) {
                updateDebugInfo("WebSocket not connected, skipping input update");
            }
            return; // Skip update if connection is not available
        }
        
        // Send input state to server
        window.room.send("input", {
            version: 2, // Version to distinguish from legacy messages
            keys: window.inputState.keys,
            mouseDelta: window.inputState.mouseDelta,
            viewMode: window.isFirstPerson ? "first-person" : "third-person"
        });
        
        // Reset mouse delta after sending
        window.inputState.mouseDelta.x = 0;
        window.inputState.mouseDelta.y = 0;
    } catch (error) {
        console.error("Error sending input update:", error);
    }
}

// Send regular position updates to the server for multiplayer synchronization
function sendRegularPositionUpdate() {
    try {
        // Make sure room is available and connected before sending
        if (!window.room || !window.room.connection || window.room.connection.readyState !== WebSocket.OPEN || 
            typeof window.sendPlayerUpdate !== 'function') {
            if (window.debugOverlay && window.debugOverlay.visible) {
                updateDebugInfo("WebSocket not connected, skipping position update");
            }
            return; // Skip update if connection is not available
        }
        
        let currentPos, currentRot;
        
        // Get current position and rotation based on view mode
        if (window.isFirstPerson && controls) {
            currentPos = controls.getObject().position;
            currentRot = controls.getObject().rotation.y;
        } else if (playerNumberblock && playerNumberblock.mesh) {
            currentPos = playerNumberblock.mesh.position;
            currentRot = playerNumberblock.mesh.rotation.y;
        } else {
            return; // No valid position
        }
        
        // Always send updates (remove threshold check to ensure frequent updates)
        // This ensures other players always see your current position
        
        // Send update to server
        window.sendPlayerUpdate(
            currentPos,
            currentRot,
            window.isFirstPerson ? camera.rotation.x : 0,
            playerValue
        );
        
        // Update last sent values
        lastSentPosition.copy(currentPos);
        lastSentRotation = currentRot;
        
        // Debug log to confirm sending
        if (DEBUG) {
            console.log(`Position update sent: ${currentPos.x.toFixed(2)}, ${currentPos.y.toFixed(2)}, ${currentPos.z.toFixed(2)}`);
        }
    } catch (error) {
        console.error("Error sending regular position update:", error);
    }
}

// Update player position in third-person mode
function updatePlayerPositionThirdPerson(time, delta) {
    try {
        if (!playerNumberblock || !controls) return;
        
        const moveSpeed = 5.0; // Movement speed as specified in memory
        const rotationSpeed = 2.0; // Rotation speed for Q/E keys
        
        // Get camera's current direction vectors, using proper forward/right orientation
        const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        
        // Project to horizontal plane by zeroing Y and normalizing
        const forward = cameraDirection.clone().setY(0).normalize();
        const right = cameraRight.clone().setY(0).normalize();
        
        // Calculate desired movement direction from keyboard input
        const movement = new THREE.Vector3();
        if (window.moveForward) movement.add(forward);
        if (window.moveBackward) movement.sub(forward);
        if (window.moveLeft) movement.sub(right);
        if (window.moveRight) movement.add(right);
        
        // Apply gravity
        window.velocity.y -= 9.8 * delta;
        
        if (movement.length() > 0) {
            movement.normalize().multiplyScalar(moveSpeed * delta);
            
            // Update player position
            playerNumberblock.mesh.position.add(movement);
            
            // Rotate player to face movement direction if moving (and no manual rotation with Q/E)
            if (!window.turnLeft && !window.turnRight) {
                const targetAngle = Math.atan2(movement.x, movement.z);
                playerNumberblock.mesh.rotation.y = targetAngle;
            }
        }
        
        // Update vertical position with gravity
        playerNumberblock.mesh.position.y += window.velocity.y * delta;
        
        // Check for floor collision
        if (playerNumberblock.mesh.position.y < 0.5) {
            window.velocity.y = 0;
            playerNumberblock.mesh.position.y = 0.5;
            window.canJump = true;
        }
        
        // Rotate player using Q/E keys
        if (window.turnLeft) playerNumberblock.mesh.rotation.y += rotationSpeed * delta;
        if (window.turnRight) playerNumberblock.mesh.rotation.y -= rotationSpeed * delta;
        
        // Send position to server for multiplayer
        if (typeof window.room !== 'undefined' && window.room) {
            window.sendPlayerUpdate(
                playerNumberblock.mesh.position, 
                playerNumberblock.mesh.rotation.y,
                0, // pitch not used in third-person
                playerValue
            );
        }
    } catch (error) {
        debug(`Error in updatePlayerPositionThirdPerson: ${error.message}`, true);
    }
}

// Update third-person camera position
function updateThirdPersonCamera() {
    try {
        if (!playerNumberblock || !playerNumberblock.mesh) return;
        
        const distance = 12;      // Camera distance behind the player
        const heightOffset = 8;   // Height offset above the player
        const smoothing = 0.1;    // Smooth camera motion factor
        const rotationSpeed = 0.05;
        
        // Initialize the angle if not set
        if (typeof window.thirdPersonCameraAngle === 'undefined') {
            window.thirdPersonCameraAngle = playerNumberblock.mesh.rotation.y + Math.PI;
        }
        
        // Adjust camera angle with Q/E keys
        if (window.turnLeft) window.thirdPersonCameraAngle += rotationSpeed;
        if (window.turnRight) window.thirdPersonCameraAngle -= rotationSpeed;
        
        // Calculate desired camera position explicitly without cumulative interpolation errors
        const playerPos = playerNumberblock.mesh.position.clone();
        const targetX = playerPos.x - Math.sin(window.thirdPersonCameraAngle) * distance;
        const targetZ = playerPos.z - Math.cos(window.thirdPersonCameraAngle) * distance;
        
        // Ensure camera Y position is always exactly at height offset plus player's midpoint height
        const targetY = playerNumberblock.mesh.position.y + heightOffset;
        
        // Set camera position explicitly without smoothing vertically to prevent drift
        camera.position.set(
            THREE.MathUtils.lerp(camera.position.x, targetX, 0.1),
            targetY, // No vertical smoothing
            THREE.MathUtils.lerp(camera.position.z, targetZ, 0.1)
        );
        
        // Always look at the player's midpoint height directly
        const heightAdjustment = playerNumberblock.getHeight ? playerNumberblock.getHeight() / 2 : 1;
        camera.lookAt(
            playerNumberblock.mesh.position.x,
            targetY - (heightOffset / 2),
            playerNumberblock.mesh.position.z
        );
    } catch (error) {
        debug(`Error in updateThirdPersonCamera: ${error.message}`, true);
    }
}

// Update operators (animate them)
function updateOperators() {
    try {
        // First, update operators managed by the OperatorManager
        if (window.operatorManager) {
            window.operatorManager.update(1/60); // Pass approximate deltaTime
        }
        
        // For backwards compatibility, also check for visuals.operators
        if (window.visuals && window.visuals.operators) {
            // Get all operator visuals
            const operators = window.visuals.operators;
            
            // Calculate deltaTime (approximate)
            const deltaTime = 1/60;
            
            // Animate each operator
            for (const operatorId in operators) {
                const operator = operators[operatorId];
                if (operator && typeof operator.animate === 'function') {
                    operator.animate(deltaTime);
                }
            }
        }
    } catch (error) {
        debug(`Error updating operators: ${error.message}`, true);
    }
}

// Check for collisions with operators and other Numberblocks
function checkCollisions() {
    // Will be implemented with proper collision detection
}

// Update player's Numberblock value
function updatePlayerValue(newValue) {
    try {
        playerValue = newValue;
        
        // Update the Numberblock
        if (playerNumberblock) {
            scene.remove(playerNumberblock.mesh);
            playerNumberblock = new Numberblock(playerValue);
            scene.add(playerNumberblock.mesh);
            
            // Position it correctly based on camera/controls
            if (window.isFirstPerson) {
                playerNumberblock.mesh.position.copy(controls.getObject().position);
                playerNumberblock.mesh.position.y -= 1.0; // Position below camera
                playerNumberblock.mesh.rotation.y = controls.getObject().rotation.y;
            }
        }
        
        // Update HUD
        updateHUD();
        
        debug(`Player value updated to ${playerValue}`);
    } catch (error) {
        debug(`Error updating player value: ${error.message}`, true);
    }
}

// Update the HUD display
function updateHUD() {
    if (gameHUD) {
        gameHUD.innerHTML = `<div class="hud-value">Number: ${playerValue}</div>`;
    }
}

// For Numberblock prototype to enable getHeight() method
if (typeof window.Numberblock === 'undefined') {
    console.log("Creating temporary Numberblock class");
    window.Numberblock = function(value, color) {
        this.value = value || 1;
        this.color = color || "#FFFF00";
        
        // Create a basic mesh for the numberblock
        const geometry = new THREE.BoxGeometry(1, this.value, 1);
        const material = new THREE.MeshStandardMaterial({ color: this.color });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
    };
    
    window.Numberblock.prototype.getHeight = function() {
        return this.value; // Actual height is the value
    };
    
    window.Numberblock.prototype.createNumberblock = function() {
        // Method already called in constructor, but added for compatibility
        return this.mesh;
    };
}

// Handle window resize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Handle keyboard input
function onKeyDown(event) {
    try {
        if (document.activeElement !== document.body) return; // Skip if focused on input
        
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW':
                window.moveForward = true;
                break;
            case 'ArrowLeft':
            case 'KeyA':
                window.moveLeft = true;
                break;
            case 'ArrowDown':
            case 'KeyS':
                window.moveBackward = true;
                break;
            case 'ArrowRight':
            case 'KeyD':
                window.moveRight = true;
                break;
            case 'Space':
                if (window.canJump) {
                    window.velocity.y = 5.0;
                    window.canJump = false;
                }
                break;
            case 'KeyV':
                // Toggle between first and third person view
                toggleCameraView();
                break;
            case 'KeyQ':
                // Turn left
                window.turnLeft = true;
                if (window.isFirstPerson) {
                    // Use quaternion rotation around world up axis (y-axis)
                    rotationAxis.copy(worldUp);
                    const rotationAngle = 0.05; // Same amount as before
                    rotationQuaternion.setFromAxisAngle(rotationAxis, rotationAngle);
                    
                    // Apply to the camera object - this matches how PointerLockControls works
                    controls.getObject().quaternion.premultiply(rotationQuaternion);
                }
                break;
            case 'KeyE':
                // Turn right
                window.turnRight = true;
                if (window.isFirstPerson) {
                    // Use quaternion rotation around world up axis (y-axis)
                    rotationAxis.copy(worldUp);
                    const rotationAngle = -0.05; // Negative for right turn
                    rotationQuaternion.setFromAxisAngle(rotationAxis, rotationAngle);
                    
                    // Apply to the camera object - this matches how PointerLockControls works
                    controls.getObject().quaternion.premultiply(rotationQuaternion);
                }
                break;
        }
    } catch (error) {
        debug(`KeyDown error: ${error.message}`, true);
    }
}

function onKeyUp(event) {
    try {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW':
                window.moveForward = false;
                break;
            case 'ArrowLeft':
            case 'KeyA':
                window.moveLeft = false;
                break;
            case 'ArrowDown':
            case 'KeyS':
                window.moveBackward = false;
                break;
            case 'ArrowRight':
            case 'KeyD':
                window.moveRight = false;
                break;
            case 'KeyQ':
                window.turnLeft = false;
                break;
            case 'KeyE':
                window.turnRight = false;
                break;
        }
    } catch (error) {
        debug(`KeyUp error: ${error.message}`, true);
    }
}

// Add static Numberblocks of various values
function addStaticNumberblocks() {
    debug('Adding static Numberblocks');
    
    try {
        // Define positions and values for static Numberblocks
        const numberblockData = [
            { value: 2, x: 8, z: 3 },
            { value: 3, x: -5, z: 8 },
            { value: 4, x: 15, z: -5 },
            { value: 5, x: -12, z: -8 },
            { value: 6, x: 5, z: -15 }
        ];
        
        // Create each Numberblock
        numberblockData.forEach(data => {
            try {
                const numberblock = new Numberblock(data.value);
                scene.add(numberblock.mesh);
                
                // Fix positioning: Set Y to half the value so bottom is at ground level (y=0)
                // For a block of value 5, the height is 5, so y=2.5 puts the bottom at ground level
                numberblock.mesh.position.set(data.x, data.value / 2, data.z);
                
                // Rotate randomly for variety
                numberblock.mesh.rotation.y = Math.random() * Math.PI * 2;
                
                // Add a small bounce animation
                const initialY = numberblock.mesh.position.y;
                const bounceSpeed = 0.5 + Math.random() * 0.5;
                const bounceHeight = 0.15;
                
                // Store animation data on the mesh for use in animate loop
                numberblock.mesh.userData = {
                    initialY: initialY,
                    bounceSpeed: bounceSpeed,
                    bounceHeight: bounceHeight,
                    bounceOffset: Math.random() * Math.PI * 2 // Random offset for varied motion
                };
            } catch (error) {
                debug(`Error creating static Numberblock: ${error.message}`, true);
            }
        });
        
        debug('Static Numberblocks added');
    } catch (error) {
        debug(`Error adding static Numberblocks: ${error.message}`, true);
    }
}

// Initialize the player's Numberblock
function initPlayerNumberblock() {
    debug('Creating player Numberblock');
    
    try {
        playerNumberblock = new Numberblock(playerValue);
        scene.add(playerNumberblock.mesh);
        playerNumberblock.mesh.position.set(0, 0, 0);
        debug('Player Numberblock created');
        
        // Make player Numberblock globally available for networking
        window.playerNumberblock = playerNumberblock;
        
        // Update HUD
        updateHUD();
        
        // Make Numberblock class available globally
        window.Numberblock = Numberblock;
    } catch (error) {
        debug(`Error creating player Numberblock: ${error.message}`, true);
    }
}

// Initialize networking for multiplayer
function initNetworkingSystem() {
    debug('Initializing networking system');
    
    try {
        console.log("Initializing networking system...");
        
        // Check if initNetworking is defined in network-core.js
        if (typeof window.initNetworking === 'function') {
            debug('Found networking module, attempting to connect...');
            window.initNetworking()
                .then((roomInstance) => {
                    debug('Networking initialized successfully');
                    window.gameRoom = roomInstance; // Store room instance globally
                    window.room = roomInstance; // For compatibility
                    
                    // Setup room event listeners
                    setupRoomEventHandlers(roomInstance);
                    
                    // Create debug overlay if it doesn't exist
                    createDebugOverlay();
                    
                    // Manually trigger player list update after successful connection
                    if (typeof window.updatePlayerListUI === 'function') {
                        setTimeout(window.updatePlayerListUI, 500);
                        setTimeout(window.updatePlayerListUI, 2000);
                    }
                })
                .catch(error => {
                    debug(`Networking error: ${error.message}`, true);
                });
        } else {
            debug('Networking module not detected, continuing in local mode');
        }
    } catch (error) {
        debug(`Error initializing networking: ${error.message}`, true);
    }
}

// Setup room event handlers
function setupRoomEventHandlers(room) {
    if (!room) return;
    
    // Register for player join events
    room.state.players.onAdd = function(player, sessionId) {
        console.log("Player added to room state:", sessionId);
        
        // Call the player join handler if available
        if (typeof window.onPlayerJoin === 'function') {
            window.onPlayerJoin(player);
        }
    };
    
    // Register for player leave events
    room.state.players.onRemove = function(player, sessionId) {
        console.log("Player removed from room state:", sessionId);
        
        // Call the player leave handler if available
        if (typeof window.onPlayerLeave === 'function') {
            window.onPlayerLeave(player);
        }
    };
    
    // Register for player change events
    room.state.players.onChange = function(player, sessionId) {
        // This could be used for player property changes if needed
    };
    
    // Register for state change events
    room.onStateChange(function(state) {
        // This could be used to handle full state changes if needed
    });
}

// Create debug overlay for development
function createDebugOverlay() {
    // Only create if DEBUG is true
    window.DEBUG = false; // Set to true during development
    
    // Create debug overlay element
    const debugOverlay = document.createElement('div');
    debugOverlay.id = 'debug-overlay';
    debugOverlay.style.position = 'absolute';
    debugOverlay.style.top = '10px';
    debugOverlay.style.left = '10px';
    debugOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    debugOverlay.style.color = 'white';
    debugOverlay.style.padding = '10px';
    debugOverlay.style.fontFamily = 'monospace';
    debugOverlay.style.fontSize = '12px';
    debugOverlay.style.display = 'none';
    debugOverlay.style.zIndex = '1000';
    document.body.appendChild(debugOverlay);
    
    // Debug logging function
    window.debugLog = function(...args) {
        if (window.DEBUG) console.log(...args);
    };
    
    // Update debug overlay
    window.updateDebugOverlay = function() {
        if (!window.DEBUG) {
            debugOverlay.style.display = 'none';
            return;
        }
        
        debugOverlay.style.display = 'block';
        
        let content = '';
        
        // Add player position info
        if (window.room && window.room.state && window.room.state.players) {
            const player = window.room.state.players.get(window.room.sessionId);
            if (player && window.playerNumberblock) {
                const clientPos = window.playerNumberblock.mesh.position;
                content += `Position:<br>`;
                content += `Client: x=${clientPos.x.toFixed(2)}, y=${clientPos.y.toFixed(2)}, z=${clientPos.z.toFixed(2)}<br>`;
                content += `Server: x=${player.x.toFixed(2)}, y=${player.y.toFixed(2)}, z=${player.z.toFixed(2)}<br>`;
                content += `<br>Rotation:<br>`;
                content += `Y: ${player.rotationY.toFixed(2)}<br>`;
                content += `Pitch: ${player.pitch.toFixed(2)}<br>`;
            }
        }
        
        // Add input state info
        if (window.inputState) {
            content += `<br>Input:<br>`;
            content += `W: ${window.inputState.keys.w}, `;
            content += `A: ${window.inputState.keys.a}, `;
            content += `S: ${window.inputState.keys.s}, `;
            content += `D: ${window.inputState.keys.d}<br>`;
            content += `Space: ${window.inputState.keys.space}, `;
            content += `Q: ${window.inputState.keys.q}, `;
            content += `E: ${window.inputState.keys.e}<br>`;
            content += `Mouse: x=${window.inputState.mouseDelta.x.toFixed(0)}, y=${window.inputState.mouseDelta.y.toFixed(0)}`;
        }
        
        debugOverlay.innerHTML = content;
    };
    
    // Toggle debug mode with F1 key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'F1') {
            window.DEBUG = !window.DEBUG;
            console.log("Debug mode:", window.DEBUG ? "ON" : "OFF");
        }
    });
}

// Emergency render function - displays a simple scene if initialization fails
function emergencyRender() {
    debug('Attempting emergency render', true);
    
    try {
        // Create a very basic scene
        const emergencyScene = new THREE.Scene();
        emergencyScene.background = new THREE.Color(0x333333);
        
        const emergencyCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10);
        emergencyCamera.position.z = 2;
        
        const emergencyGeometry = new THREE.BoxGeometry(1, 1, 1);
        const emergencyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
        const emergencyCube = new THREE.Mesh(emergencyGeometry, emergencyMaterial);
        emergencyScene.add(emergencyCube);
        
        // Add text to indicate error
        const textDiv = document.createElement('div');
        textDiv.style.position = 'absolute';
        textDiv.style.top = '10px';
        textDiv.style.left = '10px';
        textDiv.style.color = 'white';
        textDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
        textDiv.style.padding = '10px';
        textDiv.style.fontFamily = 'monospace';
        textDiv.textContent = 'Initialization Error! Check console for details.';
        document.body.appendChild(textDiv);
        
        // Render the emergency scene
        renderer.render(emergencyScene, emergencyCamera);
        debug('Emergency render complete');
    } catch (error) {
        debug(`Emergency render failed: ${error.message}`, true);
        alert('Critical rendering error: ' + error.message);
    }
}

// Add decorative objects to the scene
function addDecorativeObjects() {
    try {
        debug('Adding decorative objects');
        
        // Add multiple trees scattered around
        for (let i = 0; i < 20; i++) {
            // Randomize positions but keep away from center
            const distance = 15 + Math.random() * 30;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            
            // Create tree
            createTree(x, 0, z);
        }
        
        // Add some rocks
        for (let i = 0; i < 15; i++) {
            // Randomize positions
            const distance = 10 + Math.random() * 40;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            
            // Create rock
            createRock(x, 0, z);
        }
        
        debug('Decorative objects added successfully');
    } catch (error) {
        debug(`Error adding decorative objects: ${error.message}`, true);
    }
}

// Helper function to create a tree
function createTree(x, y, z) {
    // Create tree trunk (cylinder)
    const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunk.position.set(x, y + 2.5, z);
    trunk.castShadow = true;
    trunk.receiveShadow = true;
    scene.add(trunk);
    
    // Create tree top (cone for evergreen tree)
    const topGeometry = new THREE.ConeGeometry(2, 6, 8);
    const topMaterial = new THREE.MeshStandardMaterial({ color: 0x228822 }); // Green
    const top = new THREE.Mesh(topGeometry, topMaterial);
    top.position.set(x, y + 6, z);
    top.castShadow = true;
    top.receiveShadow = true;
    scene.add(top);
}

// Helper function to create a rock
function createRock(x, y, z) {
    // Randomly scale the rock
    const scale = 0.5 + Math.random() * 1.5;
    
    // Create irregular rock shape using a scaled sphere
    const rockGeometry = new THREE.SphereGeometry(1, 6, 4);
    
    // Randomly deform vertices to make it look more like a rock
    const vertices = rockGeometry.attributes.position;
    for (let i = 0; i < vertices.count; i++) {
        const x = vertices.getX(i);
        const y = vertices.getY(i);
        const z = vertices.getZ(i);
        
        // Apply random offset to vertex
        vertices.setX(i, x + (Math.random() - 0.5) * 0.3);
        vertices.setY(i, y + (Math.random() - 0.5) * 0.3);
        vertices.setZ(i, z + (Math.random() - 0.5) * 0.3);
    }
    
    // Update normals after vertex modification
    rockGeometry.computeVertexNormals();
    
    // Create rock material with random gray shade
    const grayShade = 0.4 + Math.random() * 0.3;
    const rockMaterial = new THREE.MeshStandardMaterial({ 
        color: new THREE.Color(grayShade, grayShade, grayShade),
        roughness: 0.9,
        metalness: 0.1
    });
    
    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
    rock.scale.set(scale, scale * 0.7, scale);
    rock.position.set(x, y + (scale * 0.35), z);
    rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
    rock.castShadow = true;
    rock.receiveShadow = true;
    scene.add(rock);
}
 
 
===================================================== 
FILE: client\js\network-core.js 
===================================================== 
 
// Numberblocks game - Core networking module
// Handles connection to the server and basic network setup

// Network configuration
const endpoint = 'ws://localhost:3000';
let client = null;
let room = null;

// Helper function to generate random colors
function getRandomColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

// Import CSS2D renderer for player names if not already defined
let CSS2DObject;
let CSS2DRenderer;
try {
    // First check if THREE.CSS2D is available (Three.js r137+)
    if (THREE.CSS2D) {
        console.log("Using THREE.CSS2D namespace");
        CSS2DObject = THREE.CSS2D.CSS2DObject;
        CSS2DRenderer = THREE.CSS2D.CSS2DRenderer;
    } 
    // For older Three.js versions
    else if (THREE.CSS2DObject && THREE.CSS2DRenderer) {
        console.log("Using THREE.CSS2DObject directly");
        CSS2DObject = THREE.CSS2DObject;
        CSS2DRenderer = THREE.CSS2DRenderer;
    } 
    else {
        throw new Error("CSS2D modules not found in THREE");
    }
} catch (error) {
    console.warn("CSS2DObject not available, player name labels will not be shown:", error.message);
    
    // Create dummy versions that do nothing to prevent errors
    CSS2DObject = class DummyCSS2DObject {
        constructor(element) {
            this.element = element;
            this.position = new THREE.Vector3();
            this.rotation = new THREE.Euler();
            this.scale = new THREE.Vector3(1, 1, 1);
            this.visible = true;
        }
    };
    
    CSS2DRenderer = class DummyCSS2DRenderer {
        constructor() {
            this.domElement = document.createElement('div');
        }
        setSize() {}
        render() {}
    };
}

// Global tracking of all visuals
const visuals = {
    players: {},
    operators: {},
    staticNumberblocks: {},
    trees: {},
    rocks: {}
};

// Function to get color based on Numberblock value
function getColorForValue(value) {
    // Default colors for Numberblocks 1-10
    const colors = [
        '#FF0000', // 1 - Red
        '#FF7F00', // 2 - Orange
        '#FFFF00', // 3 - Yellow
        '#00FF00', // 4 - Green
        '#0000FF', // 5 - Blue
        '#4B0082', // 6 - Indigo
        '#8B00FF', // 7 - Violet
        '#964B00', // 8 - Brown
        '#808080', // 9 - Gray
        '#800080'  // 10 - Purple
    ];
    
    // Use value as index (adjusted for zero-based array)
    if (value >= 1 && value <= colors.length) {
        return colors[value - 1];
    }
    
    // Fall back to random color for higher values
    return getRandomColor();
}

// Setup automatic reconnection
function setupReconnection(room, client) {
    if (!room) return;
    
    // Handle WebSocket connection error
    room.onError((error) => {
        console.error("Connection error:", error);
        showErrorMessage("Connection error. Trying to reconnect...");
        addReconnectButton();
    });
    
    // Handle WebSocket disconnection
    room.onLeave((code) => {
        console.log(`Client left the room with code: ${code}`);
        showErrorMessage("Connection lost. Trying to reconnect...");
        
        // Attempt to reconnect automatically
        setTimeout(() => {
            console.log("Attempting to reconnect...");
            
            // Call initNetworking again
            initNetworking()
                .then(() => {
                    console.log("Reconnected successfully!");
                    showInfoMessage("Reconnected successfully!");
                    
                    // Remove reconnect button if it exists
                    const reconnectBtn = document.getElementById('reconnect-button');
                    if (reconnectBtn) {
                        reconnectBtn.remove();
                    }
                })
                .catch((e) => {
                    console.error("Failed to reconnect:", e);
                    showErrorMessage("Failed to reconnect. Please try again later.");
                });
        }, 2000);
    });
}

// Show error message
function showErrorMessage(message) {
    // Check if error message container exists
    let errorContainer = document.getElementById('error-message');
    
    // Create error container if it doesn't exist
    if (!errorContainer) {
        errorContainer = document.createElement('div');
        errorContainer.id = 'error-message';
        errorContainer.style.position = 'fixed';
        errorContainer.style.top = '10px';
        errorContainer.style.left = '50%';
        errorContainer.style.transform = 'translateX(-50%)';
        errorContainer.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
        errorContainer.style.color = 'white';
        errorContainer.style.padding = '10px';
        errorContainer.style.borderRadius = '5px';
        errorContainer.style.zIndex = '1000';
        errorContainer.style.transition = 'opacity 0.5s';
        document.body.appendChild(errorContainer);
    }
    
    // Set message
    errorContainer.textContent = message;
    errorContainer.style.opacity = '1';
    
    // Hide message after 5 seconds
    setTimeout(() => {
        errorContainer.style.opacity = '0';
    }, 5000);
}

// Show info message
function showInfoMessage(message) {
    // Check if info message container exists
    let infoContainer = document.getElementById('info-message');
    
    // Create info container if it doesn't exist
    if (!infoContainer) {
        infoContainer = document.createElement('div');
        infoContainer.id = 'info-message';
        infoContainer.style.position = 'fixed';
        infoContainer.style.top = '10px';
        infoContainer.style.left = '50%';
        infoContainer.style.transform = 'translateX(-50%)';
        infoContainer.style.backgroundColor = 'rgba(0, 128, 0, 0.8)';
        infoContainer.style.color = 'white';
        infoContainer.style.padding = '10px';
        infoContainer.style.borderRadius = '5px';
        infoContainer.style.zIndex = '1000';
        infoContainer.style.transition = 'opacity 0.5s';
        document.body.appendChild(infoContainer);
    }
    
    // Set message
    infoContainer.textContent = message;
    infoContainer.style.opacity = '1';
    
    // Hide message after 3 seconds
    setTimeout(() => {
        infoContainer.style.opacity = '0';
    }, 3000);
}

// Add reconnect button
function addReconnectButton() {
    // Check if reconnect button already exists
    if (document.getElementById('reconnect-button')) {
        return;
    }
    
    // Create button
    const reconnectBtn = document.createElement('button');
    reconnectBtn.id = 'reconnect-button';
    reconnectBtn.textContent = 'Reconnect to Server';
    reconnectBtn.style.position = 'fixed';
    reconnectBtn.style.top = '50%';
    reconnectBtn.style.left = '50%';
    reconnectBtn.style.transform = 'translate(-50%, -50%)';
    reconnectBtn.style.padding = '10px 20px';
    reconnectBtn.style.backgroundColor = '#4CAF50';
    reconnectBtn.style.color = 'white';
    reconnectBtn.style.border = 'none';
    reconnectBtn.style.borderRadius = '5px';
    reconnectBtn.style.cursor = 'pointer';
    reconnectBtn.style.zIndex = '1000';
    reconnectBtn.style.fontSize = '16px';
    
    // Add hover effect
    reconnectBtn.onmouseover = function() {
        this.style.backgroundColor = '#45a049';
    };
    
    reconnectBtn.onmouseout = function() {
        this.style.backgroundColor = '#4CAF50';
    };
    
    // Add click handler
    reconnectBtn.onclick = function() {
        console.log("Reconnect button clicked");
        this.textContent = 'Connecting...';
        this.disabled = true;
        
        // Try to reconnect
        initNetworking()
            .then(() => {
                console.log("Reconnected successfully!");
                this.remove();
            })
            .catch((e) => {
                console.error("Failed to reconnect:", e);
                this.textContent = 'Reconnect to Server';
                this.disabled = false;
                showErrorMessage("Failed to reconnect. Please try again.");
            });
    };
    
    // Add to body
    document.body.appendChild(reconnectBtn);
}

// Function to initialize networking for multiplayer
async function initNetworking() {
    const endpoint = "ws://localhost:3000";
    console.log("Initializing networking system...");
    
    try {
        console.log(`Connecting to Colyseus server at: ${endpoint}`);
        
        // Create client if needed
        if (!client) {
            try {
                client = new Colyseus.Client(endpoint);
                console.log("Colyseus client created");
            } catch (clientError) {
                console.error("Failed to create Colyseus client:", clientError);
                throw new Error(`Failed to create client: ${clientError.message}`);
            }
        }
        
        // Try to join the room
        try {
            console.log("Attempting to join room...");
            room = await client.joinOrCreate("numberblocks", {
                name: `Player_${Math.floor(Math.random() * 1000)}`,
                color: getRandomColor()
            });
            console.log("Joined room successfully:", room.name);
            
            // Store room in global scope
            window.room = room;
            
            // Initialize object collections
            window.otherPlayers = {};
            window.operators = {};
            window.staticNumberblocks = {};
            window.trees = {};
            window.rocks = {};
            
            // Setup message handlers
            setupMessageHandlers();
            
            // Setup automatic reconnection
            setupReconnection(room, client);
            
            // Wait for the initial state before setting up listeners
            room.onStateChange.once((state) => {
                console.log("Initial state received, setting up room listeners");
                
                // Setup room listeners
                window.roomInitialized = false;
                setupRoomListeners(room);
                
                // Check if room initialization succeeded
                const checkRoomInit = () => {
                    if (window.roomInitialized) {
                        // Process existing players
                        processExistingPlayers();
                        
                        // Initial player list update
                        updatePlayerListUI();
                        
                        // Notify that avatar is ready
                        window.dispatchEvent(new CustomEvent('avatarReady'));
                        console.log("Avatar is ready");
                    } else {
                        // Keep checking if not initialized yet
                        setTimeout(checkRoomInit, 100);
                    }
                };
                
                // Start initialization check
                checkRoomInit();
            });
            
            return room;
        } catch (roomError) {
            console.error("Error joining room:", roomError);
            throw roomError;
        }
    } catch (error) {
        console.error("Error connecting to server:", error);
        throw error;
    }
}

// Setup message handlers
function setupMessageHandlers() {
    if (!room) return;
    
    // Listen for custom messages from the server
    room.onMessage("numberblock-collision", (message) => {
        console.log("Collision message received:", message);
        
        // Update player value if needed
        if (window.player && window.player.value !== undefined && message.newValue) {
            window.player.value = message.newValue;
            
            // Update HUD
            if (window.updateHUD) {
                window.updateHUD();
            }
        }
    });
    
    room.onMessage("server-event", (message) => {
        console.log("Server event received:", message);
        // Process server events if needed
    });
}

// Send player position updates to the server
function sendPlayerUpdate(position, rotationY, pitch, value) {
    if (!room) return;
    
    try {
        // Validate inputs before sending
        if (!position || position.x === undefined) {
            console.warn("Invalid position for player update");
            return;
        }
        
        // Send update to the server
        room.send("input", {
            version: 2,
            keys: {}, // Add appropriate key state here if needed
            mouseDelta: { x: 0, y: 0 }, // Add mouse delta if needed
            viewMode: window.isFirstPerson ? "first-person" : "third-person",
            position: {
                x: position.x,
                y: position.y,
                z: position.z
            },
            rotation: {
                y: rotationY || 0,
                pitch: pitch || 0
            },
            value: value || 1
        });
    } catch (error) {
        console.error("Error sending player update:", error);
    }
}

// Send operator collection message
function sendOperatorCollect(operatorId) {
    if (!room) return;
    
    room.send("collect-operator", { id: operatorId });
}

// Send numberblock collision message
function sendNumberblockCollision(targetId) {
    if (!room) return;
    
    room.send("numberblock-collision", { targetId: targetId });
}

// Player joined callback
function onPlayerJoin(player) {
    console.log(`Player joined! ID: ${player.sessionId}`);
    
    // If it's our own join, update the interface
    if (player.sessionId === room.sessionId) {
        console.log("This is us joining!");
        
        // Set initial player values on the server
        player.name = window.playerName || "Player";
        player.color = window.playerColor || "#3366cc";
        
        // Show multiplayer notification
        showInfoMessage("Connected to multiplayer server!");
    } else {
        console.log(`Other player joined: ${player.name || "Unnamed player"}`);
        
        // Create a new numberblock for this player
        createRemotePlayerObject(player);
    }
    
    // Update the player list in the UI
    updatePlayerListUI();
}

// Create 3D object for remote player
function createRemotePlayerObject(player) {
    if (!window.scene) {
        console.error("Scene not available to create remote player object");
        return;
    }
    
    // Create a numberblock mesh for the remote player
    const remotePlayerObject = new Numberblock(player.value || 1);
    remotePlayerObject.id = player.sessionId;
    remotePlayerObject.mesh.position.set(player.x || 0, player.y || 1, player.z || 0);
    
    // Add to scene
    window.scene.add(remotePlayerObject.mesh);
    
    // Store in global collection
    window.remotePlayers = window.remotePlayers || {};
    window.remotePlayers[player.sessionId] = remotePlayerObject;
    
    console.log(`Created remote player object for ${player.sessionId}`);
}

// Player left callback
function onPlayerLeave(player) {
    console.log(`Player left: ${player.sessionId}`);
    
    // Remove player from the scene
    if (window.remotePlayers && window.remotePlayers[player.sessionId]) {
        console.log(`Removing remote player object for ${player.sessionId}`);
        
        // Remove mesh from scene
        if (window.scene && window.remotePlayers[player.sessionId].mesh) {
            window.scene.remove(window.remotePlayers[player.sessionId].mesh);
        }
        
        // Delete player object
        delete window.remotePlayers[player.sessionId];
    }
    
    // Update the player list in the UI
    updatePlayerListUI();
}

// Update player list UI
window.updatePlayerListUI = function() {
    const playerListElement = document.getElementById('player-list');
    if (!playerListElement) return;
    
    // Clear current list
    playerListElement.innerHTML = '';
    
    // Ensure room and state are available
    if (!window.room || !window.room.state) {
        playerListElement.innerHTML = '<li>Not connected to server</li>';
        return;
    }
    
    // Add each player to the list
    window.room.state.players.forEach((player, key) => {
        const playerElement = document.createElement('li');
        
        // Highlight current player
        if (key === window.room.sessionId) {
            playerElement.classList.add('current-player');
        }
        
        // Show player info
        playerElement.innerHTML = `
            <span class="player-name">${player.name || 'Unnamed'}</span>
            <span class="player-value">${player.value || 1}</span>
        `;
        
        // Add to list
        playerListElement.appendChild(playerElement);
    });
};

// Update remote players in the scene
window.updateRemotePlayers = function() {
    if (!window.room || !window.room.state || !window.scene) return;
    
    // Get list of all players from server
    window.room.state.players.forEach((player, sessionId) => {
        // Skip local player
        if (sessionId === window.room.sessionId) return;
        
        // Create remote player object if it doesn't exist
        if (!window.remotePlayers || !window.remotePlayers[sessionId]) {
            createRemotePlayerObject(player);
        }
        
        // Update remote player position and rotation
        const remotePlayer = window.remotePlayers[sessionId];
        if (remotePlayer && remotePlayer.mesh) {
            // Update position with smooth lerping
            const lerpFactor = 0.3; // Smoothing factor for remote player movement
            
            remotePlayer.mesh.position.x = THREE.MathUtils.lerp(
                remotePlayer.mesh.position.x, 
                player.x, 
                lerpFactor
            );
            
            remotePlayer.mesh.position.y = THREE.MathUtils.lerp(
                remotePlayer.mesh.position.y, 
                player.y, 
                lerpFactor
            );
            
            remotePlayer.mesh.position.z = THREE.MathUtils.lerp(
                remotePlayer.mesh.position.z, 
                player.z, 
                lerpFactor
            );
            
            // Update rotation
            remotePlayer.mesh.rotation.y = player.rotationY;
            
            // Update numberblock value if changed
            if (remotePlayer.value !== player.value) {
                // Remove old mesh
                if (remotePlayer.mesh.parent) {
                    remotePlayer.mesh.parent.remove(remotePlayer.mesh);
                }
                
                // Create new numberblock with updated value
                const newNumberblock = new Numberblock(player.value);
                newNumberblock.id = sessionId;
                newNumberblock.mesh.position.copy(remotePlayer.mesh.position);
                newNumberblock.mesh.rotation.y = remotePlayer.mesh.rotation.y;
                
                // Add to scene
                window.scene.add(newNumberblock.mesh);
                
                // Update reference
                window.remotePlayers[sessionId] = newNumberblock;
            }
        }
    });
};

// Make functions available globally
window.initNetworking = initNetworking;
window.setupMessageHandlers = setupMessageHandlers;
window.sendPlayerUpdate = sendPlayerUpdate;
window.sendOperatorCollect = sendOperatorCollect;
window.sendNumberblockCollision = sendNumberblockCollision;
window.getRandomColor = getRandomColor;
window.getColorForValue = getColorForValue;
window.CSS2DObject = CSS2DObject;
window.CSS2DRenderer = CSS2DRenderer;
window.onPlayerJoin = onPlayerJoin;
window.onPlayerLeave = onPlayerLeave;
 
 
===================================================== 
FILE: client\js\NPC.js 
===================================================== 
 
// Numberblocks game - NPC entity class

class NPC extends Entity {
    constructor(params) {
        super(params);
        
        // NPC-specific properties
        this.isStatic = params.isStatic || false;
        this.operatorType = params.operatorType || null;
        this.behaviorType = params.behaviorType || 'static';
        this.target = params.target || null;
        
        // Animation properties
        this.animationState = {
            floating: {
                enabled: !this.isStatic,
                height: 0.5,
                speed: 1.0,
                time: Math.random() * Math.PI * 2 // Random start phase
            },
            rotating: {
                enabled: params.type === 'operator',
                speed: 0.5
            }
        };
        
        // Set initial animation state
        this.setupAnimation();
    }
    
    setupAnimation() {
        // Only set up animation for non-static NPCs or operators
        if (this.isStatic) {
            this.animationState.floating.enabled = false;
            this.animationState.rotating.enabled = false;
        }
        
        // Operators should rotate to face player
        if (this.type === 'operator') {
            this.animationState.rotating.enabled = true;
        }
    }
    
    // Animate the NPC
    animate(deltaTime) {
        if (!this.mesh) return;
        
        // Handle floating animation
        if (this.animationState.floating.enabled) {
            this.animationState.floating.time += deltaTime * this.animationState.floating.speed;
            const floatHeight = Math.sin(this.animationState.floating.time) * this.animationState.floating.height;
            
            // Apply floating motion
            this.mesh.position.y = this.y + floatHeight;
        }
        
        // Handle rotation animation (e.g., operators facing player)
        if (this.animationState.rotating.enabled && window.playerNumberblock) {
            // Rotate to face the player
            const playerPos = window.playerNumberblock.mesh.position;
            const direction = new THREE.Vector3();
            direction.subVectors(playerPos, this.mesh.position);
            
            // Calculate the angle but only on the Y axis (horizontal rotation)
            const targetRotation = Math.atan2(direction.x, direction.z);
            
            // Smooth rotation
            const rotationSpeed = this.animationState.rotating.speed;
            const angleDiff = (targetRotation - this.mesh.rotation.y + Math.PI) % (Math.PI * 2) - Math.PI;
            this.mesh.rotation.y += angleDiff * rotationSpeed * deltaTime;
        }
    }
    
    // Update position and also handle any animations
    updatePosition(position) {
        super.updatePosition(position);
        
        // Re-enable animations if needed
        this.setupAnimation();
    }
    
    createMesh() {
        // Create visual representation based on the type
        switch (this.type) {
            case 'numberblock':
                // For static numberblocks, we use the same Numberblock class
                const numberblock = new window.Numberblock(this.value, this.color, this.name);
                
                // Store the numberblock reference for later updates
                numberblock.mesh.userData.numberblockRef = numberblock;
                
                return numberblock.mesh;
                
            case 'operator':
                // For operators, use the Operator class if available
                if (window.OperatorsVisual) {
                    const operator = new window.OperatorsVisual({
                        type: this.value, // 'plus' or 'minus', stored in value
                        x: this.x,
                        y: this.y,
                        z: this.z
                    });
                    return operator.mesh;
                }
                break;
                
            default:
                // Default fallback
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshStandardMaterial({ color: this.color || 0xFFFFFF });
                return new THREE.Mesh(geometry, material);
        }
    }

    updateValue(newValue) {
        super.updateValue(newValue);
        
        // For numberblocks, we need to recreate the visual
        if (this.type === 'numberblock' && this.mesh) {
            const parentScene = this.mesh.parent;
            const position = this.mesh.position.clone();
            const rotation = this.mesh.rotation.y;
            
            // Remove old mesh
            if (parentScene) {
                parentScene.remove(this.mesh);
            }
            
            // Create new numberblock with updated value
            const numberblock = new window.Numberblock(newValue, this.color, this.name);
            this.mesh = numberblock.mesh;
            
            // Restore position and rotation
            this.mesh.position.copy(position);
            this.mesh.rotation.y = rotation;
            
            // Add back to scene
            if (parentScene) {
                parentScene.add(this.mesh);
            }
            
            // Store reference to this entity
            this.mesh.userData.entity = this;
            this.mesh.userData.numberblockRef = numberblock;
        }
    }

    updateColor(newColor) {
        super.updateColor(newColor);
        
        // Update the color based on entity type
        if (this.type === 'numberblock' && this.mesh) {
            // Delegate to Numberblock's updateColor if we can
            const numberblockRef = this.mesh.userData.numberblockRef;
            if (numberblockRef && typeof numberblockRef.updateColor === 'function') {
                numberblockRef.updateColor(newColor);
            } else {
                // Otherwise traverse all children and update materials
                this.mesh.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.color.set(newColor);
                    }
                });
            }
        }
    }
    
    // NPCs can have behavior in their update method
    update(deltaTime) {
        super.update(deltaTime);
        
        // Implement different behaviors
        switch (this.behaviorType) {
            case 'idle':
                // Do nothing
                break;
                
            case 'wander':
                // Random movement could be implemented here
                break;
                
            case 'follow':
                // Follow logic could be implemented here
                break;
        }
        
        // Animate the NPC
        this.animate(deltaTime);
    }
}

// Export to window object for access in other scripts
if (typeof window !== 'undefined') {
    window.NPC = NPC;
}

if (typeof module !== 'undefined') {
    module.exports = { NPC };
}
 
 
===================================================== 
FILE: client\js\numberblock.js 
===================================================== 
 
// Numberblocks game - Numberblock model implementation

class Numberblock {
    constructor(value = 1, color = null) {
        this.value = value;
        this.mesh = new THREE.Group();
        this.mesh.userData.numberblock = this; // Store reference for easy access
        this.blockSize = 1; // Size of each cube
        this.blockSpacing = 0.01; // Small gap between blocks
        this.totalHeight = 0;
        
        // Set color based on the Numberblock value, following show colors if no color specified
        if (!color) {
            this.color = this.getColorForNumber(value);
        } else {
            this.color = color;
        }
        
        this.createNumberblock();
    }
    
    // Get the standard Numberblocks color based on value
    getColorForNumber(number) {
        const colors = {
            1: 0xFF0000,   // Red (One)
            2: 0xFFA500,   // Orange (Two)
            3: 0xFFFF00,   // Yellow (Three)
            4: 0x00FF00,   // Green (Four)
            5: 0x0000FF,   // Blue (Five)
            6: 0x800080,   // Purple (Six)
            7: 0xFFC0CB,   // Pink (Seven)
            8: 0xA52A2A,   // Brown (Eight)
            9: 0x808080    // Grey (Nine)
        };
        
        // For numbers greater than 9, cycle through the colors or use white
        return colors[number % 9] || 0xFFFFFF;
    }
    
    // Create the complete Numberblock with all features
    createNumberblock() {
        this.mesh.clear(); // Clear any existing meshes
        this.totalHeight = 0;
        
        // Create the stack of blocks
        for (let i = 0; i < this.value; i++) {
            const block = this.createBlock();
            
            // Position each block on top of the previous one
            block.position.y = this.totalHeight;
            this.totalHeight += this.blockSize + this.blockSpacing;
            
            this.mesh.add(block);
            
            // Add face only to the top block
            if (i === this.value - 1) {
                const face = this.createFace();
                block.add(face);
            }
            
            // Add feet to the bottom block
            if (i === 0) {
                const leftFoot = this.createFoot('left');
                const rightFoot = this.createFoot('right');
                block.add(leftFoot);
                block.add(rightFoot);
            }
        }
        
        // Add arms to the middle block or the second block from the bottom if more than 3 blocks
        const armBlockIndex = this.value <= 3 ? Math.floor(this.value / 2) : 1;
        if (this.value > 0 && armBlockIndex < this.value) {
            const leftArm = this.createArm('left');
            const rightArm = this.createArm('right');
            
            this.mesh.children[armBlockIndex].add(leftArm);
            this.mesh.children[armBlockIndex].add(rightArm);
        }
        
        // Set initial position to 0 - we'll handle positioning in the game logic
        this.mesh.position.y = 0;
    }
    
    // Get the height of the Numberblock (for physics calculations)
    getHeight() {
        // Return the total height calculated during creation
        // If value is 0, return a minimum height
        return this.value > 0 ? this.totalHeight - this.blockSpacing : this.blockSize;
    }
    
    // Update the color of the Numberblock
    updateColor(newColor) {
        this.color = newColor;
        
        // Update the color of all blocks in the Numberblock
        this.mesh.children.forEach(child => {
            // Only update the blocks, not other attachments like arms or face
            if (child.geometry && child.geometry.type === 'BoxGeometry') {
                child.material.color.set(newColor);
            }
        });
    }
    
    // Create a single block with the Numberblock's color
    createBlock() {
        const geometry = new THREE.BoxGeometry(this.blockSize, this.blockSize, this.blockSize);
        const material = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        return new THREE.Mesh(geometry, material);
    }
    
    // Create a face with eyes and mouth
    createFace() {
        const face = new THREE.Group();
        
        // Eyes (white spheres with black pupils)
        const eyeSize = this.blockSize * 0.15;
        const eyeSpacing = this.blockSize * 0.3;
        const eyeHeight = this.blockSize * 0.1;
        const eyeDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        
        // Create and position left eye
        const leftEye = this.createEye(eyeSize);
        leftEye.position.set(-eyeSpacing, eyeHeight, eyeDepth);
        face.add(leftEye);
        
        // Create and position right eye
        const rightEye = this.createEye(eyeSize);
        rightEye.position.set(eyeSpacing, eyeHeight, eyeDepth);
        face.add(rightEye);
        
        // Mouth (curved line or small cylinder)
        const mouthWidth = this.blockSize * 0.4;
        const mouthHeight = this.blockSize * 0.1;
        const mouthDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        const mouthY = -eyeHeight * 2; // Position below the eyes
        
        const mouthGeometry = new THREE.CylinderGeometry(
            mouthHeight/2, mouthHeight/2, mouthWidth, 16, 1, false, 0, Math.PI
        );
        mouthGeometry.rotateZ(Math.PI / 2); // Rotate to correct orientation
        
        const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, mouthY, mouthDepth);
        face.add(mouth);
        
        return face;
    }
    
    // Create an eye (white sphere with black pupil)
    createEye(size) {
        const eye = new THREE.Group();
        
        // White part of the eye
        const eyeWhiteGeometry = new THREE.SphereGeometry(size, 16, 16);
        const eyeWhiteMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const eyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
        eye.add(eyeWhite);
        
        // Black pupil
        const pupilSize = size * 0.5;
        const pupilGeometry = new THREE.SphereGeometry(pupilSize, 16, 16);
        const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        pupil.position.z = size * 0.6; // Position the pupil slightly in front of the eye
        eye.add(pupil);
        
        return eye;
    }
    
    // Create an arm (left or right)
    createArm(side) {
        const arm = new THREE.Group();
        
        // Arm dimensions
        const armLength = this.blockSize * 0.6;
        const armWidth = this.blockSize * 0.2;
        const armHeight = this.blockSize * 0.2;
        
        // Create the arm geometry
        const armGeometry = new THREE.BoxGeometry(armLength, armHeight, armWidth);
        const armMaterial = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        const armMesh = new THREE.Mesh(armGeometry, armMaterial);
        
        // Position the arm on the side of the block
        const xOffset = (this.blockSize / 2 + armLength / 2) * (side === 'left' ? -1 : 1);
        armMesh.position.set(xOffset, 0, 0);
        
        arm.add(armMesh);
        
        // Add a hand at the end of the arm
        const handRadius = armWidth * 0.8;
        const handGeometry = new THREE.SphereGeometry(handRadius, 16, 16);
        const handMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF, // White hands
            roughness: 0.7,
            metalness: 0.2
        });
        
        const hand = new THREE.Mesh(handGeometry, handMaterial);
        
        // Position the hand at the end of the arm
        const handX = armLength / 2 * (side === 'left' ? -1 : 1);
        hand.position.set(handX, 0, 0);
        
        // Name the hand for easy reference
        hand.name = side + 'Hand';
        
        armMesh.add(hand);
        
        return arm;
    }
    
    // Create a foot (left or right)
    createFoot(side) {
        const foot = new THREE.Group();
        
        // Foot dimensions
        const footLength = this.blockSize * 0.4;
        const footWidth = this.blockSize * 0.3;
        const footHeight = this.blockSize * 0.15;
        
        // Create the foot geometry
        const footGeometry = new THREE.BoxGeometry(footLength, footHeight, footWidth);
        const footMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000, // Black feet
            roughness: 0.7,
            metalness: 0.2
        });
        
        const footMesh = new THREE.Mesh(footGeometry, footMaterial);
        
        // Position the foot on the bottom of the block
        const xOffset = (this.blockSize / 4) * (side === 'left' ? -1 : 1);
        const yOffset = -this.blockSize / 2 - footHeight / 2;
        const zOffset = this.blockSize / 4; // Push feet slightly forward
        footMesh.position.set(xOffset, yOffset, zOffset);
        
        foot.add(footMesh);
        
        return foot;
    }
    
    // Update the Numberblock value and regenerate the model
    setValue(newValue) {
        if (newValue < 1) newValue = 1; // Ensure minimum value of 1
        if (newValue !== this.value) {
            this.value = newValue;
            this.color = this.getColorForNumber(newValue);
            this.createNumberblock();
        }
    }
    
    // Update value (used for network synchronization)
    updateValue(newValue) {
        return this.setValue(newValue);
    }
    
    // Update the position of the HTML number tag in render loop
    updateNumberTagPosition(camera, renderer) {
        // Previous functionality disabled - no longer using HTML elements for tags
        // Now fully using the HUD we created in index.html and main-fixed.js
    }
    
    // Dispose any allocated resources
    dispose() {
        // We no longer need to remove HTML elements since we aren't creating them
    }
}

// Function to create a player Numberblock and add it to the scene
function createPlayerNumberblock(scene, value = 1) {
    // Create the Numberblock
    const playerBlock = new Numberblock(value);
    
    // Position it slightly above the ground
    const totalHeight = playerBlock.totalHeight;
    playerBlock.mesh.position.y = totalHeight / 2;
    
    // Add to scene
    scene.add(playerBlock.mesh);
    
    return playerBlock;
}

// Export for use in other modules
if (typeof module !== 'undefined') {
    module.exports = {
        Numberblock,
        createPlayerNumberblock
    };
}

// Always make Numberblock available globally
window.Numberblock = Numberblock;
console.log('Numberblock class exported to window object'); 
 
===================================================== 
FILE: client\js\operator.js 
===================================================== 
 
// Numberblocks game - Operator implementation

// Class to represent mathematical operators (+ and -)
class Operator {
    constructor(type, scene) {
        this.type = type; // 'plus' or 'minus'
        this.scene = scene;
        this.mesh = this.createOperatorMesh();
        
        // Add the operator to the scene
        scene.add(this.mesh);
        
        // Set the radius for collision detection
        this.collisionRadius = 0.5;
    }
    
    // Create the 3D mesh for the operator
    createOperatorMesh() {
        const operatorGroup = new THREE.Group();
        operatorGroup.userData.operator = this; // Store reference for easy access
        
        // Create a semi-transparent white sphere as the base
        const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const sphereMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF, // White sphere
            roughness: 0.3,
            metalness: 0.2,
            transparent: true, // Make it transparent
            opacity: 0.6 // 60% opacity
        });
        
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        operatorGroup.add(sphere);
        
        // Create the symbol geometry (+ or -) and place it in the center
        const symbolColor = 0x000000; // Black symbol
        const symbolMaterial = new THREE.MeshBasicMaterial({ color: symbolColor });
        
        if (this.type === 'plus') {
            // Create a plus sign (+) using two cylinders
            // Horizontal bar
            const horizontalGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            horizontalGeometry.rotateZ(Math.PI / 2); // Rotate to make it horizontal
            const horizontalBar = new THREE.Mesh(horizontalGeometry, symbolMaterial);
            
            // Vertical bar
            const verticalGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            const verticalBar = new THREE.Mesh(verticalGeometry, symbolMaterial);
            
            operatorGroup.add(horizontalBar);
            operatorGroup.add(verticalBar);
        } else {
            // Create a minus sign (-) using a single cylinder
            const minusGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            minusGeometry.rotateZ(Math.PI / 2); // Rotate to make it horizontal
            const minusBar = new THREE.Mesh(minusGeometry, symbolMaterial);
            
            operatorGroup.add(minusBar);
        }
        
        // Add a soft glow effect
        const glowGeometry = new THREE.SphereGeometry(0.6, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF, // White glow
            transparent: true,
            opacity: 0.2
        });
        
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        operatorGroup.add(glow);
        
        // Add rotation animation that ensures the symbol stays visible
        this.animate = (deltaTime) => {
            // Instead of rotating around Y-axis, make the operator face the camera
            if (window.camera) {
                // Get direction to camera
                const direction = new THREE.Vector3();
                direction.subVectors(window.camera.position, operatorGroup.position).normalize();
                
                // Create a temporary up vector (world up)
                const up = new THREE.Vector3(0, 1, 0);
                
                // Create a look-at matrix
                const lookMatrix = new THREE.Matrix4();
                lookMatrix.lookAt(operatorGroup.position, 
                                  operatorGroup.position.clone().add(direction), 
                                  up);
                
                // Convert to quaternion and apply
                operatorGroup.quaternion.setFromRotationMatrix(lookMatrix);
            } else {
                // Default rotation if no camera
                operatorGroup.rotation.y += deltaTime * 1.5;
            }
            
            // Add a subtle floating animation
            operatorGroup.position.y = Math.sin(Date.now() * 0.002) * 0.1 + 0.6; // Float between 0.5 and 0.7
        };
        
        return operatorGroup;
    }
    
    // Position the operator in the scene
    setPosition(x, y, z) {
        this.mesh.position.set(x, y, z);
    }
    
    // Remove the operator from the scene
    remove() {
        this.scene.remove(this.mesh);
        
        // Clean up geometries and materials to prevent memory leaks
        this.mesh.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(material => material.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
    }
    
    // Create a smaller version of the operator for holding
    createHeldOperatorMesh() {
        // Create a smaller version of the operator for holding
        const scale = 0.4; // Smaller scale for held operator
        const heldMesh = this.createOperatorMesh();
        heldMesh.scale.set(scale, scale, scale);
        
        return heldMesh;
    }
}

// Class to manage all operators in the game
class OperatorManager {
    constructor(scene) {
        this.scene = scene;
        this.operators = [];
        this.groundY = 0; // Y position of the ground
        
        // Player's held operator
        this.heldOperator = null;
        this.heldOperatorMesh = null;
        
        // Debug message to check initialization
        console.log("OperatorManager initialized");
    }
    
    // Update function to be called in animation loop
    update(deltaTime) {
        // Update existing operators
        this.operators.forEach(operator => {
            operator.animate(deltaTime);
        });
        
        // NOTE: We no longer spawn operators locally
        // Operators are created by the server and synchronized via Colyseus
    }
    
    // Create an operator from server data
    // This is called by the entity-sync system when a new operator is received from the server
    createOperatorFromServer(id, type, x, y, z) {
        // Create the operator
        const operator = new Operator(type, this.scene);
        
        // Set the position from server data
        operator.setPosition(x, y, z);
        
        // Store server ID for reference
        operator.serverId = id;
        
        // Add to the array of active operators
        this.operators.push(operator);
        
        console.log(`Created ${type} operator from server at (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})`);
        
        return operator;
    }
    
    // Find an operator by server ID
    getOperatorByServerId(id) {
        return this.operators.find(op => op.serverId === id);
    }
    
    // Update an operator's position based on server data
    updateOperatorFromServer(id, x, y, z) {
        const operator = this.getOperatorByServerId(id);
        if (operator) {
            operator.setPosition(x, y, z);
        }
    }
    
    // Remove an operator from the scene and the operators array
    removeOperator(operator) {
        const index = this.operators.indexOf(operator);
        if (index !== -1) {
            operator.remove();
            this.operators.splice(index, 1);
        }
    }
    
    // Remove an operator by server ID
    removeOperatorByServerId(id) {
        const operator = this.getOperatorByServerId(id);
        if (operator) {
            this.removeOperator(operator);
        }
    }
    
    // Set the currently held operator
    setHeldOperator(operator, numberblock) {
        // Clear any previously held operator
        this.clearHeldOperator();
        
        // Store the operator type
        this.heldOperator = operator.type;
        console.log("Setting held operator type:", this.heldOperator); // Debug log
        
        // Create a smaller version of the operator for holding
        this.heldOperatorMesh = operator.createHeldOperatorMesh();
        
        // Attach the operator to the Numberblock's right hand
        if (numberblock && numberblock.mesh) {
            // Find the right hand in the Numberblock's mesh hierarchy
            let rightHand = null;
            
            // Look for the arm block (should be the second block for Numberblocks with more than 3 blocks)
            const armBlockIndex = numberblock.value <= 3 ? Math.floor(numberblock.value / 2) : 1;
            
            // Find the right hand if there are enough blocks
            if (numberblock.value > 0 && armBlockIndex < numberblock.value) {
                // Get the arm block
                const armBlock = numberblock.mesh.children[armBlockIndex];
                
                // Search for the rightHand in the arm block's children
                armBlock.traverse((child) => {
                    if (child.name === 'rightHand') {
                        rightHand = child;
                    }
                });
                
                // If we found the right hand, attach the operator to it
                if (rightHand) {
                    // Position the held operator slightly offset from the hand
                    this.heldOperatorMesh.position.set(0, 0.2, 0);
                    
                    // Add the held operator mesh to the right hand
                    rightHand.add(this.heldOperatorMesh);
                    
                    console.log(`Attached ${this.heldOperator} operator to Numberblock's right hand`);
                } else {
                    // Fallback: Add to the scene if we can't find the hand
                    console.warn("Could not find rightHand - adding operator to scene");
                    this.scene.add(this.heldOperatorMesh);
                }
            } else {
                // Fallback: Add to the scene if Numberblock doesn't have arms
                console.warn("Numberblock doesn't have enough blocks for arms - adding operator to scene");
                this.scene.add(this.heldOperatorMesh);
            }
        } else {
            // Add to the scene if no Numberblock is provided
            this.scene.add(this.heldOperatorMesh);
        }
        
        // Remove the original operator from the scene
        this.removeOperator(operator);
        
        console.log(`Now holding ${this.heldOperator} operator`); // Debug log
        return this.heldOperator;
    }
    
    // Clear the currently held operator
    clearHeldOperator() {
        if (this.heldOperatorMesh) {
            // Remove from parent (either scene or hand)
            if (this.heldOperatorMesh.parent) {
                this.heldOperatorMesh.parent.remove(this.heldOperatorMesh);
            } else {
                this.scene.remove(this.heldOperatorMesh);
            }
            
            this.heldOperatorMesh = null;
        }
        this.heldOperator = null;
        console.log("Cleared held operator"); // Debug log
    }
    
    // Get the currently held operator type
    getHeldOperator() {
        console.log("Getting held operator type:", this.heldOperator); // Debug log
        return this.heldOperator;
    }
    
    // Attach the held operator to a Numberblock
    attachOperatorToNumberblock(numberblock) {
        if (this.heldOperatorMesh && numberblock) {
            // The numberblock will handle the positioning
            return {
                type: this.heldOperator,
                mesh: this.heldOperatorMesh
            };
        }
        return null;
    }
    
    // Clear all operators
    clearAll() {
        while (this.operators.length > 0) {
            this.removeOperator(this.operators[0]);
        }
        this.clearHeldOperator();
    }
    
    // Get all operators for collision checking
    getOperators() {
        return this.operators;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined') {
    module.exports = {
        Operator,
        OperatorManager
    };
}
 
 
===================================================== 
FILE: client\js\player-sync.js 
===================================================== 
 
// Numberblocks game - Player synchronization module
// Handles player synchronization between clients

// Helper functions for visual management
function setupPlayerListeners(player, sessionId) {
    try {
        // Skip if it's our own player
        if (sessionId === window.room.sessionId) {
            console.log("✅ This is my player, not creating visual");
            return;
        }

        // Create visual for remote player
        const visual = new PlayersVisual(player);
        if (!visuals.players) visuals.players = {};
        visuals.players[sessionId] = visual;
        
        // Store in tracking collection
        window.otherPlayers[sessionId] = player;

        // Add to scene
        if (window.scene) {
            window.scene.add(visual.group || visual.mesh);
        }

        // Setup change listener for updates
        player.onChange(() => {
            if (visuals.players[sessionId]) {
                visuals.players[sessionId].update(player);
            }
        });

        // Update UI
        updatePlayerListUI();
    } catch (error) {
        console.error(`Error setting up player (${sessionId}):`, error);
    }
}

function removePlayerVisual(sessionId) {
    try {
        // Remove visual
        if (visuals.players && visuals.players[sessionId]) {
            if (window.scene) {
                window.scene.remove(visuals.players[sessionId].group || 
                                  visuals.players[sessionId].mesh);
            }
            delete visuals.players[sessionId];
        }

        // Remove from tracking
        delete window.otherPlayers[sessionId];

        // Update UI
        updatePlayerListUI();
    } catch (error) {
        console.error(`Error removing player visual (${sessionId}):`, error);
    }
}

// Update player list UI
function updatePlayerListUI() {
    try {
        const playerList = document.getElementById('playerList');
        if (!playerList) return;

        // Clear existing list
        playerList.innerHTML = '';

        // Add all players
        if (window.room && window.room.state) {
            window.room.state.players.forEach((player, sessionId) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-item';
                playerDiv.textContent = `${player.name || sessionId} (Value: ${player.value || 1})`;
                if (sessionId === window.room.sessionId) {
                    playerDiv.classList.add('current-player');
                }
                playerList.appendChild(playerDiv);
            });
        }
    } catch (error) {
        console.error("Error updating player list UI:", error);
    }
}

// Define visual class for Players
window.PlayersVisual = class PlayersVisual {
    constructor(playerData) {
        this.group = new THREE.Group();
        this.numberblockMesh = null;
        this.nameLabel = null;
        this.update(playerData);
    }

    createNumberblockMesh(value, color) {
        // Create numberblock mesh based on value
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshPhongMaterial({ color: color || 0xff0000 });
        const mesh = new THREE.Mesh(geometry, material);
        
        // Scale based on value (stack of cubes)
        mesh.scale.y = value || 1;
        mesh.position.y = (value || 1) / 2;
        
        return mesh;
    }

    update(playerData) {
        try {
            // Update numberblock
            if (this.numberblockMesh) {
                this.group.remove(this.numberblockMesh);
            }
            this.numberblockMesh = this.createNumberblockMesh(playerData.value, playerData.color);
            this.group.add(this.numberblockMesh);

            // Update position and rotation
            if (playerData.x !== undefined && playerData.y !== undefined && playerData.z !== undefined) {
                this.group.position.set(playerData.x, playerData.y, playerData.z);
            }
            if (playerData.rotationY !== undefined) {
                this.group.rotation.y = playerData.rotationY;
            }

            // Update name label
            if (!this.nameLabel && playerData.name) {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'player-label';
                labelDiv.textContent = playerData.name;
                this.nameLabel = new CSS2DObject(labelDiv);
                this.nameLabel.position.set(0, (playerData.value || 1) + 0.5, 0);
                this.group.add(this.nameLabel);
            } else if (this.nameLabel && playerData.name) {
                this.nameLabel.element.textContent = playerData.name;
                this.nameLabel.position.y = (playerData.value || 1) + 0.5;
            }
        } catch (error) {
            console.error("Error updating player visual:", error);
        }
    }
};

// Process players that already exist in the room when joining
function processExistingPlayers() {
    if (!window.room) {
        console.warn("Room not available for processing existing players");
        return;
    }
    
    try {
        // Get all player objects from the room state
        const players = window.room.state.players;
        if (!players) {
            console.warn("No players collection in room state");
            return;
        }
        
        // Track our own player ID
        window.mySessionId = window.room.sessionId;
        
        // Process each player in the room
        players.forEach((player, sessionId) => {
            setupPlayerListeners(player, sessionId);
        });
        
        console.log("Processed existing players. Total:", players.size);
    } catch (error) {
        console.error("Error processing existing players:", error);
    }
}

// Setup specific schema listeners for Players
function setupPlayerListeners(room) {
    if (!room || !room.state || !room.state.players) {
        console.warn('Players state not available.');
        return;
    }

    // Listen for player added
    room.state.players.onAdd((player, sessionId) => {
        console.log(`✅ Player ${sessionId} joined.`, player);
        setupPlayerListeners(player, sessionId);
    });

    // Listen for player removal
    room.state.players.onRemove((player, sessionId) => {
        console.log(`✅ Player ${sessionId} left.`, player);
        removePlayerVisual(sessionId);
    });

    // Initial iteration (process existing players)
    room.state.players.forEach((player, sessionId) => {
        console.log(`✅ Processing existing player: ${sessionId}`, player);
        setupPlayerListeners(player, sessionId);
    });
    
    // Update UI after processing all players
    updatePlayerListUI();
}

// Make functions available globally
window.setupPlayerListeners = setupPlayerListeners;
window.removePlayerVisual = removePlayerVisual;
window.updatePlayerListUI = updatePlayerListUI;
window.processExistingPlayers = processExistingPlayers;
 
 
===================================================== 
FILE: client\js\player-ui.js 
===================================================== 
 
// Numberblocks game - Player UI module
// Handles player list UI and related functionality

// Update player list in UI
function updatePlayerListUI() {
    // Get player list container
    const playerList = document.getElementById('player-list');
    if (!playerList) {
        console.warn("Player list element not found");
        return;
    }
    
    try {
        // Clear current list
        playerList.innerHTML = '';
        
        // Add myself first
        if (room && room.state && room.state.players) {
            const myPlayer = room.state.players.get(room.sessionId);
            if (myPlayer) {
                addPlayerToList(myPlayer, room.sessionId, true);
            }
        }
        
        // Add other players
        let playerCount = 1; // Start with 1 for myself
        
        // Check if other players object exists
        if (window.otherPlayers) {
            // Count active players
            const activePlayers = Object.keys(window.otherPlayers).filter(sessionId => {
                const player = window.otherPlayers[sessionId];
                return player && (!player.active || player.active);
            });
            
            playerCount += activePlayers.length;
            
            // Loop through other players and add to list
            for (const sessionId in window.otherPlayers) {
                const player = window.otherPlayers[sessionId];
                
                // Skip inactive players
                if (player.active === false) continue;
                
                // Add to UI
                addPlayerToList(player, sessionId, false);
            }
        }
        
        // Update player count in UI
        const playerCountElement = document.getElementById('player-count');
        if (playerCountElement) {
            playerCountElement.textContent = `(${playerCount})`;
        }
        
        // Set list max height based on number of players
        playerList.style.maxHeight = `${Math.min(playerCount * 25, 150)}px`;
    } catch (error) {
        console.error("Error updating player list UI:", error);
    }
}

// Helper function to add a player to the list UI
function addPlayerToList(player, sessionId, isCurrentPlayer) {
    if (!player) return;
    
    try {
        // Get player list element
        const playerList = document.getElementById('player-list');
        if (!playerList) return;
        
        // Create player entry
        const playerEntry = document.createElement('div');
        playerEntry.className = 'player-entry';
        playerEntry.id = `player-${sessionId}`;
        
        // Add highlighting for current player
        if (isCurrentPlayer) {
            playerEntry.style.fontWeight = 'bold';
            playerEntry.style.backgroundColor = 'rgba(255,255,255,0.2)';
        }
        
        // Create color indicator
        const colorIndicator = document.createElement('div');
        colorIndicator.className = 'player-color';
        colorIndicator.style.backgroundColor = player.color || '#FFFFFF';
        
        // Create player info
        const playerInfo = document.createElement('div');
        playerInfo.className = 'player-info';
        
        // Format player name with value
        const playerName = player.name || `Player ${sessionId.substring(0, 4)}`;
        const playerValue = player.value || 1;
        playerInfo.textContent = `${playerName} (${playerValue})`;
        
        // Build entry
        playerEntry.appendChild(colorIndicator);
        playerEntry.appendChild(playerInfo);
        playerList.appendChild(playerEntry);
    } catch (error) {
        console.error("Error adding player to UI list:", error);
    }
}

// Set up key event listeners for player list toggle
function setupPlayerListKeyControls() {
    // Toggle player list on 'Tab' key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Tab') {
            event.preventDefault(); // Prevent default tab behavior
            togglePlayerList();
        }
    });
    
    // Set up click listener for header
    const playerListHeader = document.getElementById('player-list-header');
    if (playerListHeader) {
        playerListHeader.addEventListener('click', togglePlayerList);
    }
}

// Function to toggle player list visibility
function togglePlayerList() {
    const playerList = document.getElementById('player-list');
    const collapseIcon = document.getElementById('collapse-icon');
    
    if (!playerList || !collapseIcon) return;
    
    // Check current state
    const isCollapsed = playerList.style.display === 'none';
    
    // Toggle display
    playerList.style.display = isCollapsed ? 'block' : 'none';
    
    // Update icon
    collapseIcon.textContent = isCollapsed ? '▼' : '▶';
    
    // Save state in localStorage
    localStorage.setItem('playerListCollapsed', !isCollapsed);
}

// Initialize player list state from saved preference
function initPlayerListState() {
    try {
        // Get saved state
        const isCollapsed = localStorage.getItem('playerListCollapsed') === 'true';
        
        // Get elements
        const playerList = document.getElementById('player-list');
        const collapseIcon = document.getElementById('collapse-icon');
        
        if (playerList && collapseIcon) {
            // Set initial state
            playerList.style.display = isCollapsed ? 'none' : 'block';
            collapseIcon.textContent = isCollapsed ? '▶' : '▼';
        }
    } catch (error) {
        console.warn("Error initializing player list state:", error);
    }
}

// Make functions available globally
window.updatePlayerListUI = updatePlayerListUI;
window.addPlayerToList = addPlayerToList;
window.setupPlayerListKeyControls = setupPlayerListKeyControls;
window.togglePlayerList = togglePlayerList;
window.initPlayerListState = initPlayerListState;

// Initialize player list when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    initPlayerListState();
    setupPlayerListKeyControls();
});
 
 
===================================================== 
FILE: client\js\Player.js 
===================================================== 
 
// Numberblocks game - Player entity class

class Player extends Entity {
    constructor(params) {
        super(params);
        this.isPlayer = true;
        this.isLocalPlayer = params.isLocalPlayer || false;
        
        // Player-specific properties
        this.moveSpeed = 5.0;
        this.jumpHeight = 5.0;
        this.isJumping = false;
        this.isColliding = false;
        this.controls = null;
        
        // Override the mesh if this is the local player
        if (this.isLocalPlayer && window.playerNumberblock) {
            this.mesh = window.playerNumberblock.mesh;
            this.mesh.userData.entity = this;
        }
    }
    
    // For local player, position is controlled by PointerLockControls
    // For remote players, position is updated via network
    updatePosition(position) {
        // Only update remote players via network updates
        if (!this.isLocalPlayer) {
            super.updatePosition(position);
        }
    }
    
    // Create playerCamera
    createPlayerCamera() {
        if (this.isLocalPlayer) {
            // Implementation of first-person camera setup
        }
    }
    
    // Handle player input and movement
    handleInput(inputState) {
        if (this.isLocalPlayer) {
            // Handle player input (WASD, etc)
        }
    }
    
    createMesh() {
        // Create visual representation based on the type
        switch (this.type) {
            case 'numberblock':
            default:
                // Default to numberblock for now
                const numberblock = new window.Numberblock(this.value, this.color, this.name);
                return numberblock.mesh;
        }
    }

    updateValue(newValue) {
        super.updateValue(newValue);
        
        // For numberblocks, we need to recreate the visual
        if (this.type === 'numberblock' && this.mesh) {
            const parentScene = this.mesh.parent;
            const position = this.mesh.position.clone();
            const rotation = this.mesh.rotation.y;
            
            // Remove old mesh
            if (parentScene) {
                parentScene.remove(this.mesh);
            }
            
            // Create new numberblock with updated value
            const numberblock = new window.Numberblock(newValue, this.color, this.name);
            this.mesh = numberblock.mesh;
            
            // Restore position and rotation
            this.mesh.position.copy(position);
            this.mesh.rotation.y = rotation;
            
            // Add back to scene
            if (parentScene) {
                parentScene.add(this.mesh);
            }
            
            // Store reference to this entity
            this.mesh.userData.entity = this;
        }
    }

    updateColor(newColor) {
        super.updateColor(newColor);
        
        // Update the color of all blocks in the numberblock
        if (this.type === 'numberblock' && this.mesh) {
            // Delegate to Numberblock's updateColor if we can
            const numberblockRef = this.mesh.userData.numberblockRef;
            if (numberblockRef && typeof numberblockRef.updateColor === 'function') {
                numberblockRef.updateColor(newColor);
            } else {
                // Otherwise traverse all children and update materials
                this.mesh.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.color.set(newColor);
                    }
                });
            }
        }
    }
}

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.Player = Player;
}

if (typeof module !== 'undefined') {
    module.exports = { Player };
}
 
 
===================================================== 
FILE: public\minimal.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal Three.js Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        #debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            max-width: 500px;
            overflow: auto;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="debug-panel"></div>
    
    <!-- Three.js library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    
    <script>
        // Debug function
        function debug(message) {
            const debugPanel = document.getElementById('debug-panel');
            const messageElement = document.createElement('div');
            messageElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            debugPanel.appendChild(messageElement);
            debugPanel.scrollTop = debugPanel.scrollHeight;
            console.log(`[DEBUG] ${message}`);
        }
        
        // Simple Three.js scene
        let scene, camera, renderer;
        let cube;
        
        function init() {
            debug('Starting minimal test...');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            debug('Scene created');
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            debug('Camera created');
            
            // Create renderer directly on the document body
            try {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                debug('Renderer created and appended to document body');
            } catch (error) {
                debug(`Error creating renderer: ${error.message}`);
                return;
            }
            
            // Create a simple cube
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            debug('Cube created and added to scene');
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);
            debug('Lights added');
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation
            debug('Starting animation');
            animate();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            debug('Window resized');
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate cube
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;
            
            // Render
            renderer.render(scene, camera);
        }
        
        // Start everything when window loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
 
 
