===================================================== 
NUMBERBLOCKS GAME - COMPLETE CODE COMPILATION 
===================================================== 
 
===================================================== 
SECTION: MEMORY BANK 
===================================================== 
 
----------------------------------------------------- 
FILE: memory bank\architecture.md 
----------------------------------------------------- 
 
Root
├── index.html
├── package.json
├── README.md
├── assets
│   ├── images
│   ├── models
│   └── sounds
├── css
│   └── styles.css
├── js
│   ├── main.js
│   ├── controls.js
│   ├── numberblock.js
│   ├── player.js
│   ├── operators.js
│   ├── network.js
│   ├── hud.js
│   ├── gameModes.js
│   └── operator.js
└── lib
    └── three.min.js

    Explanation of the Structure
Root: The top-level directory containing essential project files:
index.html: The main HTML file that serves as the entry point for your application or game.

package.json: (Optional) A file for managing project dependencies if you're using Node.js or a package manager like npm.

README.md: A Markdown file for project documentation, instructions, and notes.

assets/: A folder for all static resources:
images/: Stores image files like textures, icons, or sprites.

models/: Holds 3D model files (if applicable, e.g., for a 3D game).

sounds/: Contains audio files such as sound effects or background music.

css/: A folder for styling:
styles.css: The primary CSS file for styling your UI, HUD, or other visual elements.

js/: A folder for all JavaScript files, each serving a specific purpose:
main.js: The core script that initializes the project (e.g., sets up the scene or game loop).

controls.js: Handles user input and controls (e.g., keyboard or mouse events). Features:
  - Robust fallback mechanisms for browser API compatibility
  - First-person camera controls with parent-child hierarchy for proper rotation
  - Separated yaw and pitch rotations for natural camera movement
  - Mouse locking within the game window with proper cursor disengagement
  - Event handler management for clean switching between locked/unlocked states
  - Support for WASD/Arrow keys movement and spacebar jumping

numberblock.js: Implements the Numberblock class for creating and managing Numberblock entities. Features:
  - Dynamic creation of block stacks based on numeric value
  - Face rendering with eyes and mouth on the top block
  - Arms with hands on the sides of blocks
  - Feet on the bottom block
  - Number tag display on top of the stack
  - Color mapping based on Numberblocks TV show aesthetics
  - HTML/CSS overlay for number display
  - Methods for updating and animating Numberblocks

player.js: Manages player-related logic (e.g., movement, health).

operators.js: Contains logic for operators or game entities (e.g., enemies, NPCs).

network.js: Implements networking features (e.g., multiplayer via WebSockets).

hud.js: Updates the heads-up display (e.g., score, health bar).

gameModes.js: Defines different game modes or rules.

operator.js: Manages operator-related logic (e.g., spawning, lifecycle).

lib/: A folder for external libraries:
three.min.js: The minified Three.js library for 3D rendering (you can add other libraries here as needed).

memory bank/: A folder for documentation and development notes:
implementation plan: Detailed steps for implementing the game features.
progress.md: Tracks completed steps and progress notes.
RULES.md: Contains development guidelines and best practices.
architecture.md: 
# Numberblocks Game Architecture

## Core Components

### 1. Scene Management (main.js)
- Scene initialization and setup
- Camera configuration
- Lighting setup
- Animation loop
- Asset loading
- Proper initialization order:
  1. Scene, camera, renderer setup
  2. Ground and environment
  3. Player Numberblock creation
  4. Operator system initialization
  5. Controls initialization

### 2. Controls System (controls.js)
- First-person camera controls using PointerLockControls
- Movement handling (WASD/Arrow keys)
  - W = Forward movement
  - S = Backward movement
  - A = Strafe left
  - D = Strafe right
- Jump mechanics (Spacebar)
- Gravity and ground collision
- Fallback controls for environments without Pointer Lock
- Delta time-based smooth movement
- Debug logging for control states

### 3. Numberblock System (numberblock.js)
- Numberblock class for player and NPCs
- Geometry and material management
- Position and rotation handling
- Height-based properties
- Camera offset calculations
- Ground collision detection

### 4. Operator System (operator.js)
- Operator class for mathematical operations
- OperatorManager for spawning and lifecycle
- Position and rotation management
- Billboarding for operator symbols
- Integration with player movement

## File Structure
```
/
├── index.html          # Main HTML file
├── js/
│   ├── main.js        # Main game logic
│   ├── controls.js    # Movement and camera controls
│   ├── numberblock.js # Numberblock implementation
│   └── operator.js    # Operator system
├── css/
│   └── style.css      # Game styles
└── memory bank/
    ├── progress.md    # Implementation progress
    └── architecture.md # This file
```

## Initialization Flow
1. Load Three.js and custom scripts
2. Initialize WebGL renderer
3. Create scene and setup lighting
4. Create ground and environment
5. Initialize player Numberblock
6. Setup operator system
7. Initialize controls
8. Start animation loop

## Control Flow
1. User input captured via event listeners
2. Movement state updated
3. Controls updated in animation loop
4. Player position updated
5. Numberblock follows camera with offset
6. Scene rendered

## Future Components
- Collision system
- Number operations
- UI system
- Score tracking
- Game state management
 
 
----------------------------------------------------- 
FILE: memory bank\game design document.md 
----------------------------------------------------- 
 
Numberblocks FPS Game Design Document
Introduction
This document outlines the design for a multiplayer, browser-based, first-person perspective game inspired by the Numberblocks TV show. Players take on the role of Numberblocks, collect mathematical operators, and interact with other players to change their numerical values, aiming to achieve specific objectives in a fun and engaging way.
Overview
In this game, players navigate a colorful 3D world as Numberblocks, each representing a number. By collecting floating plus (+) and minus (-) operators and bumping into other players, they can add or subtract the other player's number from their own, altering their value. The game offers various modes, such as reaching a target number or eliminating opponents by reducing them to zero.
Core Mechanics
Player Movement
Players move in a first-person perspective with standard FPS controls:
WASD or arrow keys: Move forward, backward, left, and right.

Mouse: Look around.

Spacebar: Jump 

Operator Collection
Plus (+) and minus (-) operators spawn randomly across the game world.

Players collect an operator by running into it and can hold only one at a time.

Operators are visually distinct (e.g., a glowing "+" or "−") and float slightly above the ground.

Bumping Interaction
When a player with an operator bumps into another player, the operator is applied:
Plus Operator (+): The initiating player's number becomes their current number plus the other player's number (e.g., 3 + 2 = 5).

Minus Operator (-): The initiating player's number becomes their current number minus the other player's number (e.g., 3 - 2 = 1).

The other player's number remains unchanged.

The operator is consumed after use, requiring the player to collect a new one.

Number Changes
As a player's number changes, their character model updates:
Larger numbers grow in size (e.g., a Numberblock of 10 is bigger than one of 1).  The player's avatar is blocks that amount to their number.

Optional balancing: Larger numbers move slower but resist displacement, while smaller numbers are faster but more vulnerable.

Game World
Visual Style
The environment is bright, blocky, and inspired by the Numberblocks aesthetic.

Features include platforms, ramps, hiding spots, and open areas for player interaction.

Maps
Multiple themed maps:
Number Forest: Trees and terrain shaped like numbers.

Block City: A city of colorful block buildings.

Mathematical Playground: A playful area with slides and obstacles.

Maps encourage exploration and strategic positioning.

Interactive Elements
Some areas may require a specific number to access (e.g., a gate that opens only for players ≥ 10).

Player Characters
Appearance
Players are Numberblocks, with a block count matching their current number.  Their shape may be straight up, or rows of several blocks, or even arms and legs as the numbers get bigger.  But they are always made of blocks and their number is always visible.

The model dynamically adjusts as the number changes (e.g., growing from 1 block to 10 blocks).

Size and Speed (Optional)
Larger Numbers: Slower movement speed, harder to push.

Smaller Numbers: Faster movement, easier to displace.

This adds a layer of strategy to growing or shrinking.

Operators
Spawning
Operators appear at random intervals and locations on the map.

Spawn rates are balanced to ensure availability without overwhelming players.

Collection
Players collect an operator by touching it.

Collecting a new operator replaces the current one if the player is already holding one.

Usage
Operators activate automatically upon bumping into another player.

After use, the operator is consumed.

Game Objectives
The game supports multiple modes:
1. Target Number Mode
Objective: Reach a specific number (e.g., 100) by adding to your value.

The first player to hit the target wins.

2. Elimination Mode
Objective: Reduce other players to zero or below using the minus operator.

Players at zero or negative are eliminated; the last one standing wins.

3. Score-Based Mode
Objective: Earn points for each operation performed (e.g., +1 point per addition/subtraction).

The player with the most points at the end wins, tracked via a leaderboard.

Multiplayer Features
Real-Time Interaction
Multiple players inhabit the same world, interacting in real time.

Players can see each other's numbers and operators for strategic planning.

Teams (Optional)
Team modes allow collaboration, such as achieving the highest combined team number.

Handling Edge Cases
Zero or Negative Numbers
If a player's number reaches zero or below:
Respawn Option: They are out for 10 seconds, then return as 1.

Elimination Option: They are removed from the round (used in Elimination Mode).

Maximum Number Limit
A cap (e.g., 100) prevents excessive growth.

Optional: Larger numbers face rarer plus operators to slow their progress.

User Interface (UI)
Heads-Up Display (HUD)
Shows:
Player's current number.

Held operator (if any).

Optional: Score or mini-map.

Menus
Main Menu: Choose game mode, map, and settings.

Lobby: Join or create multiplayer matches.

Controls
Movement: WASD or arrow keys.

Look: Mouse.

Jump: Spacebar (if implemented).

Interact: Automatic via bumping.

Audio
Background Music: Upbeat, Numberblocks-inspired tunes.

Sound Effects:
Operator collection (e.g., a cheerful "ding").

Bumping (e.g., a soft "thud").

Number change (e.g., a growing/shrinking sound).

Technical Considerations
Platform
Browser-based, using WebGL for 3D rendering (e.g., Three.js).

Networking
Real-time multiplayer requires server-side syncing of:
Player positions. 

Numbers.

Operator states and spawns.

Optimization
Must run smoothly on various devices/browsers.

Efficient collision detection is key for bumping mechanics.

Future Features
Power-Ups: Shields (block operators) or speed boosts.

Advanced Operators: Multiplication/division for complexity (optional).

Customization: Unlockable colors or accessories for Numberblocks.

Educational Mode: Single-player math puzzles for kids.

Conclusion
This game combines the playful, educational charm of Numberblocks with dynamic FPS gameplay. Its simple mechanics make it accessible to children, while strategic depth and multiplayer fun appeal to all ages. With proper balancing and optimization, it can become an entertaining and educational browser-based experience.

 
 
----------------------------------------------------- 
FILE: memory bank\implementation plan.md 
----------------------------------------------------- 
 
Step 1: Set up the basic project structure
Task: Create a new project and set up the files needed for a Three.js-based game.

Details: 
Create an index.html file with a canvas element.

Add a styles.css file for basic styling (e.g., full-screen canvas).

Create a main.js file for JavaScript code.

Include the Three.js library via a CDN (e.g., <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>).

Test: 
Open the project in a browser.

Check that there are no console errors and a blank canvas appears.

Step 2: Create a basic 3D scene
Task: Set up a simple 3D scene with a ground plane and a camera.

Details: 
In main.js, create a Three.js scene, camera, and renderer.

Add a flat plane (e.g., a large box) as the ground.

Position the camera above the ground and render the scene.

Test: 
Open the project in a browser.

See the ground plane rendered from the camera’s perspective.

Step 3: Implement first-person camera controls
Task: Add first-person movement controls to the camera.

Details: 
Use Three.js’s FirstPersonControls or a custom controller.

Enable WASD keys for movement and mouse for looking around.

Test: 
Use WASD keys to move and the mouse to look around.

Confirm the controls are smooth and responsive.

Step 4: Create a basic Numberblock model
Task: Add a simple Numberblock model to the scene.

Details: 
Create a single cube to represent a Numberblock with the number 1.

Position it slightly above the ground in the scene.

Test: 
Open the project and see the cube in the scene.

Ensure it’s correctly positioned relative to the ground.

Step 5: Implement player movement
Task: Attach the Numberblock model to the camera and add basic movement.

Details: 
Link the cube’s position to the camera so it moves with it.

Add jumping (spacebar) and gravity to prevent falling through the ground.

Test: 
Move with WASD keys and see the cube move.

Press spacebar to jump and watch the cube rise and fall back to the ground.

Step 6: Add operator spawning
Task: Create and spawn plus (+) and minus (-) operators in the scene.

Details: 
Make simple 3D models (e.g., spheres) for operators, colored differently (e.g., green for +, red for -).

Write a function to spawn them randomly on the ground every few seconds.

Test: 
See operators appear over time at different spots.

Verify they sit on the ground, not floating or underground.

Step 7: Implement operator collection
Task: Allow the player to collect operators by touching them.

Details: 
Detect when the player’s Numberblock collides with an operator.

Remove the operator from the scene and store it as the player’s held operator (limit to one).

Test: 
Walk into an operator and see it disappear.

Confirm the player holds it (e.g., log it to the console or show it on-screen).

Step 8: Implement bumping interaction
Task: Enable bumping into another Numberblock to apply the operator.

Details: 
Add a second, static Numberblock with a fixed number (e.g., 2).

Detect collision with it; if the player has an operator, apply it (e.g., 1 + 2 = 3).

Remove the operator after use.

Test: 
Bump into the static Numberblock with an operator.

Check that the player’s number updates (e.g., from 1 to 3) and the operator is consumed.

Step 9: Update Numberblock model based on number
Task: Change the Numberblock model when its number changes.

Details: 
Write a function to stack cubes vertically based on the player’s number (e.g., 3 cubes for 3).

Update the model after a number change.

Test: 
After bumping and changing the number, see the model update (e.g., from 1 cube to 3).

Ensure it doesn’t clip through the ground.

Step 10: Implement basic HUD
Task: Add a heads-up display showing the player’s number and operator.

Details: 
Use HTML elements (e.g., <div>) overlayed on the canvas.

Update the HUD whenever the number or operator changes.

Test: 
See the player’s current number and held operator on-screen.

Verify it updates in real-time after changes.

Step 11: Add multiple players (multiplayer)
Task: Enable basic multiplayer functionality.

Details: 
Use WebSockets or Socket.io for networking.

Allow multiple players to join and see each other’s Numberblocks.

Sync positions and numbers across clients.

Test: 
Open two browser tabs as different players.

See each Numberblock move and confirm numbers sync when changed.

Step 12: Implement game objectives
Task: Add the Target Number Mode.

Details: 
Set a target number (e.g., 10).

Display a win message when a player reaches it.

Test: 
Play and reach the target number.

See a win message appear when achieved.

Step 13: Add more game modes
Task: Implement Elimination Mode and Score-Based Mode.

Details: 
Elimination Mode: Remove players whose number reaches zero or below.

Score-Based Mode: Award points for each operation, shown on a leaderboard.

Test: 
Test Elimination Mode: Reach zero and get removed or respawn.

Test Score-Based Mode: Perform operations and see points increase.

Step 14: Polish and optimize
Task: Enhance visuals, add audio, and improve performance.

Details: 
Add basic textures or colors to models.

Include sound effects (e.g., “ding” for collecting operators).

Optimize rendering for smooth gameplay.

Test: 
Play and ensure no lag or glitches.

Hear sound effects and see improved visuals.

Step 15: Add advanced features (optional)
Task: Introduce power-ups or advanced operators.

Details: 
Add a power-up (e.g., speed boost) that spawns like operators.

Optionally, include multiplication operators (e.g., ×2).

Test: 
Collect a power-up and see its effect (e.g., faster movement).

Use an advanced operator and verify the number change.

Conclusion
This implementation plan provides a clear, step-by-step roadmap to develop the Numberblocks FPS game. Each step is simple enough to be handled with a single prompt in the Windsurf IDE, and the accompanying tests ensure that each feature works before moving forward. By following this plan, you can progressively build a fully functional browser-based multiplayer game that aligns with the game design document’s vision.

 
 
----------------------------------------------------- 
FILE: memory bank\progress.md 
----------------------------------------------------- 
 
# Numberblocks Game - Progress Log

## March 15, 2025
- Completed Step 1 of implementation plan: Set up basic project structure
  - Created index.html with canvas element
  - Added styles.css for basic styling (full-screen canvas)
  - Created main.js for JavaScript code
  - Included Three.js library via CDN
  - Created directory structure following the architecture document
  - Verified that the project loads in browser with no console errors
- Created comprehensive README.md file
- Set up Git repository and GitHub remote
- Added .gitignore file for the project
- Completed Step 2 of implementation plan: Created a basic 3D scene
  - Implemented Three.js scene, camera, and renderer in main.js
  - Added a flat green plane as the ground
  - Positioned the camera above the ground
  - Added proper lighting (ambient and directional)
  - Implemented window resize handling
  - Set up the animation loop
- Completed Step 3 of implementation plan: Implemented first-person camera controls
  - Created controls.js for camera movement functionality
  - Implemented Three.js PointerLockControls for first-person view
  - Added WASD and arrow key movement
  - Implemented jumping with spacebar
  - Added controls info overlay for user guidance
  - Added appropriate styles for the overlay UI
  - Implemented robust fallback mechanism for environments where Pointer Lock API is unavailable
  - Added error handling with try-catch blocks for browser API compatibility
  - Created mockControls object that mimics the PointerLockControls interface for seamless operation
  - Enhanced FPS camera controls:
    - Added parent-child object hierarchy for proper camera rotation
    - Separated yaw (horizontal) and pitch (vertical) rotations for natural camera movement
    - Implemented pitch clamping to prevent camera flipping
    - Added mouse locking within the game window using CSS and event handling
    - Ensured proper cursor disengagement when ESC key is pressed
    - Implemented proper event listener cleanup for complete mouse control disengagement
  - Updated RULES.md with browser API considerations based on implementation experience
- Completed Step 4 of implementation plan: Created a basic Numberblock model
  - Implemented Numberblock class in numberblock.js with all required features:
    - Created a stack of blocks representing the Numberblock's value
    - Added face with eyes and mouth to the top block
    - Added arms on the sides (positioned based on number of blocks)
    - Added feet to the bottom block
    - Added a number tag on top showing the Numberblock's value
  - Used appropriate colors matching the Numberblocks TV show aesthetic
  - Integrated the Numberblock model with the main game:
    - Added the Numberblock to follow the player's movement
    - Positioned it in front of the camera for a first-person view
    - Implemented smooth interpolation for natural movement
    - Added HTML/CSS-based number display that follows the 3D model
  - Added helper functions for creating and updating Numberblocks
  - Added proper resource cleanup methods to prevent memory leaks
- Completed Step 5 of implementation plan: Implemented player movement (partial collision)
  - Added getHeight method to Numberblock class for accurate height calculation
  - Improved jumping mechanics with physically accurate jump formula
  - Implemented basic ground collision detection to prevent falling through the ground
  - Created true first-person view where camera positioned from Numberblock's perspective
  - Ensured perfect synchronization between camera and Numberblock during all movements
  - Implemented two-way position binding to maintain consistent camera-Numberblock relationship
  - Note: Full collision system with other objects not implemented yet
- Completed Step 6 of implementation plan: Added operator spawning
  - Created Operator and OperatorManager classes
  - Implemented operator spawning system
  - Added proper positioning and rotation
  - Integrated with player controls
  - Fixed movement controls after operator integration
  - Ensured proper initialization order

## Next Steps
- Step 7: Implement collision system
- Step 8: Implement number operations 
 
----------------------------------------------------- 
FILE: memory bank\RULES.md 
----------------------------------------------------- 
 
# Development Rules and Notes

## PowerShell Command Issues

### Directory Creation
- When creating multiple directories at once with PowerShell's `mkdir` command, you must use quotes when specifying paths with spaces or multiple directories:
  ```
  # INCORRECT (will fail):
  mkdir css js assets assets\images assets\models assets\sounds
  
  # CORRECT (individual commands):
  mkdir css
  mkdir js
  mkdir assets
  mkdir "assets\images"
  mkdir "assets\models"
  mkdir "assets\sounds"
  ```

- PowerShell's `mkdir` doesn't support multiple directory arguments like in Linux/macOS. Create directories one by one or use a loop.

## Server Management and Development Workflow

### Restarting the Development Server
- When making changes to JavaScript files, use the following process to restart the server for clean testing:
  ```powershell
  # 1. Kill any running Node.js server instances (prevents port conflicts)
  taskkill /f /im node.exe
  
  # 2. Start the http-server with cache disabled
  npx http-server -c-1
  ```
- The `-c-1` flag disables caching, ensuring that file changes are immediately visible
- Always kill previous instances of the server to avoid potential port conflicts
- Using `taskkill /f /im node.exe` is more reliable than Ctrl+C which sometimes leaves orphaned processes

## Three.js Implementation Notes

- Always include the Three.js library before your own JavaScript files in the HTML
- When testing, make sure to run a local HTTP server rather than opening the HTML file directly due to CORS restrictions with resource loading
- Use a thin BoxGeometry instead of PlaneGeometry for the ground to ensure proper lighting on both sides
- Always implement window resize handling for responsive design (update camera aspect ratio and renderer size)
- For better performance, set renderer.setPixelRatio to match the device's pixel ratio

## Browser API Considerations

- The Pointer Lock API (used by PointerLockControls) may not work in some environments, especially in embedded preview browsers or when served through certain proxies
- Always implement a fallback mechanism for critical browser APIs in case they fail
- Use try-catch blocks around browser API calls that might not be supported in all environments
- Check browser console for API-related errors when testing in different environments
- When implementing mouse controls:
  - Proper event listener management is essential (add/remove listeners appropriately)
  - Always provide visual feedback when controls are locked/unlocked
  - Ensure complete disengagement of controls when user presses ESC

## JavaScript Considerations

- When using event handlers, store references to them for proper removal later to prevent memory leaks
- For event-based systems (like controls), implement a proper event dispatcher mechanism
- Use class-based or module patterns for complex components to keep code organized
- When dealing with 3D rotations:
  - Separate axes of rotation (yaw, pitch, roll) to prevent gimbal lock issues
  - Always clamp vertical rotation (pitch) to prevent camera flipping

## Git Workflow

- Always update the progress.md file after completing each implementation step
- Keep commit messages descriptive and related to the implementation plan steps

## Project Structure

- Follow the architecture document precisely to ensure consistency
- New JavaScript files should be placed in the js/ directory and then linked in index.html as needed 
 
----------------------------------------------------- 
FILE: memory bank\tech stack.md 
----------------------------------------------------- 
 
Tech Stack
Front-End
HTML5: Provides the structure for the game, including the canvas element for 3D rendering and UI components like the heads-up display (HUD) and menus.

CSS3: Styles the UI elements, such as the HUD, player stats, and overlays, ensuring they look polished and are positioned correctly over the game canvas.

JavaScript (ES6+): Drives the game logic, handling player movement, operator collection, real-time updates, and interactions between Numberblocks.

Three.js: A JavaScript library that simplifies WebGL for 3D rendering, used to create the game world, dynamic Numberblock models (e.g., stacks of cubes), and themed maps like Number Forest or Block City.

Web Audio API: Manages audio, including sound effects for actions like bumping into players or collecting operators, and optional background music for immersion.

Back-End
Node.js: Acts as the server-side runtime, serving static files (HTML, CSS, JavaScript) and managing game logic for multiplayer sessions, such as validating player actions and maintaining game state authority.

Socket.io: Facilitates real-time, bidirectional communication between players, syncing positions, numbers, and operator states for a seamless multiplayer experience.

Development Tools
Git: Version control system to track changes, collaborate with others (if applicable), and manage the project’s codebase effectively.

Local Server: A simple server like http-server or Node.js’s built-in http module for testing the game locally during development, simulating both single-player and multiplayer scenarios.

Jest (Optional): A JavaScript testing framework to verify game logic (e.g., operator interactions, collision detection), which can be added as the project scales.

Hosting
Heroku (or similar platforms like AWS, DigitalOcean): Hosts the Node.js application, serving both the front-end assets and WebSocket connections for multiplayer functionality, offering a straightforward deployment solution.

Why This Stack?
Front-End: HTML, CSS, and JavaScript are core web technologies, making them essential for a browser-based game. Three.js provides an accessible way to render 3D graphics, while the Web Audio API ensures robust audio support.

Back-End: Node.js integrates seamlessly with JavaScript and Socket.io, offering a lightweight yet powerful solution for real-time multiplayer features like position syncing and player interactions.

Development Tools: Git is a standard for version control, and a local server simplifies testing. Jest is optional but recommended for ensuring reliability as complexity grows.

Hosting: Heroku supports Node.js and WebSocket applications out of the box, making it an ideal choice for deploying the full game (front-end and back-end) in one place.

This tech stack aligns with your project’s needs: a browser-based, multiplayer 3D FPS game with dynamic Numberblock characters, real-time interactions, and themed environments. It’s lightweight, scalable, and leverages widely-used web technologies. Let me know if you’d like more details on any component!

 
 
===================================================== 
FILE: debug-test.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numberblocks Debug Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #debug-canvas { width: 100%; height: 100%; display: block; }
        #debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            z-index: 1000;
            max-width: 400px;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <canvas id="debug-canvas"></canvas>
    <div id="debug-info">Loading...</div>
    
    <!-- Load Three.js library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    
    <script>
        // Debug log function
        function log(message) {
            console.log(message);
            const debugInfo = document.getElementById('debug-info');
            debugInfo.innerHTML += `<div>${message}</div>`;
        }
        
        // Error handler
        window.onerror = function(message, source, lineno, colno, error) {
            log(`ERROR: ${message} at ${source}:${lineno}`);
            return false;
        };
        
        // Initialize everything
        window.addEventListener('load', () => {
            log('Page loaded, initializing Three.js');
            
            // Check if Three.js is available
            if (typeof THREE === 'undefined') {
                log('ERROR: THREE is not defined! Check network connection or CDN link.');
                return;
            }
            
            log(`THREE.js version ${THREE.REVISION} loaded successfully`);
            
            try {
                // Create scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue
                log('Scene created with blue background');
                
                // Create camera
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 0, 0);
                log(`Camera created at position (${camera.position.x}, ${camera.position.y}, ${camera.position.z})`);
                
                // Create renderer
                const canvas = document.getElementById('debug-canvas');
                if (!canvas) {
                    log('ERROR: Canvas element not found!');
                    return;
                }
                
                const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                log('Renderer created and attached to canvas');
                
                // Check if renderer is working properly
                if (!renderer.domElement) {
                    log('ERROR: Renderer domElement is not available!');
                    return;
                }
                
                // Create a simple ground plane
                const groundGeometry = new THREE.BoxGeometry(50, 0.1, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x7CFC00, // Green
                    roughness: 0.8, 
                    metalness: 0.2 
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.position.y = -0.05;
                scene.add(ground);
                log('Ground plane added to scene');
                
                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                // Add directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                scene.add(directionalLight);
                log('Lights added to scene');
                
                // Add a visible object to confirm rendering
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.set(0, 1, 0);
                scene.add(cube);
                log('Red cube added to center of scene for visibility test');
                
                // Testing WebGL capabilities
                log('WebGL Capabilities:');
                const gl = renderer.getContext();
                log(`Max texture size: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}`);
                log(`WebGL version: ${gl.getParameter(gl.VERSION)}`);
                log(`Renderer: ${gl.getParameter(gl.RENDERER)}`);
                log(`Vendor: ${gl.getParameter(gl.VENDOR)}`);
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    // Rotate the cube to make it obvious if rendering is working
                    cube.rotation.x += 0.01;
                    cube.rotation.y += 0.01;
                    
                    // Render the scene
                    renderer.render(scene, camera);
                }
                
                // Start animation
                animate();
                log('Animation loop started');
                
                // Add window resize handler
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    log('Window resized, canvas adjusted');
                });
                
                log('Debug test initialization complete, you should see a rotating red cube');
            } catch (e) {
                log(`CRITICAL ERROR: ${e.message}`);
                log(`Stack trace: ${e.stack}`);
            }
        });
    </script>
</body>
</html>
 
 
===================================================== 
FILE: index.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numberblocks Game</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <canvas id="game-canvas"></canvas>
    
    <div id="controls-info" class="overlay">
        <h2>Numberblocks Game</h2>
        <p>Click anywhere to enable controls</p>
        <ul>
            <li>Move: WASD or Arrow Keys</li>
            <li>Jump: Space</li>
            <li>Look: Mouse</li>
        </ul>
    </div>
    
    <!-- Three.js library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    
    <!-- Game JavaScript files -->
    <script src="js/controls.js"></script>
    <script src="js/numberblock.js"></script>
    <script src="js/operator.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
 
 
===================================================== 
FILE: css\styles.css 
===================================================== 
 
/* Reset default margins and padding */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body, html {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: Arial, sans-serif;
}

/* Make the canvas fill the entire screen */
#game-canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* Controls info overlay */
.overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    z-index: 100;
}

.overlay h2 {
    margin-bottom: 10px;
}

.overlay p {
    margin-bottom: 15px;
}

.overlay ul {
    list-style-type: none;
    text-align: left;
    margin: 0 auto;
    display: inline-block;
}

.overlay ul li {
    margin-bottom: 5px;
}
 
 
===================================================== 
FILE: js\collision.js 
===================================================== 
 
/**
 * Numberblocks AABB Collision System
 * Uses Axis-Aligned Bounding Boxes for efficient collision detection
 */

// Collection of collidable objects
let collidableObjects = [];
let debugMode = true; // Set to true to see debug logging

// Initialize collision system and collect collidable objects from the scene
function initCollisionSystem(scene) {
    console.log("Initializing collision system...");
    collidableObjects = [];
    
    // Traverse the scene to find all collidable objects
    scene.traverse((object) => {
        if (object.isMesh && object.userData && object.userData.collidable === true) {
            collidableObjects.push(object);
            if (debugMode) console.log(`Added collidable object: ${object.name || 'unnamed object'}`);
        }
    });
    
    console.log(`Collision system initialized with ${collidableObjects.length} collidable objects`);
    return collidableObjects.length;
}

// Add a single object to the collidable objects list
function addCollidableObject(object) {
    if (!object || !(object.isMesh || object.isGroup)) return;
    
    // Mark the object as collidable
    object.userData = object.userData || {};
    object.userData.collidable = true;
    
    // Add a name if it doesn't have one for easier debugging
    if (!object.name) {
        object.name = `collidable_${collidableObjects.length}`;
    }
    
    // Only add if not already in the list
    if (!collidableObjects.includes(object)) {
        collidableObjects.push(object);
        if (debugMode) console.log(`Added collidable object: ${object.name}`);
        
        // If it's a group, also make all children collidable
        if (object.isGroup && object.children) {
            object.children.forEach(child => {
                if (child.isMesh) {
                    child.userData = child.userData || {};
                    child.userData.collidable = true;
                    collidableObjects.push(child);
                    if (debugMode) console.log(`Added child collidable object: ${child.name || 'unnamed child'}`);
                }
            });
        }
    }
}

// Create or update a bounding box for a mesh
function updateAABB(mesh) {
    if (!mesh) return null;
    
    // Use Three.js Box3 to create a bounding box from the mesh
    const box = new THREE.Box3().setFromObject(mesh);
    return box;
}

// Check if two bounding boxes intersect
function checkCollision(boxA, boxB) {
    if (!boxA || !boxB) return false;
    return boxA.intersectsBox(boxB);
}

// Get the minimum translation vector to resolve a collision
function getCollisionResponse(boxA, boxB) {
    // Create a box that represents the intersection
    const intersection = new THREE.Box3();
    intersection.copy(boxA).intersect(boxB);
    
    // Get the size of the intersection
    const size = intersection.getSize(new THREE.Vector3());
    
    // Find the minimum penetration axis (x, y, or z)
    let axis, minSize;
    
    if (size.x <= size.y && size.x <= size.z) {
        axis = 'x';
        minSize = size.x;
    } else if (size.y <= size.x && size.y <= size.z) {
        axis = 'y';
        minSize = size.y;
    } else {
        axis = 'z';
        minSize = size.z;
    }
    
    // Return the direction and amount to move
    const response = {
        axis: axis,
        depth: minSize,
        direction: new THREE.Vector3()
    };
    
    // Calculate the direction to move (away from the obstacle)
    const centerA = boxA.getCenter(new THREE.Vector3());
    const centerB = boxB.getCenter(new THREE.Vector3());
    
    if (axis === 'x') {
        response.direction.x = centerA.x < centerB.x ? -1 : 1;
    } else if (axis === 'y') {
        response.direction.y = centerA.y < centerB.y ? -1 : 1;
    } else {
        response.direction.z = centerA.z < centerB.z ? -1 : 1;
    }
    
    return response;
}

// Check collisions for the player against all collidable objects
function checkPlayerCollisions(playerMesh, controlsObject) {
    if (!playerMesh || !controlsObject || collidableObjects.length === 0) {
        return { collision: false, grounded: false };
    }
    
    // Update player bounding box
    const playerBox = updateAABB(playerMesh);
    let hasCollision = false;
    let isGrounded = false;
    
    // Check against all collidable objects
    for (const obstacle of collidableObjects) {
        // Skip player's own mesh
        if (obstacle === playerMesh) continue;
        
        const obstacleBox = updateAABB(obstacle);
        if (checkCollision(playerBox, obstacleBox)) {
            hasCollision = true;
            if (debugMode) console.log(`Collision detected with ${obstacle.name || 'unnamed object'}`);
            
            // Handle the collision and check if we're standing on something
            const collisionResult = handleCollision(playerBox, obstacleBox, controlsObject);
            if (collisionResult.landedOnTop) {
                isGrounded = true;
            }
        }
    }
    
    return { collision: hasCollision, grounded: isGrounded };
}

// Apply collision response and return collision info
function handleCollision(playerBox, obstacleBox, controlsObject) {
    const response = getCollisionResponse(playerBox, obstacleBox);
    
    // Apply a small buffer to prevent getting stuck
    const buffer = 0.1;
    let landedOnTop = false;
    
    // Apply the collision response to the controls object
    if (response.axis === 'x') {
        controlsObject.position.x += (response.depth + buffer) * response.direction.x;
    } else if (response.axis === 'y') {
        // For Y-axis collisions, we need to determine if we landed on top
        if (response.direction.y > 0) {
            // We hit the bottom of something
            controlsObject.position.y += (response.depth + buffer) * response.direction.y;
        } else {
            // We landed on top of something
            controlsObject.position.y += (response.depth + buffer) * response.direction.y;
            landedOnTop = true;
            
            // Stop any downward velocity if we're using physics
            if (controlsObject.userData && controlsObject.userData.velocity) {
                controlsObject.userData.velocity.y = 0;
            }
        }
    } else {
        controlsObject.position.z += (response.depth + buffer) * response.direction.z;
    }
    
    return { landedOnTop };
}

// Mark objects in the scene as collidable
function markAllObjectsAsCollidable(scene) {
    scene.traverse(object => {
        // Skip the player, camera, lights, and ground
        if (object.name === 'ground' || 
            object.name === 'player' || 
            object.isLight || 
            object.isCamera) {
            return;
        }
        
        // Mark all meshes that aren't the player, lights, or ground as collidable
        if (object.isMesh) {
            object.userData = object.userData || {};
            object.userData.collidable = true;
            
            // Add it to our collidable objects array if not already there
            if (!collidableObjects.includes(object)) {
                collidableObjects.push(object);
                if (debugMode) console.log(`Auto-marked as collidable: ${object.name || 'unnamed mesh'}`);
            }
        }
    });
    
    console.log(`Total collidable objects after auto-marking: ${collidableObjects.length}`);
}

// No modules export - functions are accessible globally for traditional script inclusion
 
 
===================================================== 
FILE: js\controls.js 
===================================================== 
 
// Numberblocks game - First-person controls implementation

// Global variables
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let canJump = false;
let pitch = 0;  // Track vertical rotation separately

let prevTime = performance.now();
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();

// Player settings
const playerHeight = 2.0;             // Height of camera from ground
const moveSpeed = 5.0;                // Units per second
const jumpHeight = 5.0;               // Jump impulse force
const gravity = 9.8;                  // Gravity force 

// Flag to force fallback controls (for environments like browser previews)
const forceFallbackControls = false;

// Initialize controls for the camera
function initControls(camera, domElement) {
    console.log("Initializing controls...");
    
    // Always use fallback controls in browser preview environments
    if (forceFallbackControls) {
        console.log("Using fallback controls (forced)");
        return createFallbackControls(camera, domElement);
    }
    
    // For non-preview environments, try to use PointerLockControls
    try {
        // Test if Pointer Lock API is supported
        if (!document.pointerLockElement && 
            !document.mozPointerLockElement && 
            !document.webkitPointerLockElement) {
            console.log("Pointer Lock API not supported, using fallback");
            return createFallbackControls(camera, domElement);
        }
        
        console.log("Using PointerLockControls");
        
        // Create PointerLockControls
        const controls = new THREE.PointerLockControls(camera, domElement);
        
        // Set up click event
        domElement.addEventListener('click', () => {
            console.log("Canvas clicked, requesting pointer lock");
            controls.lock();
        });
        
        // Event listeners for controls state
        controls.addEventListener('lock', () => {
            console.log("PointerLock controls LOCKED");
            document.getElementById('controls-info').style.display = 'none';
        });
        
        controls.addEventListener('unlock', () => {
            console.log("PointerLock UNLOCKED");
            document.getElementById('controls-info').style.display = 'block';
        });
        
        // Add keyboard controls with debug logging
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        // Store controls object for movement functions
        controls.moveState = {
            moveForward: () => controls.moveForward(moveSpeed * clock.getDelta()),
            moveBackward: () => controls.moveForward(-moveSpeed * clock.getDelta()),
            moveLeft: () => controls.moveRight(-moveSpeed * clock.getDelta()),
            moveRight: () => controls.moveRight(moveSpeed * clock.getDelta())
        };
        
        return controls;
    } catch (e) {
        console.error('Error initializing controls, using fallback:', e);
        return createFallbackControls(camera, domElement);
    }
}

// Create improved fallback controls
function createFallbackControls(camera, domElement) {
    const pitchObject = new THREE.Object3D();
    pitchObject.add(camera);

    const controlsObject = new THREE.Object3D();
    controlsObject.add(pitchObject);

    // Track active event handlers for removal when needed
    const activeEventListeners = {
        mousemove: null,
        mouseleave: null,
        keydown: null
    };

    const mockControls = {
        isLocked: false,
        getObject: () => controlsObject,

        moveForward: (distance) => {
            if (!mockControls.isLocked) return;
            const dir = new THREE.Vector3(0, 0, -1);
            dir.applyQuaternion(controlsObject.quaternion);
            controlsObject.position.addScaledVector(dir, distance);
        },
        moveRight: (distance) => {
            if (!mockControls.isLocked) return;
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(controlsObject.quaternion);
            controlsObject.position.add(right.multiplyScalar(distance));
        },

        lock: function() {
            if (this.isLocked) return;

            this.isLocked = true;
            document.getElementById('controls-info').style.display = 'none';
            document.body.style.cursor = 'none';
            
            // Attempt to use standard pointer lock if available
            try {
                if (domElement.requestPointerLock) {
                    domElement.requestPointerLock();
                } else if (domElement.mozRequestPointerLock) {
                    domElement.mozRequestPointerLock();
                } else if (domElement.webkitRequestPointerLock) {
                    domElement.webkitRequestPointerLock();
                }
            } catch (e) {
                console.error('Pointer lock not supported, using fallback cursor hiding');
            }
            
            // Apply cursor containment styles
            document.body.classList.add('cursor-locked');

            // Add event listeners only when locked
            this.setupEventListeners();
            
            this.dispatchEvent({ type: 'lock' });
        },

        unlock: function() {
            if (!this.isLocked) return;

            this.isLocked = false;
            document.getElementById('controls-info').style.display = 'block';
            document.body.style.cursor = 'auto';
            
            // Exit pointer lock if active
            try {
                if (document.exitPointerLock) {
                    document.exitPointerLock();
                } else if (document.mozExitPointerLock) {
                    document.mozExitPointerLock();
                } else if (document.webkitExitPointerLock) {
                    document.webkitExitPointerLock();
                }
            } catch (e) {
                console.error('Error exiting pointer lock');
            }
            
            // Remove cursor containment styles
            document.body.classList.remove('cursor-locked');
            
            // Remove event listeners when unlocked to fully disengage
            this.removeEventListeners();
            
            this.dispatchEvent({ type: 'unlock' });
        },
        
        setupEventListeners: function() {
            // Mouse look event handling
            const mouseMoveHandler = (event) => {
                if (!mockControls.isLocked) return;

                // For browsers that don't support pointer lock, we can use this approach
                // to at least keep processing mouse events even at screen edges
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                
                // Only apply reasonable movements to avoid jumps
                if (Math.abs(movementX) < 100 && Math.abs(movementY) < 100) {
                    controlsObject.rotation.y -= movementX * 0.002; // Unlimited horizontal rotation (yaw)
                    
                    pitch -= movementY * 0.002; // track pitch separately
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch)); // limit pitch
                    pitchObject.rotation.x = pitch; // apply limited pitch
                }
            };

            // Handle mouseleave to prevent cursor from exiting the window
            const mouseLeaveHandler = (event) => {
                if (mockControls.isLocked) {
                    // If mouse leaves the window, simulate it returning to center
                    // This keeps the cursor within the window bounds
                    const rect = domElement.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    // Create a new mouse event to simulate mouse movement
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: centerX,
                        clientY: centerY,
                        screenX: centerX,
                        screenY: centerY,
                        movementX: 0,
                        movementY: 0
                    });
                    
                    // Dispatch the event
                    document.dispatchEvent(mouseEvent);
                }
            };

            // Escape to unlock controls
            const escKeyHandler = (event) => {
                if (event.code === 'Escape' && mockControls.isLocked) {
                    mockControls.unlock();
                }
            };

            // Store references to handlers so we can remove them later
            activeEventListeners.mousemove = mouseMoveHandler;
            activeEventListeners.mouseleave = mouseLeaveHandler;
            activeEventListeners.keydown = escKeyHandler;

            // Add the event listeners
            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseleave', mouseLeaveHandler);
            document.addEventListener('keydown', escKeyHandler);
        },
        
        removeEventListeners: function() {
            // Remove all active event listeners to fully disengage
            if (activeEventListeners.mousemove) {
                document.removeEventListener('mousemove', activeEventListeners.mousemove);
            }
            
            if (activeEventListeners.mouseleave) {
                document.removeEventListener('mouseleave', activeEventListeners.mouseleave);
            }
            
            if (activeEventListeners.keydown) {
                document.removeEventListener('keydown', activeEventListeners.keydown);
            }
        },
        
        _listeners: {},
        addEventListener: function(type, listener) {
            this._listeners[type] = this._listeners[type] || [];
            this._listeners[type].push(listener);
        },
        dispatchEvent: function(event) {
            if (this._listeners[event.type]) {
                this._listeners[event.type].forEach(listener => listener.call(this, event));
            }
        }
    };

    // Add CSS to trap cursor within game area
    const style = document.createElement('style');
    style.textContent = `
        .cursor-locked {
            cursor: none !important;
            user-select: none;
            -webkit-user-select: none;
        }
        .cursor-locked * {
            cursor: none !important;
        }
    `;
    document.head.appendChild(style);

    // Click event handling - this one remains always active
    domElement.addEventListener('click', () => {
        if (!mockControls.isLocked) mockControls.lock();
    });

    // Add keyboard event listeners for movement - these remain always active
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    return mockControls;
}

// Key down event handler
function onKeyDown(event) {
    // Skip if we're in an input field or textarea
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
        return;
    }
    
    // Map key code to action
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = true;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = true;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = true;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            moveRight = true;
            break;
            
        case 'Space':
            if (canJump) {
                // Apply a physically accurate jump velocity
                velocity.y = Math.sqrt(jumpHeight * 2 * gravity);
                canJump = false;
            }
            break;
    }
}

// Key up event handler
function onKeyUp(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = false;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = false;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = false;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            moveRight = false;
            break;
    }
}

// Update controls - call this in the animation loop
function updateControls(controls, delta) {
    if (!controls) {
        console.warn("Controls not initialized");
        return;
    }

    // If using PointerLockControls and not locked, return
    if (controls.isLocked === false && !forceFallbackControls) {
        return;
    }

    // Update velocity
    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;
    velocity.y -= gravity * delta; // Apply gravity

    // Apply movement based on key states - fixed direction
    if (moveForward) controls.moveForward(moveSpeed * delta);
    if (moveBackward) controls.moveForward(-moveSpeed * delta);
    if (moveLeft) controls.moveRight(-moveSpeed * delta);
    if (moveRight) controls.moveRight(moveSpeed * delta);

    // Update Y position with gravity
    if (controls.getObject) {
        controls.getObject().position.y += velocity.y * delta;

        // Ground collision
        if (controls.getObject().position.y < playerHeight) {
            velocity.y = 0;
            controls.getObject().position.y = playerHeight;
            canJump = true;
        }
    }
}
 
 
===================================================== 
FILE: js\main.js 
===================================================== 
 
// Numberblocks game - Three.js implementation
console.log('Numberblocks game initializing...');

// Global variables
let scene, camera, renderer;
let ground;
let controls;
let clock;
let playerNumberblock; // Player's Numberblock
let operatorManager; // Operator system manager

// Initialize the Three.js scene
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky blue background
    
    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    
    renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('game-canvas'),
        antialias: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    createGround();
    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);
    
    // Add landscape elements for perspective
    createLandscapeElements();
    
    // Create player's Numberblock
    playerNumberblock = createPlayerNumberblock(scene, 1);

    // Initialize operator system
    window.camera = camera; // Make camera available for operator billboarding
    operatorManager = new OperatorManager(scene);

    controls = initControls(camera, renderer.domElement);

    // CRITICAL FIX: Explicitly set position on controls object (not camera directly)
    controls.getObject().position.set(0, 2, 5);
    scene.add(controls.getObject());
    
    clock = new THREE.Clock();
    window.addEventListener('resize', onWindowResize);
    
    // CRITICAL FIX: Explicitly call onWindowResize to ensure camera's projection matrix is correct initially
    onWindowResize();
    
    animate();
}

// Create the ground plane
function createGround() {
    // Create a large flat plane for the ground
    const groundGeometry = new THREE.BoxGeometry(50, 0.1, 50);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x7CFC00, // Lawn green color
        roughness: 0.8,
        metalness: 0.2
    });
    
    ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.05; // Move it slightly down to center it
    scene.add(ground);
}

// Create random landscape elements for perspective
function createLandscapeElements() {
    // Define bright colors that match Numberblocks aesthetic
    const colors = [
        0xFF0000, // Red (One)
        0xFFA500, // Orange (Two)
        0xFFFF00, // Yellow (Three)
        0x00FF00, // Green (Four)
        0x0000FF, // Blue (Five)
        0x800080, // Purple (Six)
        0xFFC0CB, // Pink (Seven)
        0xA52A2A, // Brown (Eight)
        0x808080  // Grey (Nine)
    ];
    
    // Create 30 random objects
    for (let i = 0; i < 30; i++) {
        let geometry, material, mesh;
        const shapeType = Math.floor(Math.random() * 4); // 0-3 for different shapes
        const colorIndex = Math.floor(Math.random() * colors.length);
        const color = colors[colorIndex];
        
        // Create different shapes
        switch (shapeType) {
            case 0: // Cube (like Numberblock parts)
                const size = 0.5 + Math.random() * 1.5;
                geometry = new THREE.BoxGeometry(size, size, size);
                break;
            case 1: // Cylinder
                const radius = 0.3 + Math.random() * 1;
                const height = 1 + Math.random() * 3;
                geometry = new THREE.CylinderGeometry(radius, radius, height, 16);
                break;
            case 2: // Sphere
                const sphereRadius = 0.5 + Math.random() * 1;
                geometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
                break;
            case 3: // Cone
                const coneRadius = 0.5 + Math.random() * 1;
                const coneHeight = 1 + Math.random() * 2;
                geometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
                break;
        }
        
        // Create material with random color
        material = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        // Create and position the mesh
        mesh = new THREE.Mesh(geometry, material);
        
        // Position randomly on the ground plane (within a 40x40 area)
        const posX = (Math.random() * 40) - 20;
        const posZ = (Math.random() * 40) - 20;
        
        // Calculate Y position based on the shape's height
        let posY;
        if (shapeType === 0) { // Cube
            posY = mesh.geometry.parameters.height / 2;
        } else if (shapeType === 1) { // Cylinder
            posY = mesh.geometry.parameters.height / 2;
        } else if (shapeType === 2) { // Sphere
            posY = mesh.geometry.parameters.radius;
        } else { // Cone
            posY = mesh.geometry.parameters.height / 2;
        }
        
        mesh.position.set(posX, posY, posZ);
        
        // Add random rotation for more variety
        mesh.rotation.y = Math.random() * Math.PI * 2;
        
        // Add to scene
        scene.add(mesh);
    }
    
    // Add some trees as landmarks
    createTrees();
}

// Create simple trees as landmarks
function createTrees() {
    for (let i = 0; i < 10; i++) {
        // Create trunk
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 2, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513, // Brown
            roughness: 0.9
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        
        // Create foliage (as a cone)
        const foliageGeometry = new THREE.ConeGeometry(1.5, 3, 8);
        const foliageMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22, // Forest green
            roughness: 0.8
        });
        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
        foliage.position.y = 2.5; // Position on top of trunk
        
        // Create tree group
        const tree = new THREE.Group();
        tree.add(trunk);
        tree.add(foliage);
        
        // Position randomly on the ground plane but away from center
        let posX, posZ, distance;
        do {
            posX = (Math.random() * 40) - 20;
            posZ = (Math.random() * 40) - 20;
            distance = Math.sqrt(posX * posX + posZ * posZ);
        } while (distance < 8); // Keep trees away from spawn point
        
        tree.position.set(posX, 1, posZ); // Position with trunk base on ground
        
        // Add to scene
        scene.add(tree);
    }
}

// Handle window resize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Animation loop
function animate() {
    requestAnimationFrame(animate);
    
    // Calculate time delta for smooth movement
    const delta = clock.getDelta();
    
    // Update controls
    if (controls && typeof updateControls === 'function') {
        updateControls(controls, delta);
    }
    
    // Update the playerNumberblock position to follow the camera
    updatePlayerPosition();
    
    // Update operator system
    if (operatorManager) {
        operatorManager.update(delta);
    }
    
    // Render the scene
    renderer.render(scene, camera);
}

// Update the player's Numberblock position to follow the camera
function updatePlayerPosition() {
    if (playerNumberblock && controls) {
        // Get the controls object's position
        const controlsObject = controls.getObject();
        
        // Calculate the forward direction vector
        const camDirection = new THREE.Vector3(0, 0, -1);
        camDirection.applyQuaternion(camera.quaternion);
        
        // Position the Numberblock at the exact same position as the camera, but slightly lower
        const targetPosition = new THREE.Vector3();
        targetPosition.copy(controlsObject.position);
        
        // Fixed vertical offset to maintain strict relationship between camera and Numberblock
        const verticalOffset = 1.5;
        targetPosition.y -= verticalOffset;
        
        // Get the height of the Numberblock for ground collision
        const numberblockHeight = playerNumberblock.getHeight();
        const groundLevel = numberblockHeight / 2; // Bottom of Numberblock should be at y=0
        
        // Prevent the Numberblock from falling through the ground
        // This will also adjust the camera accordingly to maintain the relationship
        if (targetPosition.y < groundLevel) {
            targetPosition.y = groundLevel;
            // Adjust camera position to maintain the fixed relationship
            controlsObject.position.y = groundLevel + verticalOffset;
        }
        
        // Update the Numberblock's position immediately (no lerp) to stay perfectly aligned with camera
        playerNumberblock.mesh.position.copy(targetPosition);
        
        // Make the Numberblock rotate to match camera's horizontal rotation
        playerNumberblock.mesh.rotation.y = controlsObject.rotation.y;
    }
}

// Initialize the scene when the page loads
document.addEventListener('DOMContentLoaded', init);
 
 
===================================================== 
FILE: js\numberblock.js 
===================================================== 
 
// Numberblocks game - Numberblock model implementation

class Numberblock {
    constructor(value = 1, color = null) {
        this.value = value;
        this.mesh = new THREE.Group();
        this.blockSize = 1; // Size of each cube
        this.blockSpacing = 0.01; // Small gap between blocks
        this.totalHeight = 0;
        
        // Set color based on the Numberblock value, following show colors if no color specified
        if (!color) {
            this.color = this.getColorForNumber(value);
        } else {
            this.color = color;
        }
        
        this.createNumberblock();
    }
    
    // Get the standard Numberblocks color based on value
    getColorForNumber(number) {
        const colors = {
            1: 0xFF0000,   // Red (One)
            2: 0xFFA500,   // Orange (Two)
            3: 0xFFFF00,   // Yellow (Three)
            4: 0x00FF00,   // Green (Four)
            5: 0x0000FF,   // Blue (Five)
            6: 0x800080,   // Purple (Six)
            7: 0xFFC0CB,   // Pink (Seven)
            8: 0xA52A2A,   // Brown (Eight)
            9: 0x808080    // Grey (Nine)
        };
        
        // For numbers greater than 9, cycle through the colors or use white
        return colors[number % 9] || 0xFFFFFF;
    }
    
    // Create the complete Numberblock with all features
    createNumberblock() {
        this.mesh.clear(); // Clear any existing meshes
        this.totalHeight = 0;
        
        // Create the stack of blocks
        for (let i = 0; i < this.value; i++) {
            const block = this.createBlock();
            
            // Position each block on top of the previous one
            block.position.y = this.totalHeight;
            this.totalHeight += this.blockSize + this.blockSpacing;
            
            this.mesh.add(block);
            
            // Add face only to the top block
            if (i === this.value - 1) {
                const face = this.createFace();
                block.add(face);
                
                // Add number tag on top of the top block
                const numberTag = this.createNumberTag();
                numberTag.position.y = this.blockSize / 2 + 0.1; // Position just above the top block
                block.add(numberTag);
            }
        }
        
        // Add arms to the middle block or the second block from the bottom if more than 3 blocks
        const armBlockIndex = this.value <= 3 ? Math.floor(this.value / 2) : 1;
        if (this.value > 0 && armBlockIndex < this.value) {
            const leftArm = this.createArm('left');
            const rightArm = this.createArm('right');
            
            this.mesh.children[armBlockIndex].add(leftArm);
            this.mesh.children[armBlockIndex].add(rightArm);
        }
        
        // Add feet to the bottom block
        if (this.value > 0) {
            const leftFoot = this.createFoot('left');
            const rightFoot = this.createFoot('right');
            
            this.mesh.children[0].add(leftFoot);
            this.mesh.children[0].add(rightFoot);
        }
        
        // Adjust the entire Numberblock position so the bottom is at y=0
        this.mesh.position.y = 0;
    }
    
    // Get the height of the Numberblock (for physics calculations)
    getHeight() {
        // Return the total height calculated during creation
        // If value is 0, return a minimum height
        return this.value > 0 ? this.totalHeight - this.blockSpacing : this.blockSize;
    }
    
    // Create a single block with the Numberblock's color
    createBlock() {
        const geometry = new THREE.BoxGeometry(this.blockSize, this.blockSize, this.blockSize);
        const material = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        return new THREE.Mesh(geometry, material);
    }
    
    // Create a face with eyes and mouth
    createFace() {
        const face = new THREE.Group();
        
        // Eyes (white spheres with black pupils)
        const eyeSize = this.blockSize * 0.15;
        const eyeSpacing = this.blockSize * 0.3;
        const eyeHeight = this.blockSize * 0.1;
        const eyeDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        
        // Create and position left eye
        const leftEye = this.createEye(eyeSize);
        leftEye.position.set(-eyeSpacing, eyeHeight, eyeDepth);
        face.add(leftEye);
        
        // Create and position right eye
        const rightEye = this.createEye(eyeSize);
        rightEye.position.set(eyeSpacing, eyeHeight, eyeDepth);
        face.add(rightEye);
        
        // Mouth (curved line or small cylinder)
        const mouthWidth = this.blockSize * 0.4;
        const mouthHeight = this.blockSize * 0.1;
        const mouthDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        const mouthY = -eyeHeight * 2; // Position below the eyes
        
        const mouthGeometry = new THREE.CylinderGeometry(
            mouthHeight/2, mouthHeight/2, mouthWidth, 16, 1, false, 0, Math.PI
        );
        mouthGeometry.rotateZ(Math.PI / 2); // Rotate to correct orientation
        
        const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, mouthY, mouthDepth);
        face.add(mouth);
        
        return face;
    }
    
    // Create an eye (white sphere with black pupil)
    createEye(size) {
        const eye = new THREE.Group();
        
        // White part of the eye
        const eyeWhiteGeometry = new THREE.SphereGeometry(size, 16, 16);
        const eyeWhiteMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const eyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
        eye.add(eyeWhite);
        
        // Black pupil
        const pupilSize = size * 0.5;
        const pupilGeometry = new THREE.SphereGeometry(pupilSize, 16, 16);
        const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        pupil.position.z = size * 0.6; // Position the pupil slightly in front of the eye
        eye.add(pupil);
        
        return eye;
    }
    
    // Create a number tag to display on top of the Numberblock
    createNumberTag() {
        const tag = new THREE.Group();
        
        // Create a circular background for the number
        const tagRadius = this.blockSize * 0.3;
        const tagGeometry = new THREE.CylinderGeometry(tagRadius, tagRadius, 0.05, 32);
        const tagMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const tagMesh = new THREE.Mesh(tagGeometry, tagMaterial);
        tagMesh.rotation.x = Math.PI / 2; // Make it horizontal
        tag.add(tagMesh);
        
        // Create text geometry for the number
        // Note: Using a simple approach since Three.js TextGeometry requires font loading
        // In production, use Three.js TextGeometry with a loaded font
        
        // For now, we'll create a simple representation
        const numberSize = this.blockSize * 0.2;
        const numberThickness = 0.05;
        let numberMesh;
        
        // Create a simple cube for the number (in a real implementation, use TextGeometry)
        const numberGeometry = new THREE.BoxGeometry(numberSize, numberSize * 1.5, numberThickness);
        const numberMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
        
        // Position the number just above the tag background
        numberMesh.position.z = 0.03;
        tag.add(numberMesh);
        
        // Add a text object using HTML and CSS (will be updated in the render loop)
        const valueDiv = document.createElement('div');
        valueDiv.className = 'numberblock-value';
        valueDiv.innerHTML = this.value.toString();
        valueDiv.style.position = 'absolute';
        valueDiv.style.display = 'none'; // Will be positioned in render loop
        valueDiv.style.color = 'black';
        valueDiv.style.fontWeight = 'bold';
        valueDiv.style.fontSize = '24px';
        valueDiv.style.fontFamily = 'Arial, sans-serif';
        valueDiv.style.textAlign = 'center';
        valueDiv.style.userSelect = 'none';
        document.body.appendChild(valueDiv);
        
        // Store the div element for later positioning
        this.valueDiv = valueDiv;
        
        return tag;
    }
    
    // Create an arm (left or right)
    createArm(side) {
        const arm = new THREE.Group();
        
        // Arm dimensions
        const armLength = this.blockSize * 0.6;
        const armWidth = this.blockSize * 0.2;
        const armHeight = this.blockSize * 0.2;
        
        // Create the arm geometry
        const armGeometry = new THREE.BoxGeometry(armLength, armHeight, armWidth);
        const armMaterial = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        const armMesh = new THREE.Mesh(armGeometry, armMaterial);
        
        // Position the arm on the side of the block
        const xOffset = (this.blockSize / 2 + armLength / 2) * (side === 'left' ? -1 : 1);
        armMesh.position.set(xOffset, 0, 0);
        
        arm.add(armMesh);
        
        // Add a hand at the end of the arm
        const handRadius = armWidth * 0.8;
        const handGeometry = new THREE.SphereGeometry(handRadius, 16, 16);
        const handMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF, // White hands
            roughness: 0.7,
            metalness: 0.2
        });
        
        const hand = new THREE.Mesh(handGeometry, handMaterial);
        
        // Position the hand at the end of the arm
        const handX = armLength / 2 * (side === 'left' ? -1 : 1);
        hand.position.set(handX, 0, 0);
        
        armMesh.add(hand);
        
        return arm;
    }
    
    // Create a foot (left or right)
    createFoot(side) {
        const foot = new THREE.Group();
        
        // Foot dimensions
        const footLength = this.blockSize * 0.4;
        const footWidth = this.blockSize * 0.3;
        const footHeight = this.blockSize * 0.15;
        
        // Create the foot geometry
        const footGeometry = new THREE.BoxGeometry(footLength, footHeight, footWidth);
        const footMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000, // Black feet
            roughness: 0.7,
            metalness: 0.2
        });
        
        const footMesh = new THREE.Mesh(footGeometry, footMaterial);
        
        // Position the foot on the bottom of the block
        const xOffset = (this.blockSize / 4) * (side === 'left' ? -1 : 1);
        const yOffset = -this.blockSize / 2 - footHeight / 2;
        const zOffset = this.blockSize / 4; // Push feet slightly forward
        footMesh.position.set(xOffset, yOffset, zOffset);
        
        foot.add(footMesh);
        
        return foot;
    }
    
    // Update the Numberblock value and regenerate the model
    setValue(newValue) {
        if (newValue < 1) newValue = 1; // Ensure minimum value of 1
        if (newValue !== this.value) {
            this.value = newValue;
            this.color = this.getColorForNumber(newValue);
            this.createNumberblock();
        }
    }
    
    // Update the position of the HTML number tag in render loop
    updateNumberTagPosition(camera, renderer) {
        if (this.valueDiv && this.mesh.children.length > 0) {
            // Get the top block
            const topBlock = this.mesh.children[this.value - 1];
            
            // Calculate position in screen space
            const position = new THREE.Vector3();
            position.copy(topBlock.position);
            position.y += this.blockSize / 2 + 0.2; // Position above the top block
            
            // Convert 3D position to 2D screen coordinates
            const worldPos = new THREE.Vector3();
            topBlock.getWorldPosition(worldPos);
            worldPos.y += this.blockSize / 2 + 0.2;
            
            const screenPos = worldPos.clone();
            screenPos.project(camera);
            
            // Convert to CSS coordinates
            const x = (screenPos.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
            
            // Update the position of the div
            this.valueDiv.style.display = 'block';
            this.valueDiv.style.left = `${x}px`;
            this.valueDiv.style.top = `${y}px`;
            this.valueDiv.innerHTML = this.value.toString();
        }
    }
    
    // Clean up resources when no longer needed
    dispose() {
        if (this.valueDiv && this.valueDiv.parentNode) {
            this.valueDiv.parentNode.removeChild(this.valueDiv);
        }
    }
}

// Function to create a player Numberblock and add it to the scene
function createPlayerNumberblock(scene, value = 1) {
    // Create the Numberblock
    const playerBlock = new Numberblock(value);
    
    // Position it slightly above the ground
    const totalHeight = playerBlock.totalHeight;
    playerBlock.mesh.position.y = totalHeight / 2;
    
    // Add to scene
    scene.add(playerBlock.mesh);
    
    return playerBlock;
}

// Export for use in other modules
if (typeof module !== 'undefined') {
    module.exports = {
        Numberblock,
        createPlayerNumberblock
    };
} 
 
===================================================== 
FILE: js\operator.js 
===================================================== 
 
// Numberblocks game - Operator implementation

// Class to represent mathematical operators (+ and -)
class Operator {
    constructor(type, scene) {
        this.type = type; // 'plus' or 'minus'
        this.scene = scene;
        this.mesh = this.createOperatorMesh();
        
        // Add the operator to the scene
        scene.add(this.mesh);
        
        // Set the radius for collision detection
        this.collisionRadius = 0.5;
    }
    
    // Create the 3D mesh for the operator
    createOperatorMesh() {
        const operatorGroup = new THREE.Group();
        
        // Create a semi-transparent white sphere as the base
        const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const sphereMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF, // White sphere
            roughness: 0.3,
            metalness: 0.2,
            transparent: true, // Make it transparent
            opacity: 0.6 // 60% opacity
        });
        
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        operatorGroup.add(sphere);
        
        // Create the symbol geometry (+ or -) and place it in the center
        const symbolColor = 0x000000; // Black symbol
        const symbolMaterial = new THREE.MeshBasicMaterial({ color: symbolColor });
        
        if (this.type === 'plus') {
            // Create a plus sign (+) using two cylinders
            // Horizontal bar
            const horizontalGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            horizontalGeometry.rotateZ(Math.PI / 2); // Rotate to make it horizontal
            const horizontalBar = new THREE.Mesh(horizontalGeometry, symbolMaterial);
            
            // Vertical bar
            const verticalGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            const verticalBar = new THREE.Mesh(verticalGeometry, symbolMaterial);
            
            operatorGroup.add(horizontalBar);
            operatorGroup.add(verticalBar);
        } else {
            // Create a minus sign (-) using a single cylinder
            const minusGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            minusGeometry.rotateZ(Math.PI / 2); // Rotate to make it horizontal
            const minusBar = new THREE.Mesh(minusGeometry, symbolMaterial);
            
            operatorGroup.add(minusBar);
        }
        
        // Add a soft glow effect
        const glowGeometry = new THREE.SphereGeometry(0.6, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF, // White glow
            transparent: true,
            opacity: 0.2
        });
        
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        operatorGroup.add(glow);
        
        // Add rotation animation that ensures the symbol stays visible
        this.animate = (deltaTime) => {
            // Instead of rotating around Y-axis, make the operator face the camera
            if (window.camera) {
                // Get direction to camera
                const direction = new THREE.Vector3();
                direction.subVectors(window.camera.position, operatorGroup.position).normalize();
                
                // Create a temporary up vector (world up)
                const up = new THREE.Vector3(0, 1, 0);
                
                // Create a look-at matrix
                const lookMatrix = new THREE.Matrix4();
                lookMatrix.lookAt(operatorGroup.position, 
                                  operatorGroup.position.clone().add(direction), 
                                  up);
                
                // Convert to quaternion and apply
                operatorGroup.quaternion.setFromRotationMatrix(lookMatrix);
            } else {
                // Default rotation if no camera
                operatorGroup.rotation.y += deltaTime * 1.5;
            }
            
            // Add a subtle floating animation
            operatorGroup.position.y = Math.sin(Date.now() * 0.002) * 0.1 + 0.6; // Float between 0.5 and 0.7
        };
        
        return operatorGroup;
    }
    
    // Position the operator in the scene
    setPosition(x, y, z) {
        this.mesh.position.set(x, y, z);
    }
    
    // Remove the operator from the scene
    remove() {
        this.scene.remove(this.mesh);
        
        // Clean up geometries and materials to prevent memory leaks
        this.mesh.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(material => material.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
    }
    
    // Create a smaller version of the operator for holding
    createHeldOperatorMesh() {
        // Create a smaller version of the operator for holding
        const scale = 0.4; // Smaller scale for held operator
        const heldMesh = this.createOperatorMesh();
        heldMesh.scale.set(scale, scale, scale);
        
        return heldMesh;
    }
}

// Class to manage all operators in the game
class OperatorManager {
    constructor(scene) {
        this.scene = scene;
        this.operators = [];
        this.spawnTimer = 0;
        this.spawnInterval = this.getRandomSpawnInterval();
        this.maxOperators = 10; // Maximum number of operators allowed at once
        this.groundY = 0; // Y position of the ground
        this.mapSize = 40; // Size of the playable area (40x40)
        
        // Player's held operator
        this.heldOperator = null;
        this.heldOperatorMesh = null;
        
        // Debug message to check initialization
        console.log("OperatorManager initialized");
    }
    
    // Get a random spawn interval between 5-10 seconds
    getRandomSpawnInterval() {
        return 5 + Math.random() * 5; // 5-10 seconds
    }
    
    // Update function to be called in animation loop
    update(deltaTime) {
        // Update existing operators
        this.operators.forEach(operator => {
            operator.animate(deltaTime);
        });
        
        // Check if it's time to spawn a new operator
        this.spawnTimer += deltaTime;
        if (this.spawnTimer >= this.spawnInterval && this.operators.length < this.maxOperators) {
            this.spawnOperator();
            this.spawnTimer = 0;
            this.spawnInterval = this.getRandomSpawnInterval();
        }
    }
    
    // Spawn a new operator at a random position
    spawnOperator() {
        // Randomly choose between plus and minus
        const type = Math.random() > 0.5 ? 'plus' : 'minus';
        
        // Create the operator
        const operator = new Operator(type, this.scene);
        
        // Set a random position on the ground
        const posX = (Math.random() * this.mapSize) - (this.mapSize / 2);
        const posZ = (Math.random() * this.mapSize) - (this.mapSize / 2);
        
        // Set the Y position slightly above the ground to prevent z-fighting
        operator.setPosition(posX, this.groundY + 0.6, posZ);
        
        // Add to the array of active operators
        this.operators.push(operator);
        
        console.log(`Spawned ${type} operator at (${posX.toFixed(2)}, ${this.groundY + 0.6}, ${posZ.toFixed(2)})`);
        
        return operator;
    }
    
    // Remove an operator from the scene and the operators array
    removeOperator(operator) {
        const index = this.operators.indexOf(operator);
        if (index !== -1) {
            operator.remove();
            this.operators.splice(index, 1);
        }
    }
    
    // Set the currently held operator
    setHeldOperator(operator) {
        // Clear any previously held operator
        this.clearHeldOperator();
        
        // Store the operator type
        this.heldOperator = operator.type;
        
        // Create a smaller version of the operator for holding
        this.heldOperatorMesh = operator.createHeldOperatorMesh();
        
        // Add to the scene
        this.scene.add(this.heldOperatorMesh);
        
        // Remove the original operator from the scene
        this.removeOperator(operator);
        
        console.log(`Holding ${this.heldOperator} operator`);
        return this.heldOperator;
    }
    
    // Clear the currently held operator
    clearHeldOperator() {
        if (this.heldOperatorMesh) {
            this.scene.remove(this.heldOperatorMesh);
            this.heldOperatorMesh = null;
        }
        this.heldOperator = null;
    }
    
    // Get the currently held operator type
    getHeldOperator() {
        return this.heldOperator;
    }
    
    // Clear all operators
    clearAll() {
        while (this.operators.length > 0) {
            this.removeOperator(this.operators[0]);
        }
        this.clearHeldOperator();
    }
    
    // Get all operators for collision checking
    getOperators() {
        return this.operators;
    }
    
    // Attach the held operator to a Numberblock
    attachOperatorToNumberblock(numberblock) {
        if (this.heldOperatorMesh && numberblock) {
            // The numberblock will handle the positioning
            return {
                type: this.heldOperator,
                mesh: this.heldOperatorMesh
            };
        }
        return null;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined') {
    module.exports = {
        Operator,
        OperatorManager
    };
}
 
 
