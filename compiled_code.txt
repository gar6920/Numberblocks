===================================================== 
NUMBERBLOCKS GAME - COMPLETE CODE COMPILATION 
===================================================== 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\four_player_setup.html 
===================================================== 
 
<!DOCTYPE html>
<html>
<head>
    <title>3D AI Game - Multi-Player Setup</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        .container {
            width: 100vw;
            height: 100vh;
            gap: 2px;
            background-color: #000;
            display: grid;
        }
        /* 2 players: top-bottom split */
        .players-2 {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr 1fr;
        }
        /* 3 players: top left, top right, bottom left */
        .players-3 {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }
        .players-3 iframe:last-of-type {
            grid-column: 1;
            grid-row: 2;
        }
        /* 4 players: 2x2 grid */
        .players-4 {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }
        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        #implementation-display {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: Arial, sans-serif;
            z-index: 1000;
        }
    </style>
    <script>
        window.addEventListener('DOMContentLoaded', async () => {
            // Get number of players from URL parameter
            const urlParams = new URLSearchParams(window.location.search);
            const playerCount = parseInt(urlParams.get('players')) || 4;
            
            // Set container class based on player count
            const container = document.querySelector('.container');
            container.className = `container players-${playerCount}`;
            
            // Create iframes based on player count
            container.innerHTML = '';
            for (let i = 0; i < playerCount; i++) {
                const iframe = document.createElement('iframe');
                iframe.src = 'http://localhost:3000';
                container.appendChild(iframe);
            }

            // Fetch implementation info
            try {
                const response = await fetch('http://localhost:3000/api/config');
                if (response.ok) {
                    const config = await response.json();
                    document.title = `3D AI Game - ${playerCount} Players - ${config.activeImplementation}`;
                    
                    const implDisplay = document.createElement('div');
                    implDisplay.id = 'implementation-display';
                    implDisplay.textContent = `Implementation: ${config.activeImplementation}`;
                    document.body.appendChild(implDisplay);
                }
            } catch (error) {
                console.error('Failed to fetch implementation info:', error);
            }
        });
    </script>
</head>
<body>
    <div class="container">
        <!-- iframes will be added by JavaScript -->
    </div>
</body>
</html>  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\README.md 
===================================================== 
 
# 3D AI Game Platform

A modular 3D multiplayer browser-based game platform with support for various game implementations.

## Project Structure

The project follows a modular architecture with core components separated from implementation-specific code:

```
/
├── client/                 # Client-side code
│   ├── css/                # Stylesheets
│   ├── js/                 # JavaScript code
│   │   ├── core/           # Core client components
│   │   │   ├── main.js     # Main entry point
│   │   │   ├── game-engine.js # Game engine
│   │   │   ├── controls.js # Input controls
│   │   │   └── ...         # Other core modules
│   │   └── implementations/ # Implementation-specific client code
│   │       └── ...         # Various game implementations
│   └── index.html          # Main HTML file
├── server/                 # Server-side code
│   ├── core/               # Core server components
│   │   ├── server.js       # Server entry point
│   │   ├── index.js        # Core server logic
│   │   ├── BaseRoom.js     # Base room implementation
│   │   └── schemas/        # Core data schemas
│   └── implementations/    # Implementation-specific server code
│       └── ...             # Various game implementations
└── package.json            # Node.js package configuration
```

## Getting Started

1. Install dependencies:
```
npm install
```

2. Start the server:
```
npm start
```

3. Open your browser to `http://localhost:3000`

## Core vs. Implementation

The codebase separates core functionality from implementation-specific code:

- **Core** components provide the underlying game platform features.
- **Implementations** build on the core to create specific games.

To create a new implementation, see the existing examples in the implementations directory.

## Modular Design

The platform follows a modular architecture that separates core functionality from game-specific implementations. This allows for:

- **Multiple Game Implementations**: Create different games using the same platform code
- **Code Reuse**: Share common functionality across implementations
- **Clean Separation**: Keep game-specific code isolated from platform code
- **Easy Extension**: Add new implementations without modifying core code

## Current Implementations

### Numberblocks

The first implementation is a mathematical building blocks game inspired by the Numberblocks educational show. Players control Numberblock characters and interact with operators (+, -) in a fun mathematical environment.

- **Features**: Dynamic number blocks, mathematical operators, player interaction
- **Objectives**: Various game modes including target number challenges and elimination

## Tech Stack

- **Front-End**: HTML5, CSS3, JavaScript (ES6+), Three.js
- **Back-End**: Node.js, Colyseus (WebSocket-based multiplayer framework)
- **Development Tools**: Git, Nodemon

## Adding New Implementations

To create a new game implementation:

1. Create a new directory under `/client/js/implementations/`
2. Create a new directory under `/server/implementations/`
3. Extend the core Entity, Player, and NPC classes for your game implementation
4. Create implementation-specific schemas on the server
5. Register your implementation with the entity factories

See the Numberblocks implementation for an example.

## Camera Controls

- **WASD**: Move the player
- **Mouse**: Look around
- **V**: Toggle between first-person, third-person, and free roam views
- **Q/E**: Rotate player in third-person view
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\package-lock.json 
===================================================== 
 
{
  "name": "3d-ai-game-platform",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "3d-ai-game-platform",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "colyseus": "^0.16.3",
        "express": "^4.21.2"
      },
      "devDependencies": {
        "nodemon": "^3.1.9"
      }
    },
    "node_modules/@colyseus/auth": {
      "version": "0.16.4",
      "resolved": "https://registry.npmjs.org/@colyseus/auth/-/auth-0.16.4.tgz",
      "integrity": "sha512-bystav44bLieWDlmqkx+A9u8YB4/amuQIFylrBIuVdAOfLI5Dr+qLY/ng3ywOaDXvq73uYNnxcHVnvXkwSZNgA==",
      "peer": true,
      "dependencies": {
        "@types/jsonwebtoken": "^9.0.5",
        "connect-redis": "^7.1.0",
        "express-jwt": "^8.5.1",
        "express-session": "^1.17.3",
        "grant": "^5.4.24",
        "jsonwebtoken": "^9.0.0"
      },
      "engines": {
        "node": ">= 18.x"
      },
      "funding": {
        "url": "https://github.com/sponsors/endel"
      },
      "peerDependencies": {
        "@colyseus/core": "0.16.x",
        "express": "^4.17.1"
      }
    },
    "node_modules/@colyseus/clock": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/@colyseus/clock/-/clock-1.0.0.tgz",
      "integrity": "sha512-x1un5rFEgilVAA6ukSG8GFgtpX/hsmL5BtrPdxLx0dbPU7zwpTVXez2qoGza7YYS5QTvVD45gbHyX/KaaEWSZQ==",
      "peer": true
    },
    "node_modules/@colyseus/core": {
      "version": "0.16.12",
      "resolved": "https://registry.npmjs.org/@colyseus/core/-/core-0.16.12.tgz",
      "integrity": "sha512-i7tdQofhUL+5wZEKlhlnJo1mGKL6fN1rF1jO7ppRICkTp4RrbO2KH5yE8w3SnYEQf7EmlOQxCB7JxRHbZWed0Q==",
      "peer": true,
      "dependencies": {
        "@colyseus/greeting-banner": "^2.0.6",
        "@colyseus/msgpackr": "^1.11.2",
        "@colyseus/timer": "^1.0.1",
        "debug": "^4.3.4",
        "nanoid": "^2.0.0"
      },
      "engines": {
        "node": ">= 18.x"
      },
      "funding": {
        "url": "https://github.com/sponsors/endel"
      },
      "peerDependencies": {
        "@colyseus/schema": "^3.0.0"
      }
    },
    "node_modules/@colyseus/greeting-banner": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/@colyseus/greeting-banner/-/greeting-banner-2.0.6.tgz",
      "integrity": "sha512-65nK7KnJn6g3ArtJqNfVX+Mx7xTlBka04kSwloLP7s24UpCEaK7bMGRLgkzfnysARzlVh1eV4jynBWZN82dYwQ==",
      "peer": true
    },
    "node_modules/@colyseus/msgpackr": {
      "version": "1.11.2",
      "resolved": "https://registry.npmjs.org/@colyseus/msgpackr/-/msgpackr-1.11.2.tgz",
      "integrity": "sha512-MuwPFhizFKC3zmGfy0fpo+kcnZdNdnQHFVjw81v4WXHCelDeCX8yNRVtuEm8kGlHqq7qiASLC0pu0RPqYOhxXg==",
      "peer": true,
      "optionalDependencies": {
        "msgpackr-extract": "^3.0.2"
      }
    },
    "node_modules/@colyseus/redis-driver": {
      "version": "0.16.1",
      "resolved": "https://registry.npmjs.org/@colyseus/redis-driver/-/redis-driver-0.16.1.tgz",
      "integrity": "sha512-dFDyyVEBemfdeHrO2fTt86803fV8iMepGi6UHD7feR7vQO9bdN6yXpAyrBWMJrfBs8EFuEEb73gM3mDUjppH/A==",
      "peer": true,
      "dependencies": {
        "@colyseus/core": "^0.16.4",
        "ioredis": "^5.3.2"
      }
    },
    "node_modules/@colyseus/redis-presence": {
      "version": "0.16.1",
      "resolved": "https://registry.npmjs.org/@colyseus/redis-presence/-/redis-presence-0.16.1.tgz",
      "integrity": "sha512-VSY10Sv1tRk9lao56+mexHGwqXjmQMweb67rn+yWyvVZGEaSNgVN63rTZxbE9yeaCzsDlgBxSI4vXnSofpcWcg==",
      "peer": true,
      "dependencies": {
        "@colyseus/core": "^0.16.4",
        "ioredis": "^5.3.2"
      }
    },
    "node_modules/@colyseus/schema": {
      "version": "3.0.21",
      "resolved": "https://registry.npmjs.org/@colyseus/schema/-/schema-3.0.21.tgz",
      "integrity": "sha512-t2/3LKhHJfsIYhjjWgOLbuAYIRiGQF4OnXHrA7d/dypIutzWiRz7zM4qy5ONGRg2AfjJnMIz3wE/lQa6A+7lgA==",
      "peer": true,
      "bin": {
        "schema-codegen": "bin/schema-codegen",
        "schema-debug": "bin/schema-debug"
      }
    },
    "node_modules/@colyseus/timer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@colyseus/timer/-/timer-1.0.1.tgz",
      "integrity": "sha512-zsbmytTaSfqOYlnw0PXQCgwumXjn8eM/HMyMTVGjXlczsJ8DFl5OHaWAsJz7kIn92NTAONoIwLTwyVRvpJCVzA==",
      "peer": true,
      "dependencies": {
        "@colyseus/clock": "^1.0.0"
      }
    },
    "node_modules/@colyseus/uwebsockets-transport": {
      "version": "0.16.5",
      "resolved": "https://registry.npmjs.org/@colyseus/uwebsockets-transport/-/uwebsockets-transport-0.16.5.tgz",
      "integrity": "sha512-cvHmKZylOTuFpH00F02kraRK6bt0m5uUxvwtXDoVP5u7+iD/CBiX13kqp9cC0SJPl3NRNQIiQxscST8P5aSQQg==",
      "peer": true,
      "dependencies": {
        "uwebsockets-express": "^1.3.8",
        "uWebSockets.js": "github:uNetworking/uWebSockets.js#v20.51.0"
      },
      "peerDependencies": {
        "@colyseus/core": "0.16.x"
      }
    },
    "node_modules/@colyseus/ws-transport": {
      "version": "0.16.3",
      "resolved": "https://registry.npmjs.org/@colyseus/ws-transport/-/ws-transport-0.16.3.tgz",
      "integrity": "sha512-RCNghW0UM2Ql4obkju7/D94Ir4ijD+lmxTmcXCuLc4teXy+GRZEZDfeiO349jv8rdmJZSFitUvz5tub5GKM5bQ==",
      "peer": true,
      "dependencies": {
        "@types/ws": "^8.5.14",
        "ws": "^8.18.0"
      },
      "peerDependencies": {
        "@colyseus/core": "0.16.x"
      }
    },
    "node_modules/@ioredis/commands": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@ioredis/commands/-/commands-1.2.0.tgz",
      "integrity": "sha512-Sx1pU8EM64o2BrqNpEO1CNLtKQwyhuXuqyfH7oGKCk+1a33d2r5saW8zNwm3j6BTExtjrv2BxTgzzkMwts6vGg==",
      "peer": true
    },
    "node_modules/@msgpackr-extract/msgpackr-extract-darwin-arm64": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/@msgpackr-extract/msgpackr-extract-darwin-arm64/-/msgpackr-extract-darwin-arm64-3.0.3.tgz",
      "integrity": "sha512-QZHtlVgbAdy2zAqNA9Gu1UpIuI8Xvsd1v8ic6B2pZmeFnFcMWiPLfWXh7TVw4eGEZ/C9TH281KwhVoeQUKbyjw==",
      "cpu": [
        "arm64"
      ],
      "optional": true,
      "os": [
        "darwin"
      ],
      "peer": true
    },
    "node_modules/@msgpackr-extract/msgpackr-extract-darwin-x64": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/@msgpackr-extract/msgpackr-extract-darwin-x64/-/msgpackr-extract-darwin-x64-3.0.3.tgz",
      "integrity": "sha512-mdzd3AVzYKuUmiWOQ8GNhl64/IoFGol569zNRdkLReh6LRLHOXxU4U8eq0JwaD8iFHdVGqSy4IjFL4reoWCDFw==",
      "cpu": [
        "x64"
      ],
      "optional": true,
      "os": [
        "darwin"
      ],
      "peer": true
    },
    "node_modules/@msgpackr-extract/msgpackr-extract-linux-arm": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/@msgpackr-extract/msgpackr-extract-linux-arm/-/msgpackr-extract-linux-arm-3.0.3.tgz",
      "integrity": "sha512-fg0uy/dG/nZEXfYilKoRe7yALaNmHoYeIoJuJ7KJ+YyU2bvY8vPv27f7UKhGRpY6euFYqEVhxCFZgAUNQBM3nw==",
      "cpu": [
        "arm"
      ],
      "optional": true,
      "os": [
        "linux"
      ],
      "peer": true
    },
    "node_modules/@msgpackr-extract/msgpackr-extract-linux-arm64": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/@msgpackr-extract/msgpackr-extract-linux-arm64/-/msgpackr-extract-linux-arm64-3.0.3.tgz",
      "integrity": "sha512-YxQL+ax0XqBJDZiKimS2XQaf+2wDGVa1enVRGzEvLLVFeqa5kx2bWbtcSXgsxjQB7nRqqIGFIcLteF/sHeVtQg==",
      "cpu": [
        "arm64"
      ],
      "optional": true,
      "os": [
        "linux"
      ],
      "peer": true
    },
    "node_modules/@msgpackr-extract/msgpackr-extract-linux-x64": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/@msgpackr-extract/msgpackr-extract-linux-x64/-/msgpackr-extract-linux-x64-3.0.3.tgz",
      "integrity": "sha512-cvwNfbP07pKUfq1uH+S6KJ7dT9K8WOE4ZiAcsrSes+UY55E/0jLYc+vq+DO7jlmqRb5zAggExKm0H7O/CBaesg==",
      "cpu": [
        "x64"
      ],
      "optional": true,
      "os": [
        "linux"
      ],
      "peer": true
    },
    "node_modules/@msgpackr-extract/msgpackr-extract-win32-x64": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/@msgpackr-extract/msgpackr-extract-win32-x64/-/msgpackr-extract-win32-x64-3.0.3.tgz",
      "integrity": "sha512-x0fWaQtYp4E6sktbsdAqnehxDgEc/VwM7uLsRCYWaiGu0ykYdZPiS8zCWdnjHwyiumousxfBm4SO31eXqwEZhQ==",
      "cpu": [
        "x64"
      ],
      "optional": true,
      "os": [
        "win32"
      ],
      "peer": true
    },
    "node_modules/@types/jsonwebtoken": {
      "version": "9.0.9",
      "resolved": "https://registry.npmjs.org/@types/jsonwebtoken/-/jsonwebtoken-9.0.9.tgz",
      "integrity": "sha512-uoe+GxEuHbvy12OUQct2X9JenKM3qAscquYymuQN4fMWG9DBQtykrQEFcAbVACF7qaLw9BePSodUL0kquqBJpQ==",
      "peer": true,
      "dependencies": {
        "@types/ms": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/ms": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@types/ms/-/ms-2.1.0.tgz",
      "integrity": "sha512-GsCCIZDE/p3i96vtEqx+7dBUGXrc7zeSK3wwPHIaRThS+9OhWIXRqzs4d6k1SVU8g91DrNRWxWUGhp5KXQb2VA==",
      "peer": true
    },
    "node_modules/@types/node": {
      "version": "22.13.10",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.13.10.tgz",
      "integrity": "sha512-I6LPUvlRH+O6VRUqYOcMudhaIdUVWfsjnZavnsraHvpBwaEyMN29ry+0UVJhImYL16xsscu0aske3yA+uPOWfw==",
      "peer": true,
      "dependencies": {
        "undici-types": "~6.20.0"
      }
    },
    "node_modules/@types/ws": {
      "version": "8.18.0",
      "resolved": "https://registry.npmjs.org/@types/ws/-/ws-8.18.0.tgz",
      "integrity": "sha512-8svvI3hMyvN0kKCJMvTJP/x6Y/EoQbepff882wL+Sn5QsXb3etnamgrJq4isrBxSJj5L2AuXcI0+bgkoAXGUJw==",
      "peer": true,
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/array-flatten": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
      "integrity": "sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg=="
    },
    "node_modules/asn1.js": {
      "version": "5.4.1",
      "resolved": "https://registry.npmjs.org/asn1.js/-/asn1.js-5.4.1.tgz",
      "integrity": "sha512-+I//4cYPccV8LdmBLiX8CYvf9Sp3vQsrqu2QNXRcrbiWvcx/UdlFiqUJJzxRQxgsZmvhXhn4cSKeSmoFjVdupA==",
      "optional": true,
      "peer": true,
      "dependencies": {
        "bn.js": "^4.0.0",
        "inherits": "^2.0.1",
        "minimalistic-assert": "^1.0.0",
        "safer-buffer": "^2.1.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true,
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/bn.js": {
      "version": "4.12.1",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.12.1.tgz",
      "integrity": "sha512-k8TVBiPkPJT9uHLdOKfFpqcfprwBFOAAXXozRubr7R7PfIuKvQlzcI4M0pALeqXN09vdaMbUdUj+pass+uULAg==",
      "optional": true,
      "peer": true
    },
    "node_modules/body-parser": {
      "version": "1.20.3",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.3.tgz",
      "integrity": "sha512-7rAxByjUMqQ3/bHJy7D6OGXvx/MMc4IqBn/X0fcM1QUcAItpZrBEYhWGem+tzXH90c+G01ypMcYJBO9Y30203g==",
      "dependencies": {
        "bytes": "3.1.2",
        "content-type": "~1.0.5",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "on-finished": "2.4.1",
        "qs": "6.13.0",
        "raw-body": "2.5.2",
        "type-is": "~1.6.18",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/body-parser/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/body-parser/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A=="
    },
    "node_modules/brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "dev": true,
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/brorand": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/brorand/-/brorand-1.1.0.tgz",
      "integrity": "sha512-cKV8tMCEpQs4hK/ik71d6LrPOnpkpGBR0wzxqr68g2m/LB2GxVYQroAjMJZRVM1Y4BCjCKc3vAamxSzOY2RP+w==",
      "optional": true,
      "peer": true
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "peer": true
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/cluster-key-slot": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/cluster-key-slot/-/cluster-key-slot-1.1.2.tgz",
      "integrity": "sha512-RMr0FhtfXemyinomL4hrWcYJxmX6deFdCxpJzhDttxgO1+bcCnkk+9drydLVDmAMG7NE6aN/fl4F7ucU/90gAA==",
      "peer": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/colyseus": {
      "version": "0.16.3",
      "resolved": "https://registry.npmjs.org/colyseus/-/colyseus-0.16.3.tgz",
      "integrity": "sha512-CbuaASic//2fd2wFYzpUEaW+PmZrmFgIBqPXaH3f28AHn871GKk1jM5vzmFqCh3W0PMGiXpeEJZovtyziCaiBQ==",
      "engines": {
        "node": ">= 20.x"
      },
      "peerDependencies": {
        "@colyseus/auth": "0.16.x",
        "@colyseus/core": "0.16.x",
        "@colyseus/redis-driver": "0.16.x",
        "@colyseus/redis-presence": "0.16.x",
        "@colyseus/schema": "^3.0.0",
        "@colyseus/uwebsockets-transport": "0.16.x",
        "@colyseus/ws-transport": "0.16.x"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true
    },
    "node_modules/connect-redis": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/connect-redis/-/connect-redis-7.1.1.tgz",
      "integrity": "sha512-M+z7alnCJiuzKa8/1qAYdGUXHYfDnLolOGAUjOioB07pP39qxjG+X9ibsud7qUBc4jMV5Mcy3ugGv8eFcgamJQ==",
      "peer": true,
      "engines": {
        "node": ">=16"
      },
      "peerDependencies": {
        "express-session": ">=1"
      }
    },
    "node_modules/content-disposition": {
      "version": "0.5.4",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
      "integrity": "sha512-FveZTNuGw04cxlAiWbzi6zTAL/lhehaWbTtgluJh4/E95DqMwTmha3KZN1aAWA8cFIhHzMZUvLevkw5Rqk+tSQ==",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.1.tgz",
      "integrity": "sha512-6DnInpx7SJ2AK3+CTUE/ZM0vWTUboZCegxhC2xiIydHR9jNuTAASBrfEpHhiGOZw/nX51bHt6YQl8jsGo4y/0w==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ=="
    },
    "node_modules/debug": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.0.tgz",
      "integrity": "sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/denque": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/denque/-/denque-2.1.0.tgz",
      "integrity": "sha512-HVQE3AAb/pxF8fQAoiqpvg9i3evqug3hoiwakOyZAwJm+6vZehbkYXZ0l4JxS+I3QxM97v5aaRNhj8v5oBhekw==",
      "peer": true,
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/destroy": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
      "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-2.0.3.tgz",
      "integrity": "sha512-bwy0MGW55bG41VqxxypOsdSdGqLwXPI/focwgTYCFMbdUiBAxLg9CFzG08sz2aqzknwiX7Hkl0bQENjg8iLByw==",
      "optional": true,
      "peer": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "peer": true,
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow=="
    },
    "node_modules/elliptic": {
      "version": "6.6.1",
      "resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.6.1.tgz",
      "integrity": "sha512-RaddvvMatK2LJHqFJ+YA4WysVN5Ita9E35botqIYspQ4TkRAlCicdzKOjlyv/1Za5RyTNn7di//eEV0uTAfe3g==",
      "optional": true,
      "peer": true,
      "dependencies": {
        "bn.js": "^4.11.9",
        "brorand": "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        "inherits": "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow=="
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express": {
      "version": "4.21.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.21.2.tgz",
      "integrity": "sha512-28HqgMZAmih1Czt9ny7qr6ek2qddF4FclbMzwhCREB6OFfH+rXAnuNCwo1/wFvrtbgsQDb4kSbX9de9lFbrXnA==",
      "dependencies": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        "body-parser": "1.20.3",
        "content-disposition": "0.5.4",
        "content-type": "~1.0.4",
        "cookie": "0.7.1",
        "cookie-signature": "1.0.6",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "1.3.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "merge-descriptors": "1.0.3",
        "methods": "~1.1.2",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "path-to-regexp": "0.1.12",
        "proxy-addr": "~2.0.7",
        "qs": "6.13.0",
        "range-parser": "~1.2.1",
        "safe-buffer": "5.2.1",
        "send": "0.19.0",
        "serve-static": "1.16.2",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "type-is": "~1.6.18",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": {
        "node": ">= 0.10.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/express-jwt": {
      "version": "8.5.1",
      "resolved": "https://registry.npmjs.org/express-jwt/-/express-jwt-8.5.1.tgz",
      "integrity": "sha512-Dv6QjDLpR2jmdb8M6XQXiCcpEom7mK8TOqnr0/TngDKsG2DHVkO8+XnVxkJVN7BuS1I3OrGw6N8j5DaaGgkDRQ==",
      "peer": true,
      "dependencies": {
        "@types/jsonwebtoken": "^9",
        "express-unless": "^2.1.3",
        "jsonwebtoken": "^9.0.0"
      },
      "engines": {
        "node": ">= 8.0.0"
      }
    },
    "node_modules/express-session": {
      "version": "1.18.1",
      "resolved": "https://registry.npmjs.org/express-session/-/express-session-1.18.1.tgz",
      "integrity": "sha512-a5mtTqEaZvBCL9A9aqkrtfz+3SMDhOVUnjafjo+s7A9Txkq+SVX2DLvSp1Zrv4uCXa3lMSK3viWnh9Gg07PBUA==",
      "peer": true,
      "dependencies": {
        "cookie": "0.7.2",
        "cookie-signature": "1.0.7",
        "debug": "2.6.9",
        "depd": "~2.0.0",
        "on-headers": "~1.0.2",
        "parseurl": "~1.3.3",
        "safe-buffer": "5.2.1",
        "uid-safe": "~2.1.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/express-session/node_modules/cookie": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
      "peer": true,
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express-session/node_modules/cookie-signature": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.7.tgz",
      "integrity": "sha512-NXdYc3dLr47pBkpUCHtKSwIOQXLVn8dZEuywboCOJY/osA0wFSLlSawr3KN8qXJEyX66FcONTH8EIlVuK0yyFA==",
      "peer": true
    },
    "node_modules/express-session/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "peer": true,
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/express-session/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "peer": true
    },
    "node_modules/express-unless": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/express-unless/-/express-unless-2.1.3.tgz",
      "integrity": "sha512-wj4tLMyCVYuIIKHGt0FhCtIViBcwzWejX0EjNxveAa6dG+0XBCQhMbx+PnkLkFCxLC69qoFrxds4pIyL88inaQ==",
      "peer": true
    },
    "node_modules/express/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/express/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A=="
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/finalhandler": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.3.1.tgz",
      "integrity": "sha512-6BN9trH7bp3qvnrRyzsBz+g3lZxTNZTbVO2EV1CS0WIcDbawYVdYvGflME/9QP0h0pYlCDBCTjYa9nZzMDpyxQ==",
      "dependencies": {
        "debug": "2.6.9",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "statuses": "2.0.1",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/finalhandler/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/finalhandler/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A=="
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/grant": {
      "version": "5.4.24",
      "resolved": "https://registry.npmjs.org/grant/-/grant-5.4.24.tgz",
      "integrity": "sha512-PD5AvSI7wgCBDi2mEd6M/TIe+70c/fVc3Ik4B0s4mloWTy9J800eUEcxivOiyqSP9wvBy2QjWq1JR8gOfDMnEg==",
      "peer": true,
      "dependencies": {
        "qs": "^6.14.0",
        "request-compose": "^2.1.7",
        "request-oauth": "^1.0.1"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "optionalDependencies": {
        "cookie": "^0.7.2",
        "cookie-signature": "^1.2.2",
        "jwk-to-pem": "^2.0.7",
        "jws": "^4.0.0"
      }
    },
    "node_modules/grant/node_modules/cookie": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
      "optional": true,
      "peer": true,
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/grant/node_modules/cookie-signature": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz",
      "integrity": "sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==",
      "optional": true,
      "peer": true,
      "engines": {
        "node": ">=6.6.0"
      }
    },
    "node_modules/grant/node_modules/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==",
      "peer": true,
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hash.js": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/hash.js/-/hash.js-1.1.7.tgz",
      "integrity": "sha512-taOaskGt4z4SOANNseOviYDvjEJinIkRgmp7LbKP2YTTmVxWBl87s/uzK9r+44BclBSp2X7K1hqeNfz9JbBeXA==",
      "optional": true,
      "peer": true,
      "dependencies": {
        "inherits": "^2.0.3",
        "minimalistic-assert": "^1.0.1"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/hmac-drbg": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/hmac-drbg/-/hmac-drbg-1.0.1.tgz",
      "integrity": "sha512-Tti3gMqLdZfhOQY1Mzf/AanLiqh1WTiJgEj26ZuYQ9fbkLomzGchCws4FyrSd4VkpBfiNhaE1On+lOz894jvXg==",
      "optional": true,
      "peer": true,
      "dependencies": {
        "hash.js": "^1.0.3",
        "minimalistic-assert": "^1.0.0",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/http-status-codes": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/http-status-codes/-/http-status-codes-2.3.0.tgz",
      "integrity": "sha512-RJ8XvFvpPM/Dmc5SV+dC4y5PCeOhT3x1Hq0NU3rjGeg5a/CqlhZ7uudknPwZFz4aeAXDcbAyaeP7GAo9lvngtA==",
      "peer": true
    },
    "node_modules/iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ignore-by-default": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/ignore-by-default/-/ignore-by-default-1.0.1.tgz",
      "integrity": "sha512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==",
      "dev": true
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "node_modules/ioredis": {
      "version": "5.6.0",
      "resolved": "https://registry.npmjs.org/ioredis/-/ioredis-5.6.0.tgz",
      "integrity": "sha512-tBZlIIWbndeWBWCXWZiqtOF/yxf6yZX3tAlTJ7nfo5jhd6dctNxF7QnYlZLZ1a0o0pDoen7CgZqO+zjNaFbJAg==",
      "peer": true,
      "dependencies": {
        "@ioredis/commands": "^1.1.1",
        "cluster-key-slot": "^1.1.0",
        "debug": "^4.3.4",
        "denque": "^2.1.0",
        "lodash.defaults": "^4.2.0",
        "lodash.isarguments": "^3.1.0",
        "redis-errors": "^1.2.0",
        "redis-parser": "^3.0.0",
        "standard-as-callback": "^2.1.0"
      },
      "engines": {
        "node": ">=12.22.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/ioredis"
      }
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.2.tgz",
      "integrity": "sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==",
      "peer": true,
      "dependencies": {
        "jws": "^3.2.2",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jsonwebtoken/node_modules/jwa": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-1.4.1.tgz",
      "integrity": "sha512-qiLX/xhEEFKUAJ6FiBMbes3w9ATzyk5W7Hvzpa/SLYdxNtng+gcurvrI7TbACjIXlsJyr05/S1oUhZrc63evQA==",
      "peer": true,
      "dependencies": {
        "buffer-equal-constant-time": "1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jsonwebtoken/node_modules/jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "peer": true,
      "dependencies": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jwa": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-2.0.0.tgz",
      "integrity": "sha512-jrZ2Qx916EA+fq9cEAeCROWPTfCwi1IVHqT2tapuqLEVVDKFDENFw1oL+MwrTvH6msKxsd1YTDVw6uKEcsrLEA==",
      "optional": true,
      "peer": true,
      "dependencies": {
        "buffer-equal-constant-time": "1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jwk-to-pem": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/jwk-to-pem/-/jwk-to-pem-2.0.7.tgz",
      "integrity": "sha512-cSVphrmWr6reVchuKQZdfSs4U9c5Y4hwZggPoz6cbVnTpAVgGRpEuQng86IyqLeGZlhTh+c4MAreB6KbdQDKHQ==",
      "optional": true,
      "peer": true,
      "dependencies": {
        "asn1.js": "^5.3.0",
        "elliptic": "^6.6.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/jws/-/jws-4.0.0.tgz",
      "integrity": "sha512-KDncfTmOZoOMTFG4mBlG0qUIOlc03fmzH+ru6RgYVZhPkyiy/92Owlt/8UEN+a4TXR1FQetfIpJE8ApdvdVxTg==",
      "optional": true,
      "peer": true,
      "dependencies": {
        "jwa": "^2.0.0",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/lodash.defaults": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/lodash.defaults/-/lodash.defaults-4.2.0.tgz",
      "integrity": "sha512-qjxPLHd3r5DnsdGacqOMU6pb/avJzdh9tFX2ymgoZE27BmjXrNy/y4LoaiTeAb+O3gL8AfpJGtqfX/ae2leYYQ==",
      "peer": true
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==",
      "peer": true
    },
    "node_modules/lodash.isarguments": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/lodash.isarguments/-/lodash.isarguments-3.1.0.tgz",
      "integrity": "sha512-chi4NHZlZqZD18a0imDHnZPrDeBbTtVN7GXMwuGdRH9qotxAjYs3aVLKc7zNOG9eddR5Ksd8rvFEBc9SsggPpg==",
      "peer": true
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==",
      "peer": true
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==",
      "peer": true
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==",
      "peer": true
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "peer": true
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==",
      "peer": true
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==",
      "peer": true
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.3.tgz",
      "integrity": "sha512-gaNvAS7TZ897/rVaZ0nMtAyxNyi/pdbjbAwUpFQpN70GqnVfOiXpeUUMKRBmzXaSQ8DdTX4/0ms62r2K+hE6mQ==",
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
      "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimalistic-assert": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-assert/-/minimalistic-assert-1.0.1.tgz",
      "integrity": "sha512-UtJcAD4yEaGtjPezWuO9wC4nwUnVH/8/Im3yEHQP4b67cXlD/Qr9hdITCU1xDbSEXg2XKNaP8jsReV7vQd00/A==",
      "optional": true,
      "peer": true
    },
    "node_modules/minimalistic-crypto-utils": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-crypto-utils/-/minimalistic-crypto-utils-1.0.1.tgz",
      "integrity": "sha512-JIYlbt6g8i5jKfJ3xz7rF0LXmv2TkDxBLUkiBeZ7bAx4GnnNMr8xFpGnOxn6GhTEHx3SjRrZEoU+j04prX1ktg==",
      "optional": true,
      "peer": true
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
    },
    "node_modules/msgpackr-extract": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/msgpackr-extract/-/msgpackr-extract-3.0.3.tgz",
      "integrity": "sha512-P0efT1C9jIdVRefqjzOQ9Xml57zpOXnIuS+csaB4MdZbTdmGDLo8XhzBG1N7aO11gKDDkJvBLULeFTo46wwreA==",
      "hasInstallScript": true,
      "optional": true,
      "peer": true,
      "dependencies": {
        "node-gyp-build-optional-packages": "5.2.2"
      },
      "bin": {
        "download-msgpackr-prebuilds": "bin/download-prebuilds.js"
      },
      "optionalDependencies": {
        "@msgpackr-extract/msgpackr-extract-darwin-arm64": "3.0.3",
        "@msgpackr-extract/msgpackr-extract-darwin-x64": "3.0.3",
        "@msgpackr-extract/msgpackr-extract-linux-arm": "3.0.3",
        "@msgpackr-extract/msgpackr-extract-linux-arm64": "3.0.3",
        "@msgpackr-extract/msgpackr-extract-linux-x64": "3.0.3",
        "@msgpackr-extract/msgpackr-extract-win32-x64": "3.0.3"
      }
    },
    "node_modules/nanoid": {
      "version": "2.1.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-2.1.11.tgz",
      "integrity": "sha512-s/snB+WGm6uwi0WjsZdaVcuf3KJXlfGl2LcxgwkEwJF0D/BWzVWAZW/XY4bFaiR7s0Jk3FPvlnepg1H1b1UwlA==",
      "peer": true
    },
    "node_modules/negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/node-gyp-build-optional-packages": {
      "version": "5.2.2",
      "resolved": "https://registry.npmjs.org/node-gyp-build-optional-packages/-/node-gyp-build-optional-packages-5.2.2.tgz",
      "integrity": "sha512-s+w+rBWnpTMwSFbaE0UXsRlg7hU4FjekKU4eyAih5T8nJuNZT1nNsskXpxmeqSK9UzkBl6UgRlnKc8hz8IEqOw==",
      "optional": true,
      "peer": true,
      "dependencies": {
        "detect-libc": "^2.0.1"
      },
      "bin": {
        "node-gyp-build-optional-packages": "bin.js",
        "node-gyp-build-optional-packages-optional": "optional.js",
        "node-gyp-build-optional-packages-test": "build-test.js"
      }
    },
    "node_modules/nodemon": {
      "version": "3.1.9",
      "resolved": "https://registry.npmjs.org/nodemon/-/nodemon-3.1.9.tgz",
      "integrity": "sha512-hdr1oIb2p6ZSxu3PB2JWWYS7ZQ0qvaZsc3hK8DR8f02kRzc8rjYmxAIvdz+aYC+8F2IjNaB7HMcSDg8nQpJxyg==",
      "dev": true,
      "dependencies": {
        "chokidar": "^3.5.2",
        "debug": "^4",
        "ignore-by-default": "^1.0.1",
        "minimatch": "^3.1.2",
        "pstree.remy": "^1.1.8",
        "semver": "^7.5.3",
        "simple-update-notifier": "^2.0.0",
        "supports-color": "^5.5.0",
        "touch": "^3.1.0",
        "undefsafe": "^2.0.5"
      },
      "bin": {
        "nodemon": "bin/nodemon.js"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nodemon"
      }
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/oauth-sign": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/oauth-sign/-/oauth-sign-0.9.0.tgz",
      "integrity": "sha512-fexhUFFPTGV8ybAtSIGbV6gOkSv8UtRbDBnAyLQw4QPKkgNlsH2ByPGtMUqdWkos6YCRmAqViwgZrJc/mRDzZQ==",
      "peer": true,
      "engines": {
        "node": "*"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/on-headers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/on-headers/-/on-headers-1.0.2.tgz",
      "integrity": "sha512-pZAE+FJLoyITytdqK0U5s+FIpjN0JP3OzFi/u8Rx+EV5/W+JTWGXG8xFzevE7AjBfDqHv/8vL8qQsIhHnqRkrA==",
      "peer": true,
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "0.1.12",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
      "integrity": "sha512-RA1GjUVMnvYFxuqovrEqZoxxW5NUZqbwKtYz/Tt7nXerk0LbLblQmrsgdeOxV5SFHf0UDggjS/bSeOZwt1pmEQ=="
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/pstree.remy": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/pstree.remy/-/pstree.remy-1.1.8.tgz",
      "integrity": "sha512-77DZwxQmxKnu3aR542U+X8FypNzbfJ+C5XQDk3uWjWxn6151aIMGthWYRXTqT1E5oJvg+ljaa2OJi+VfvCOQ8w==",
      "dev": true
    },
    "node_modules/qs": {
      "version": "6.13.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.13.0.tgz",
      "integrity": "sha512-+38qI9SOr8tfZ4QmJNplMUxqjbe7LKvvZgWdExBOmd+egZTtjLB67Gu0HRX3u/XOq7UU2Nx6nsjvS16Z9uwfpg==",
      "dependencies": {
        "side-channel": "^1.0.6"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/random-bytes": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/random-bytes/-/random-bytes-1.0.0.tgz",
      "integrity": "sha512-iv7LhNVO047HzYR3InF6pUcUsPQiHTM1Qal51DcGSuZFBil1aBBWG5eHPNek7bvILMaYJ/8RU1e8w1AMdHmLQQ==",
      "peer": true,
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "2.5.2",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.2.tgz",
      "integrity": "sha512-8zGqypfENjCIqGhgXToC8aB2r7YrBX+AQAfIPs/Mlk+BtPTztOvTS01NRW/3Eh60J+a48lt8qsCzirQ6loCVfA==",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/redis-errors": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/redis-errors/-/redis-errors-1.2.0.tgz",
      "integrity": "sha512-1qny3OExCf0UvUV/5wpYKf2YwPcOqXzkwKKSmKHiE6ZMQs5heeE/c8eXK+PNllPvmjgAbfnsbpkGZWy8cBpn9w==",
      "peer": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/redis-parser": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/redis-parser/-/redis-parser-3.0.0.tgz",
      "integrity": "sha512-DJnGAeenTdpMEH6uAJRK/uiyEIH9WVsUmoLwzudwGJUwZPp80PDBWPHXSAGNPwNvIXAbe7MSUB1zQFugFml66A==",
      "peer": true,
      "dependencies": {
        "redis-errors": "^1.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/request-compose": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/request-compose/-/request-compose-2.1.7.tgz",
      "integrity": "sha512-27amNkWTK4Qq25XEwdmrhb4VLMiQzRSKuDfsy1o1griykcyXk5MxMHmJG+OKTRdO9PgsO7Kkn7GrEkq0UAIIMQ==",
      "peer": true,
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/request-oauth": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/request-oauth/-/request-oauth-1.0.1.tgz",
      "integrity": "sha512-85THTg1RgOYtqQw42JON6AqvHLptlj1biw265Tsq4fD4cPdUvhDB2Qh9NTv17yCD322ROuO9aOmpc4GyayGVBA==",
      "peer": true,
      "dependencies": {
        "oauth-sign": "^0.9.0",
        "qs": "^6.9.6",
        "uuid": "^8.3.2"
      },
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "node_modules/semver": {
      "version": "7.7.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.1.tgz",
      "integrity": "sha512-hlq8tAfn0m/61p4BVRcPzIGr6LKiMwo4VM6dGi6pt4qcRkmNzTcWq6eCEjEh+qXjkMDvPlOFFSGwQjoEa6gyMA==",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/send": {
      "version": "0.19.0",
      "resolved": "https://registry.npmjs.org/send/-/send-0.19.0.tgz",
      "integrity": "sha512-dW41u5VfLXu8SJh5bwRmyYUbAoSB3c9uQh6L8h/KtsFREPWpbX1lrljJo186Jc4nmci/sGUZ9a0a0J2zgfq2hw==",
      "dependencies": {
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "mime": "1.6.0",
        "ms": "2.1.3",
        "on-finished": "2.4.1",
        "range-parser": "~1.2.1",
        "statuses": "2.0.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/send/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/send/node_modules/debug/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A=="
    },
    "node_modules/send/node_modules/encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/serve-static": {
      "version": "1.16.2",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.16.2.tgz",
      "integrity": "sha512-VqpjJZKadQB/PEbEwvFdO43Ax5dFBZ2UECszz8bQ7pi7wt//PWe1P6MN7eCnjsatYtBT6EuiClbjSWP2WrIoTw==",
      "dependencies": {
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.3",
        "send": "0.19.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/simple-update-notifier": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/simple-update-notifier/-/simple-update-notifier-2.0.0.tgz",
      "integrity": "sha512-a2B9Y0KlNXl9u/vsW6sTIu9vGEpfKu2wRV6l1H3XEas/0gUIzGzBoP/IouTcUQbm9JWZLH3COxyn03TYlFax6w==",
      "dev": true,
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/standard-as-callback": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/standard-as-callback/-/standard-as-callback-2.1.0.tgz",
      "integrity": "sha512-qoRRSyROncaz1z0mvYqIE4lCd9p2R90i6GxW3uZv5ucSu8tU7B5HXUP1gG8pVZsYNVaXjk8ClXHPttLyxAL48A==",
      "peer": true
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "dev": true,
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/touch": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/touch/-/touch-3.1.1.tgz",
      "integrity": "sha512-r0eojU4bI8MnHr8c5bNo7lJDdI2qXlWWJk6a9EAFG7vbhTjElYhBVS3/miuE0uOuoLdb8Mc/rVfsmm6eo5o9GA==",
      "dev": true,
      "bin": {
        "nodetouch": "bin/nodetouch.js"
      }
    },
    "node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/uid-safe": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/uid-safe/-/uid-safe-2.1.5.tgz",
      "integrity": "sha512-KPHm4VL5dDXKz01UuEd88Df+KzynaohSL9fBh096KWAxSKZQDI2uBrVqtvRM4rwrIrRRKsdLNML/lnaaVSRioA==",
      "peer": true,
      "dependencies": {
        "random-bytes": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/undefsafe": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/undefsafe/-/undefsafe-2.0.5.tgz",
      "integrity": "sha512-WxONCrssBM8TSPRqN5EmsjVrsv4A8X12J4ArBiiayv3DyyG3ZlIg6yysuuSYdZsVz3TKcTg2fd//Ujd4CHV1iA==",
      "dev": true
    },
    "node_modules/undici-types": {
      "version": "6.20.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.20.0.tgz",
      "integrity": "sha512-Ny6QZ2Nju20vw1SRHe3d9jVu6gJ+4e3+MMpqu7pqE5HT6WsTSlce++GQmK5UXS8mzV8DSYHrQH+Xrf2jVcuKNg==",
      "peer": true
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/uuid": {
      "version": "8.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz",
      "integrity": "sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==",
      "peer": true,
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/uwebsockets-express": {
      "version": "1.3.13",
      "resolved": "https://registry.npmjs.org/uwebsockets-express/-/uwebsockets-express-1.3.13.tgz",
      "integrity": "sha512-EGv0q/D5KhV/V6CjlUalWfzKrcTihLPyQjnImR3hngviWg/UHtKX+SOI0+5lOLr+QjjfOHrKwc1jkXedAtMOmw==",
      "peer": true,
      "dependencies": {
        "express": "^4.18.1",
        "http-status-codes": "^2.1.4",
        "mime": "^2.5.2",
        "path-to-regexp": "^0.1.7"
      }
    },
    "node_modules/uwebsockets-express/node_modules/mime": {
      "version": "2.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-2.6.0.tgz",
      "integrity": "sha512-USPkMeET31rOMiarsBNIHZKLGgvKc/LrjofAnBlOttf5ajRvqiRA8QsenbcooctK6d6Ts6aqZXBA+XbkKthiQg==",
      "peer": true,
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/uWebSockets.js": {
      "version": "20.51.0",
      "resolved": "git+ssh://git@github.com/uNetworking/uWebSockets.js.git#6609a88ffa9a16ac5158046761356ce03250a0df",
      "license": "Apache-2.0",
      "peer": true
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/ws": {
      "version": "8.18.1",
      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.1.tgz",
      "integrity": "sha512-RKW2aJZMXeMxVpnZ6bck+RswznaxmzdULiBr6KY7XkTnW8uvt0iT9H5DkHUChXrc+uurzwa0rVI16n/Xzjdz1w==",
      "peer": true,
      "engines": {
        "node": ">=10.0.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": ">=5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    }
  }
}
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\package.json 
===================================================== 
 
{
  "name": "3d-ai-game-platform",
  "version": "1.0.0",
  "description": "A modular 3D multiplayer browser-based game platform with support for various game implementations. The first implementation is Numberblocks, a mathematical building blocks game.",
  "main": "server/core/server.js",
  "scripts": {
    "start": "node server/core/server.js",
    "dev": "nodemon server/core/server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "3d",
    "game",
    "platform",
    "multiplayer",
    "modular",
    "numberblocks",
    "threejs",
    "colyseus"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "colyseus": "^0.16.3",
    "express": "^4.21.2"
  },
  "devDependencies": {
    "nodemon": "^3.1.9"
  }
}
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\open_4player_direct.bat 
===================================================== 
 
@echo off
echo Opening 3D AI Game - Single Window 4-Player Setup

REM Check if Chrome exists in both possible locations
set "CHROME_PATH=C:\Program Files\Google\Chrome\Application\chrome.exe"
if not exist "%CHROME_PATH%" (
    set "CHROME_PATH=C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"
)

if not exist "%CHROME_PATH%" (
    echo ERROR: Could not find Chrome browser.
    echo Please make sure Chrome is installed or update this script with the correct path.
    pause
    exit /b 1
)

REM Get the full path to the four_player_setup.html file
set "SETUP_FILE=%~dp0four_player_setup.html"

echo Opening 4-player game window...
start "" "%CHROME_PATH%" --app="file:///%SETUP_FILE:\=/%"

echo.
echo Setup complete!
echo Press F11 in the browser for fullscreen mode.
echo.
echo Make sure your game server is running at http://localhost:3000  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\start_game.bat 
===================================================== 
 
@echo off
setlocal enabledelayedexpansion

REM Kill any existing Node.js processes
echo Killing any existing Node.js processes...
taskkill /F /IM node.exe 2>nul
timeout /t 2 /nobreak >nul

REM Start the server and capture its output
echo Starting server...
start "3D AI Game Server" /B cmd /c "start_server.bat > server_output.tmp 2>&1"

REM Wait for server to initialize and show implementation selection
timeout /t 2 /nobreak >nul

:IMPLEMENTATION_SELECT
cls
echo ===== 3D AI Game Platform =====
echo Available implementations:
echo 1. default
echo 2. numberblocks
echo.
set /p IMPL_CHOICE="Select implementation (1-2): "

REM Send implementation choice
if !IMPL_CHOICE!==1 (
    echo 1
) else if !IMPL_CHOICE!==2 (
    echo 2
) else (
    goto IMPLEMENTATION_SELECT
)

REM Wait for implementation to be set
timeout /t 3 /nobreak >nul

:PLAYER_COUNT
cls
echo Choose number of players (1-4):
echo 1 - Single player (fullscreen)
echo 2 - Two players (split screen)
echo 3 - Three players
echo 4 - Four players
echo.
set /p PLAYER_COUNT="Enter number of players (1-4): "

REM Validate input
if !PLAYER_COUNT! LSS 1 goto PLAYER_COUNT
if !PLAYER_COUNT! GTR 4 goto PLAYER_COUNT

REM Check if Chrome exists in both possible locations
set "CHROME_PATH=C:\Program Files\Google\Chrome\Application\chrome.exe"
if not exist "%CHROME_PATH%" (
    set "CHROME_PATH=C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"
)

if not exist "%CHROME_PATH%" (
    echo ERROR: Could not find Chrome browser.
    echo Please make sure Chrome is installed or update this script with the correct path.
    pause
    exit /b 1
)

REM Get the full path to the HTML files
set "SETUP_FILE=%~dp0four_player_setup.html"
set "SINGLE_FILE=%~dp0client/index.html"

REM Launch appropriate number of clients
if !PLAYER_COUNT!==1 (
    echo Opening single player mode...
    start "" "%CHROME_PATH%" --app="file:///%SINGLE_FILE:\=/%"
) else (
    echo Opening !PLAYER_COUNT!-player setup...
    start "" "%CHROME_PATH%" --app="file:///%SETUP_FILE:\=/%?players=!PLAYER_COUNT!"
)

echo.
echo Game launched! 
echo Press F11 in the browser for fullscreen mode.
echo.
echo Server is running at http://localhost:3000
echo To quit, close all windows and press Ctrl+C in the server window.

REM Clean up temporary file
if exist server_output.tmp del server_output.tmp

pause  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\start_server.bat 
===================================================== 
 
@echo off
echo Starting 3D AI Game Server

REM Kill any existing Node.js processes
taskkill /F /IM node.exe >nul 2>&1

REM Start the game server
cd /d "%~dp0server"
echo Server starting - press Ctrl+C to stop
npm start  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\update_compiled_code.bat 
===================================================== 
 
@echo off
setlocal enabledelayedexpansion

echo Creating updated compiled_code.txt file...

:: Delete the old file if it exists
if exist compiled_code.txt del compiled_code.txt

:: Create the new file with a header
echo ===================================================== > compiled_code.txt
echo NUMBERBLOCKS GAME - COMPLETE CODE COMPILATION >> compiled_code.txt
echo ===================================================== >> compiled_code.txt
echo. >> compiled_code.txt

set /a totalFiles=0

:: Process all text files recursively
for /R %%F in (*.js, *.html, *.css, *.md, *.json, *.bat, *.txt) do (
    set "filePath=%%F"
    set "fileName=%%~nxF"
    
    :: Skip compiled_code.txt and node_modules
    echo !filePath! | findstr /i /c:"compiled_code.txt" /c:"node_modules" /c:"\.git\" > nul
    if errorlevel 1 (
        echo Processing !filePath!...
        echo ===================================================== >> compiled_code.txt
        echo FILE: !filePath! >> compiled_code.txt
        echo ===================================================== >> compiled_code.txt
        echo. >> compiled_code.txt
        type "!filePath!" >> compiled_code.txt
        echo. >> compiled_code.txt
        echo. >> compiled_code.txt
        set /a totalFiles=totalFiles+1
    )
)

echo.
echo Compilation complete! Processed !totalFiles! files.
echo The updated compiled_code.txt file now contains all code from the project.
echo.

pause
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\index.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D AI Game Platform</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #lock-instructions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            text-align: center;
            cursor: pointer;
            z-index: 10;
        }
        #player-list-container {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 5px;
            width: 200px;
            max-height: 300px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            z-index: 100;
        }
        #player-list-header {
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.5);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #player-list {
            margin-top: 5px;
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            transition: height 0.3s ease;
        }
        .player-entry {
            padding: 3px;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            font-size: 11px;
            background-color: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        .player-color {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
            flex-shrink: 0;
        }
        .player-info {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #collapse-icon {
            transition: transform 0.3s ease;
        }
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            font-family: Arial, sans-serif;
        }
        #loading-status {
            margin-top: 20px;
            font-size: 16px;
        }
        .spinner {
            border: 5px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 5px solid white;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <script>
        // Fetch the current implementation information and update the page title
        window.addEventListener('DOMContentLoaded', async () => {
            try {
                const response = await fetch('/api/config');
                if (response.ok) {
                    const config = await response.json();
                    // Update the page title with the active implementation
                    document.title = `3D AI Game - ${config.activeImplementation}`;
                    
                    // Also add a small indicator in the corner
                    const implIndicator = document.createElement('div');
                    implIndicator.style.position = 'absolute';
                    implIndicator.style.top = '5px';
                    implIndicator.style.right = '10px';
                    implIndicator.style.background = 'rgba(0,0,0,0.5)';
                    implIndicator.style.color = 'white';
                    implIndicator.style.padding = '5px 10px';
                    implIndicator.style.borderRadius = '3px';
                    implIndicator.style.fontSize = '12px';
                    implIndicator.style.zIndex = '1000';
                    implIndicator.textContent = `Implementation: ${config.activeImplementation}`;
                    document.body.appendChild(implIndicator);
                }
            } catch (error) {
                console.error('Failed to fetch implementation info:', error);
            }
        });
    </script>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    
    <div id="lock-instructions">
        Click to play<br>
        WASD to move, Mouse to look<br>
        V to toggle camera views<br>
        Right-click + Mouse to orbit in third-person view
    </div>
    
    <!-- Multiplayer panel - Players List -->
    <div id="player-list-container">
        <div id="player-list-header">
            <span id="collapse-icon">▼</span> Players <span id="player-count">(0)</span>
        </div>
        <div id="player-list"></div>
    </div>
    
    <!-- Game HUD -->
    <div id="game-hud"></div>
    
    <!-- Loading Screen -->
    <div id="loading-screen">
        <h2>3D Game Platform</h2>
        <div class="spinner"></div>
        <div id="loading-status">Loading game engine...</div>
        <div style="margin-top: 10px; font-size: 14px;">Connecting to server...</div>
    </div>
    
    <!-- Three.js library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/renderers/CSS2DRenderer.js"></script>
    
    <!-- Colyseus client library -->
    <script src="https://unpkg.com/colyseus.js@^0.16.3/dist/colyseus.js"></script>
    
    <!-- Main loader script -->
    <script src="js/core/main.js"></script>
</body>
</html>
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\css\styles.css 
===================================================== 
 
/* Reset default margins and padding */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
}

body, html {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background-color: #000;
}

/* Make the canvas fill the entire screen */
#game-canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* Fix for horizontal bar issue - ensuring no elements create unwanted artifacts */
canvas {
    position: fixed;
    top: 0;
    left: 0;
    outline: none;
}

/* Controls info overlay */
.overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    z-index: 100;
}

.overlay h2 {
    margin-bottom: 10px;
}

.overlay p {
    margin-bottom: 15px;
}

.overlay ul {
    list-style-type: none;
    text-align: left;
    margin: 0 auto;
    display: inline-block;
}

.overlay ul li {
    margin-bottom: 5px;
}

/* Game HUD */
.hud {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 10;
    color: white;
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.8);
    background-color: rgba(0, 0, 0, 0.5);
    padding: 10px 15px;
    border-radius: 8px;
    pointer-events: none; /* Allow clicking through the HUD */
}

#player-number-display {
    display: flex;
    align-items: center;
    justify-content: flex-end;
}

#player-value {
    margin-left: 5px;
    font-size: 32px;
}

/* Ensure no overflow elements */
body, html, canvas {
    overflow: hidden;
}
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\main.js 
===================================================== 
 
// 3D Game Platform - Main Entry Point

// Game configuration
const gameConfig = {
    debug: false,                 // Debug mode
    sceneSettings: {
        groundSize: 100,          // Size of the ground plane
        skyColor: 0x87CEEB,       // Sky color
        groundColor: 0x228B22     // Ground color
    },
    playerSettings: {
        startPosition: {
            x: 0,
            y: 1,
            z: 0
        },
        viewMode: 'firstPerson'   // 'firstPerson', 'thirdPerson', or 'freeRoam'
    },
    networkSettings: {
        serverUrl: window.location.hostname.includes('localhost') 
            ? `ws://${window.location.hostname}:3000` // Local development
            : `wss://${window.location.hostname}`,    // Production
        roomName: 'default'       // Default room name
    }
};

// Store config globally for access by other modules
window.gameConfig = gameConfig;

// Main game initialization
function initGame() {
    console.log('Initializing 3D Game Platform...');
    
    // Load core modules
    loadCoreModules()
        .then(() => {
            // Initialize the game engine
            initGameEngine();
        })
        .catch(error => {
            console.error('Error initializing game:', error);
        });
}

// Load core platform modules
function loadCoreModules() {
    return new Promise((resolve, reject) => {
        try {
            console.log('Loading core modules...');
            
            // Create core module paths
            const corePath = 'js/core/';
            const coreModules = [
                'Entity.js',
                'Player.js',
                'NPC.js',
                'EntityFactory.js',
                'collision.js',
                'player-ui.js',
                'network-core.js',
                'controls.js'
            ];
            
            // Load each module in sequence
            let loadPromise = Promise.resolve();
            
            coreModules.forEach(module => {
                loadPromise = loadPromise.then(() => {
                    return loadScript(corePath + module);
                });
            });
            
            // Resolve when all core modules are loaded
            loadPromise.then(() => {
                console.log('Core modules loaded successfully');
                resolve();
            }).catch(error => {
                reject(error);
            });
        } catch (error) {
            reject(error);
        }
    });
}

// Initialize the main game engine
function initGameEngine() {
    console.log('Initializing game engine...');
    
    // Initialize default player factory first
    window.createPlayerEntity = function(scene, value = 1) {
        // Create a simple player with a box
        const player = new window.Player({
            id: 'player',
            isLocalPlayer: true,
            color: 0xFFFF00
        });
        
        if (scene && player.mesh) {
            scene.add(player.mesh);
        }
        
        return player;
    };
    
    // Load default implementation
    loadScript('js/implementations/default/DefaultPlayer.js')
        .then(() => {
            // Load the game engine
            return loadScript('js/core/game-engine.js');
        })
        .then(() => {
            console.log('Game engine loaded');
            // Remove the loading screen once everything is loaded
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
            
            // Set isFirstPerson based on viewMode
            window.isFirstPerson = gameConfig.playerSettings.viewMode === 'firstPerson';
            window.viewMode = gameConfig.playerSettings.viewMode;
        })
        .catch(error => {
            console.error('Error loading game engine:', error);
        });
}

// Helper function to load a script asynchronously
function loadScript(src) {
    return new Promise((resolve, reject) => {
        // Check if this script has already been loaded
        if (document.querySelector(`script[src="${src}"]`)) {
            console.log(`Script already loaded: ${src}`);
            resolve();
            return;
        }
        
        const script = document.createElement('script');
        script.src = src;
        script.onload = () => resolve();
        script.onerror = (error) => reject(new Error(`Failed to load script: ${src}`));
        document.head.appendChild(script);
    });
}

// Start the game when the document is ready
document.addEventListener('DOMContentLoaded', initGame);  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\core\collision.js 
===================================================== 
 
/**
 * 3D AI Game Platform - AABB Collision System
 * Uses Axis-Aligned Bounding Boxes for efficient collision detection
 */

class CollisionSystem {
    constructor() {
        // Collection of collidable objects
        this.collidableObjects = [];
        this.debugMode = false; // Set to true to see debug logging
    }

    // Initialize collision system and collect collidable objects from the scene
    init(scene) {
        console.log("Initializing collision system...");
        this.collidableObjects = [];
        
        // Traverse the scene to find all collidable objects
        scene.traverse((object) => {
            if (object.isMesh && object.userData && object.userData.collidable === true) {
                this.collidableObjects.push(object);
                if (this.debugMode) console.log(`Added collidable object: ${object.name || 'unnamed object'}`);
            }
        });
        
        console.log(`Collision system initialized with ${this.collidableObjects.length} collidable objects`);
        return this.collidableObjects.length;
    }

    // Add a single object to the collidable objects list
    addCollidableObject(object) {
        if (!object || !(object.isMesh || object.isGroup)) return;
        
        // Mark the object as collidable
        object.userData = object.userData || {};
        object.userData.collidable = true;
        
        // Add a name if it doesn't have one for easier debugging
        if (!object.name) {
            object.name = `collidable_${this.collidableObjects.length}`;
        }
        
        // Only add if not already in the list
        if (!this.collidableObjects.includes(object)) {
            this.collidableObjects.push(object);
            if (this.debugMode) console.log(`Added collidable object: ${object.name}`);
            
            // If it's a group, also make all children collidable
            if (object.isGroup && object.children) {
                object.children.forEach(child => {
                    if (child.isMesh) {
                        child.userData = child.userData || {};
                        child.userData.collidable = true;
                        this.collidableObjects.push(child);
                        if (this.debugMode) console.log(`Added child collidable object: ${child.name || 'unnamed child'}`);
                    }
                });
            }
        }
    }

    // Create or update a bounding box for a mesh
    updateAABB(mesh) {
        if (!mesh) return null;
        
        // Use Three.js Box3 to create a bounding box from the mesh
        const box = new THREE.Box3().setFromObject(mesh);
        return box;
    }

    // Check if two bounding boxes intersect
    checkCollision(boxA, boxB) {
        if (!boxA || !boxB) return false;
        return boxA.intersectsBox(boxB);
    }

    // Get the minimum translation vector to resolve a collision
    getCollisionResponse(boxA, boxB) {
        // Create a box that represents the intersection
        const intersection = new THREE.Box3();
        intersection.copy(boxA).intersect(boxB);
        
        // Get the size of the intersection
        const size = intersection.getSize(new THREE.Vector3());
        
        // Find the minimum penetration axis (x, y, or z)
        let axis, minSize;
        
        if (size.x <= size.y && size.x <= size.z) {
            axis = 'x';
            minSize = size.x;
        } else if (size.y <= size.x && size.y <= size.z) {
            axis = 'y';
            minSize = size.y;
        } else {
            axis = 'z';
            minSize = size.z;
        }
        
        // Return the direction and amount to move
        const response = {
            axis: axis,
            depth: minSize,
            direction: new THREE.Vector3()
        };
        
        // Calculate the direction to move (away from the obstacle)
        const centerA = boxA.getCenter(new THREE.Vector3());
        const centerB = boxB.getCenter(new THREE.Vector3());
        
        if (axis === 'x') {
            response.direction.x = centerA.x < centerB.x ? -1 : 1;
        } else if (axis === 'y') {
            response.direction.y = centerA.y < centerB.y ? -1 : 1;
        } else {
            response.direction.z = centerA.z < centerB.z ? -1 : 1;
        }
        
        return response;
    }

    // Check collisions for the player against all collidable objects
    checkPlayerCollisions(playerMesh, controlsObject) {
        if (!playerMesh || !controlsObject || this.collidableObjects.length === 0) {
            return { collision: false, grounded: false };
        }
        
        // Update player bounding box
        const playerBox = this.updateAABB(playerMesh);
        let hasCollision = false;
        let isGrounded = false;
        
        // Check against all collidable objects
        for (const obstacle of this.collidableObjects) {
            // Skip player's own mesh
            if (obstacle === playerMesh) continue;
            
            const obstacleBox = this.updateAABB(obstacle);
            if (this.checkCollision(playerBox, obstacleBox)) {
                hasCollision = true;
                if (this.debugMode) console.log(`Collision detected with ${obstacle.name || 'unnamed object'}`);
                
                // Handle the collision and check if we're standing on something
                const collisionResult = this.handleCollision(playerBox, obstacleBox, controlsObject);
                if (collisionResult.landedOnTop) {
                    isGrounded = true;
                }
            }
        }
        
        return { collision: hasCollision, grounded: isGrounded };
    }

    // Apply collision response and return collision info
    handleCollision(playerBox, obstacleBox, controlsObject) {
        const response = this.getCollisionResponse(playerBox, obstacleBox);
        
        // Apply a small buffer to prevent getting stuck
        const buffer = 0.1;
        let landedOnTop = false;
        
        // Apply the collision response to the controls object
        if (response.axis === 'x') {
            controlsObject.position.x += (response.depth + buffer) * response.direction.x;
        } else if (response.axis === 'y') {
            // For Y-axis collisions, we need to determine if we landed on top
            if (response.direction.y > 0) {
                // We hit the bottom of something
                controlsObject.position.y += (response.depth + buffer) * response.direction.y;
            } else {
                // We landed on top of something
                controlsObject.position.y += (response.depth + buffer) * response.direction.y;
                landedOnTop = true;
                
                // Stop any downward velocity if we're using physics
                if (controlsObject.userData && controlsObject.userData.velocity) {
                    controlsObject.userData.velocity.y = 0;
                }
            }
        } else {
            controlsObject.position.z += (response.depth + buffer) * response.direction.z;
        }
        
        return { landedOnTop };
    }

    // Mark objects in the scene as collidable
    markAllObjectsAsCollidable(scene) {
        scene.traverse(object => {
            // Skip the player, camera, lights, and ground
            if (object.name === 'ground' || 
                object.name === 'player' || 
                object.isLight || 
                object.isCamera) {
                return;
            }
            
            // Mark all meshes that aren't the player, lights, or ground as collidable
            if (object.isMesh) {
                object.userData = object.userData || {};
                object.userData.collidable = true;
                
                // Add it to our collidable objects array if not already there
                if (!this.collidableObjects.includes(object)) {
                    this.collidableObjects.push(object);
                    if (this.debugMode) console.log(`Auto-marked as collidable: ${object.name || 'unnamed mesh'}`);
                }
            }
        });
        
        console.log(`Total collidable objects after auto-marking: ${this.collidableObjects.length}`);
    }

    // Set debug mode
    setDebugMode(debug) {
        this.debugMode = debug;
    }
}

// Create and export a singleton instance
const collisionSystem = new CollisionSystem();

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.CollisionSystem = CollisionSystem;
    window.collisionSystem = collisionSystem;
}

if (typeof module !== 'undefined') {
    module.exports = { CollisionSystem, collisionSystem };
}  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\core\controls.js 
===================================================== 
 
// Global variables
window.moveForward = false;
window.moveBackward = false;
window.moveLeft = false;
window.moveRight = false;
window.turnLeft = false;    // For diagonal movement forward-left
window.turnRight = false;   // For diagonal movement forward-right
window.canJump = false;
// isFirstPerson is a global variable attached to the window object in game-engine.js
window.prevTime = performance.now();
window.velocity = new THREE.Vector3();
window.direction = new THREE.Vector3();

// Add input state object for server-based movement
window.inputState = {
  keys: { w: false, a: false, s: false, d: false, space: false, q: false, e: false, shift: false },
  mouseDelta: { x: 0, y: 0 }
};

// Add variable for right mouse button state tracking
window.rightMouseDown = false;
window.middleMouseDown = false;

// Player settings
window.playerHeight = 2.0;             // Height of camera from ground
window.moveSpeed = 50.0;                // Units per second
window.turnSpeed = 2.0;                // Rotation speed for Q/E turning
window.jumpHeight = 2.0;               // Jump height in units
window.jumpPressed = false;            // Track jump button press

// Third-person camera settings
window.thirdPersonCameraDistance = 5;  // Distance for the third person camera
window.thirdPersonCameraMinDistance = 2; // Minimum zoom distance
window.thirdPersonCameraMaxDistance = 10; // Maximum zoom distance
window.thirdPersonCameraZoomSpeed = 0.5; // Zoom speed multiplier
window.thirdPersonCameraOrbitSpeed = 0.003; // Orbit speed multiplier
window.thirdPersonCameraHeight = 3.0; // Height of camera above player 
window.thirdPersonCameraOrbitX = 0; // Horizontal orbit angle (left/right)
window.thirdPersonCameraOrbitY = 0.5; // Vertical orbit angle (up/down) 
window.thirdPersonCameraMinY = -0.3; // Minimum vertical orbit angle
window.thirdPersonCameraMaxY = 1.0; // Maximum vertical orbit angle

// Add variables for free camera mode
window.freeCameraSpeed = 0.3;         // Speed for free camera movement
window.freeCameraRotationSpeed = 0.003; // Rotation speed for free camera
window.freeCameraPitch = 0;          // Vertical rotation of free camera
window.freeCameraYaw = 0;            // Horizontal rotation of free camera

// Mouse sensitivity settings
window.mouseSensitivity = {
  firstPerson: 1.0,    // Sensitivity multiplier in first-person
  thirdPerson: 0.7,    // Sensitivity multiplier in third-person (slightly lower for smoother movement)
  current: 1.0         // Current sensitivity based on view mode
};

// Add a global viewMode state variable
window.viewMode = 'firstPerson'; // Values: 'firstPerson', 'thirdPerson', 'freeCamera'

// Initialize controls for the camera
window.initControls = function(camera, domElement) {
    console.log("Initializing PointerLockControls properly...");

    const controls = new THREE.PointerLockControls(camera, domElement);
    
    // We don't need a click listener here anymore - it's handled in game-engine.js

    controls.addEventListener('lock', () => {
        const instructions = document.getElementById('lock-instructions');
        if (instructions) {
            instructions.style.display = 'none';
        }
        
        // Update mouse sensitivity based on current view mode
        updateMouseSensitivity();
    });
    
    controls.addEventListener('unlock', () => {
        const instructions = document.getElementById('lock-instructions');
        if (instructions) {
            instructions.style.display = 'block';
        }
        
        if (window.isFirstPerson) {
            const controlsInfo = document.getElementById('controls-info');
            if (controlsInfo) {
                controlsInfo.style.display = 'block';
            }
        }
        // Always show cursor when unlocked, regardless of view mode
        document.body.style.cursor = 'auto';
    });

    // Keyboard listeners for movement remain as-is
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    
    // Mouse button handlers for classic third-person orbital controls
    document.addEventListener('mousedown', (event) => {
        if (event.button === 2) { // Right mouse button
            window.rightMouseDown = true;
        } else if (event.button === 1) { // Middle mouse button (scroll wheel click)
            window.middleMouseDown = true;
        }
    });
    
    document.addEventListener('mouseup', (event) => {
        if (event.button === 2) { // Right mouse button
            window.rightMouseDown = false;
        } else if (event.button === 1) { // Middle mouse button
            window.middleMouseDown = false;
        }
    });
    
    // Prevent context menu from appearing on right-click
    document.addEventListener('contextmenu', (event) => {
        event.preventDefault();
    });

    // Add mouse movement tracking with sensitivity adjustment and fix inversion
    document.addEventListener('mousemove', (event) => {
        if (document.pointerLockElement) {
            // Apply sensitivity adjustment to mouse movements
            const sensitivity = window.mouseSensitivity.current;
            
            if (window.isFirstPerson && !window.isFreeCameraMode) {
                // First-person: Standard FPS mouse look - rotate with mouse movement
                // Store movement for server synchronization
                window.inputState.mouseDelta.x += event.movementX * sensitivity;
                window.inputState.mouseDelta.y -= event.movementY * sensitivity;
                
                // Apply rotation locally for immediate response
                const rotationX = event.movementY * 0.002 * sensitivity; // Vertical rotation (pitch)
                const rotationY = event.movementX * 0.002 * sensitivity; // Horizontal rotation (yaw)
                
                // Update local camera rotation immediately
                if (window.camera) {
                    // Update the camera's pitch (looking up/down)
                    window.firstPersonCameraPitch = window.firstPersonCameraPitch || 0;
                    window.firstPersonCameraPitch -= rotationX;
                    
                    // Clamp the pitch to prevent looking too far up or down
                    window.firstPersonCameraPitch = THREE.MathUtils.clamp(
                        window.firstPersonCameraPitch,
                        -Math.PI/2 + 0.1,  // Slightly less than straight down
                        Math.PI/2 - 0.1    // Slightly less than straight up
                    );
                    
                    // Update the player's rotation around Y axis
                    window.playerRotationY = window.playerRotationY || 0;
                    window.playerRotationY -= rotationY;
                    
                    // Apply the rotations to the camera
                    window.camera.quaternion.setFromEuler(new THREE.Euler(
                        window.firstPersonCameraPitch,
                        window.playerRotationY,
                        0,
                        'YXZ'  // Important for proper FPS controls
                    ));
                    
                    // Also update player mesh rotation immediately for seamless transition to third-person
                    if (window.playerEntity && window.playerEntity.mesh) {
                        window.playerEntity.mesh.rotation.y = window.playerRotationY;
                    }
                }
            } else if (!window.isFirstPerson && !window.isFreeCameraMode) {
                // Third-person: Only rotate camera when right mouse button is held (classic behavior)
                if (window.rightMouseDown || window.middleMouseDown) {
                    // X movement orbits camera horizontally around player
                    window.thirdPersonCameraOrbitX += event.movementX * window.thirdPersonCameraOrbitSpeed;
                    
                    // Y movement changes camera height/angle (with limits to prevent flipping)
                    window.thirdPersonCameraOrbitY -= event.movementY * window.thirdPersonCameraOrbitSpeed;
                    window.thirdPersonCameraOrbitY = THREE.MathUtils.clamp(
                        window.thirdPersonCameraOrbitY,
                        window.thirdPersonCameraMinY,
                        window.thirdPersonCameraMaxY
                    );
                }
            } else if (window.isFreeCameraMode) {
                // Free camera mode: Standard FPS-style look with mouse
                window.freeCameraYaw -= event.movementX * window.freeCameraRotationSpeed;
                window.freeCameraPitch -= event.movementY * window.freeCameraRotationSpeed;
                
                // Limit pitch to avoid flipping
                window.freeCameraPitch = THREE.MathUtils.clamp(
                    window.freeCameraPitch,
                    -Math.PI / 2 + 0.1,  // Avoid looking straight down
                    Math.PI / 2 - 0.1    // Avoid looking straight up
                );
                
                // Apply rotation to camera using quaternions for proper rotation
                window.camera.quaternion.setFromEuler(new THREE.Euler(
                    window.freeCameraPitch,
                    window.freeCameraYaw,
                    0,
                    'YXZ'  // Important for proper FPS controls
                ));
            }
        }
    });
    
    // Add mouse wheel zoom for third-person view
    document.addEventListener('wheel', (event) => {
        // Only handle zoom in third-person mode and not affect the server state
        if (!window.isFirstPerson) {
            // Normalize wheel delta across browsers (positive = zoom in, negative = zoom out)
            const zoomAmount = -Math.sign(event.deltaY) * window.thirdPersonCameraZoomSpeed;
            
            // Apply zoom to the camera distance
            window.thirdPersonCameraDistance = THREE.MathUtils.clamp(
                window.thirdPersonCameraDistance - zoomAmount,
                window.thirdPersonCameraMinDistance,
                window.thirdPersonCameraMaxDistance
            );
            
            console.log(`Third-person camera zoom: ${window.thirdPersonCameraDistance.toFixed(1)}`);
        }
    });

    return controls;
}

// Update mouse sensitivity based on current view mode
function updateMouseSensitivity() {
    if (window.viewMode === 'firstPerson') {
        window.mouseSensitivity.current = window.mouseSensitivity.firstPerson;
    } else if (window.viewMode === 'thirdPerson') {
        window.mouseSensitivity.current = window.mouseSensitivity.thirdPerson;
    } else {
        // Free camera uses first-person sensitivity
        window.mouseSensitivity.current = window.mouseSensitivity.firstPerson;
    }
    console.log(`Updated mouse sensitivity to ${window.mouseSensitivity.current} (${window.viewMode} mode)`);
}

// Function to get the forward direction based on camera orientation in third-person mode
window.getThirdPersonForwardDirection = function() {
    const angle = window.thirdPersonCameraOrbitX;
    return new THREE.Vector3(-Math.sin(angle), 0, -Math.cos(angle));
}

// Key down event handler
function onKeyDown(event) {
    // Skip if we're in an input field or textarea
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
        return;
    }
    
    // Map key code to action
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            window.moveForward = true;
            window.inputState.keys.w = true;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            window.moveLeft = true;
            window.inputState.keys.a = true;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            window.moveBackward = true;
            window.inputState.keys.s = true;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            window.moveRight = true;
            window.inputState.keys.d = true;
            break;
            
        case 'KeyQ':
            window.turnLeft = true;
            window.inputState.keys.q = true;
            break;
            
        case 'KeyE':
            window.turnRight = true;
            window.inputState.keys.e = true;
            break;
            
        case 'Space':
            window.canJump = false; // Reset jump ability until ground collision
            window.inputState.keys.space = true;
            // Client-side jump for prediction - server will override with authority
            if (window.velocity) {
                window.velocity.y = Math.sqrt(window.jumpHeight * 2 * 9.8);
            }
            break;

        case 'KeyV':
            window.toggleCameraView(); // Call the global toggleCameraView function
            break;
        case 'ShiftLeft':
        case 'ShiftRight':
            window.shiftPressed = true;
            window.inputState.keys.shift = true;
            break;
    }
    
    // Force an immediate input update to minimize latency
    if (window.sendInputUpdate && 
        (event.code === 'KeyW' || event.code === 'KeyA' || 
         event.code === 'KeyS' || event.code === 'KeyD' || 
         event.code === 'KeyQ' || event.code === 'KeyE' || 
         event.code === 'Space')) {
        window.sendInputUpdate();
    }
}

// Key up event handler
function onKeyUp(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            window.moveForward = false;
            window.inputState.keys.w = false;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            window.moveLeft = false;
            window.inputState.keys.a = false;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            window.moveBackward = false;
            window.inputState.keys.s = false;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            window.moveRight = false;
            window.inputState.keys.d = false;
            break;
            
        case 'KeyQ':
            window.turnLeft = false;
            window.inputState.keys.q = false;
            break;
            
        case 'KeyE':
            window.turnRight = false;
            window.inputState.keys.e = false;
            break;
            
        case 'Space':
            window.inputState.keys.space = false;
            break;
        case 'ShiftLeft':
        case 'ShiftRight':
            window.shiftPressed = false;
            window.inputState.keys.shift = false;
            break;
    }
    
    // Force an immediate input update to minimize latency
    if (window.sendInputUpdate && 
        (event.code === 'KeyW' || event.code === 'KeyA' || 
         event.code === 'KeyS' || event.code === 'KeyD' || 
         event.code === 'KeyQ' || event.code === 'KeyE' || 
         event.code === 'Space')) {
        window.sendInputUpdate();
    }
}

// Update controls - call this in the animation loop
window.updateControls = function(controls, delta) {
    if (!controls.isLocked) return;

    // If we're in free camera mode, handle movement without updating the server
    if (window.isFreeCameraMode) {
        updateFreeCameraMovement(delta);
        return;
    }

    // Only perform client-side movement prediction 
    // Actual position updates will be driven by the server
    
    // Handle directional movement - scaled by delta for consistent speed
    if (window.moveForward) controls.moveForward(window.moveSpeed * delta);
    if (window.moveBackward) controls.moveForward(-window.moveSpeed * delta);
    if (window.moveLeft) controls.moveRight(-window.moveSpeed * delta);
    if (window.moveRight) controls.moveRight(window.moveSpeed * delta);
    
    // Handle Q/E keys for diagonal movement (forward + turning)
    if (window.turnLeft) {
        // Move diagonally forward-left
        const diagonalSpeed = window.moveSpeed * 0.7 * delta; // Scale down for diagonal
        controls.moveForward(diagonalSpeed);
        controls.moveRight(-diagonalSpeed);
    }
    if (window.turnRight) {
        // Move diagonally forward-right
        const diagonalSpeed = window.moveSpeed * 0.7 * delta; // Scale down for diagonal
        controls.moveForward(diagonalSpeed);
        controls.moveRight(diagonalSpeed);
    }

    // Apply gravity
    window.velocity.y -= 9.8 * delta;
    controls.getObject().position.y += window.velocity.y * delta;

    // Ground collision
    if (controls.getObject().position.y < window.playerHeight) {
        window.velocity.y = 0;
        controls.getObject().position.y = window.playerHeight;
        window.canJump = true;
    }
}

// Handle free camera movement independent of player
function updateFreeCameraMovement(delta) {
    // Calculate movement speed with delta time for consistent speed
    const moveSpeed = window.freeCameraSpeed * delta * 60; // Base speed adjusted for frame rate
    
    // Create movement vectors using quaternion-based direction
    // This ensures movement always follows the camera's view direction
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(window.camera.quaternion).normalize();
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(window.camera.quaternion).normalize();
    
    // Remove any Y component to keep movement horizontal (along XZ plane) for WASD
    forward.y = 0;
    forward.normalize();
    right.y = 0;
    right.normalize();
    
    // Apply movement based on keys
    if (window.moveForward) {
        window.camera.position.addScaledVector(forward, moveSpeed);
    }
    if (window.moveBackward) {
        window.camera.position.addScaledVector(forward, -moveSpeed);
    }
    if (window.moveLeft) {
        window.camera.position.addScaledVector(right, -moveSpeed);
    }
    if (window.moveRight) {
        window.camera.position.addScaledVector(right, moveSpeed);
    }
    
    // Handle vertical movement (space and shift)
    const up = new THREE.Vector3(0, 1, 0);
    if (window.inputState.keys.space) {
        window.camera.position.addScaledVector(up, moveSpeed);
    }
    if (window.shiftPressed) { 
        window.camera.position.addScaledVector(up, -moveSpeed);
    }
}

// Function to toggle between camera views
window.toggleCameraView = function() {
    if (window.viewMode === 'firstPerson') {
        window.viewMode = 'thirdPerson';
        window.isFirstPerson = false;
        window.isFreeCameraMode = false;
        if (typeof window.switchToThirdPersonView === 'function') {
            window.switchToThirdPersonView();
        }
        console.log("[DEBUG] Switched to third-person view");
    } else if (window.viewMode === 'thirdPerson') {
        window.viewMode = 'freeCamera';
        window.isFirstPerson = false;
        window.isFreeCameraMode = true;
        // Save player position for free camera starting point
        if (window.playerEntity && window.playerEntity.mesh) {
            const pos = window.playerEntity.mesh.position.clone();
            pos.y += 3; // Start slightly above the player
            window.camera.position.copy(pos);
        }
        if (typeof window.switchToFreeCameraView === 'function') {
            window.switchToFreeCameraView();
        }
        console.log("[DEBUG] Switched to free camera view");
    } else {
        window.viewMode = 'firstPerson';
        window.isFirstPerson = true;
        window.isFreeCameraMode = false;
        if (typeof window.switchToFirstPersonView === 'function') {
            window.switchToFirstPersonView();
        }
        console.log("[DEBUG] Switched back to first-person view");
    }
    
    // Update mouse sensitivity for the new view mode
    updateMouseSensitivity();
    
    // Update UI for new view mode
    updateViewModeUI();
    
    // Update view toggle button with current mode
    const viewToggleBtn = document.getElementById('view-toggle');
    if (viewToggleBtn) {
        if (window.viewMode === 'firstPerson') {
            viewToggleBtn.textContent = 'First-Person View';
        } else if (window.viewMode === 'thirdPerson') {
            viewToggleBtn.textContent = 'Third-Person View';
        } else {
            viewToggleBtn.textContent = 'Free Camera View';
        }
    }
    
    // Return to prevent recursion
    return window.viewMode;
};

// Function to update the UI based on view mode
function updateViewModeUI() {
    // Do NOT show click instructions/overlay when switching views
    const instructions = document.getElementById('lock-instructions');
    if (instructions) {
        instructions.style.display = 'none';
    }
}
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\core\Entity.js 
===================================================== 
 
// 3D AI Game Platform - Base Entity class for all game entities

class Entity {
    constructor({id, name, value, color, x, y, z, rotationY, type}) {
        this.id = id;
        this.name = name || id;
        this.value = value || 1;
        this.color = color; 
        this.type = type; // Type of visual representation
        this.x = x || 0;
        this.y = y || 1;
        this.z = z || 0;
        this.rotationY = rotationY || 0;
        
        // Create the mesh - this should be implemented by subclasses
        this.mesh = this.createMesh();
        if (this.mesh) {
            this.mesh.position.set(this.x, this.y, this.z);
            this.mesh.rotation.y = this.rotationY;
            
            // Store a reference to this entity in the mesh's userData
            this.mesh.userData.entity = this;
        }
    }

    // Create the visual representation (mesh) for this entity
    // This is a base method that should be overridden by implementation-specific subclasses
    createMesh() {
        console.warn("createMesh() method not implemented in Entity base class");
        return null;
    }

    // Update the entity's position and rotation
    updatePosition(pos) {
        if (!pos) {
            console.warn("updatePosition called with undefined position!");
            return;
        }
    
        const { x, y, z, rotationY } = pos;
    
        if (x !== undefined) {
            this.x = x;
            this.mesh.position.x = x;
        }
        if (y !== undefined) {
            this.y = y;
            this.mesh.position.y = y;
        }
        if (z !== undefined) {
            this.z = z;
            this.mesh.position.z = z;
        }
        if (rotationY !== undefined) {
            this.rotationY = rotationY;
            this.mesh.rotation.y = rotationY;
        }
    }
    
    // Update the entity's value
    // This is a base method that implementations can override
    updateValue(newValue) {
        if (this.value === newValue) return;
        this.value = newValue;
    }

    // Update the entity's color
    // This is a base method that implementations can override
    updateColor(newColor) {
        this.color = newColor;
    }

    // Generic update method called once per frame
    // This should be overridden by subclasses that need frame-by-frame updates
    update(deltaTime) {
        // Base implementation does nothing
    }

    // Remove entity from scene when destroyed
    destroy() {
        if (this.mesh && this.mesh.parent) {
            this.mesh.parent.remove(this.mesh);
        }
    }
}

// Export the Entity class
if (typeof window !== 'undefined') {
    window.Entity = Entity;
}

if (typeof module !== 'undefined') {
    module.exports = { Entity };
}  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\core\EntityFactory.js 
===================================================== 
 
// 3D AI Game Platform - Entity Factory for creating game entities

class EntityFactory {
    constructor() {
        // Registry for entity types and their constructors
        this.registry = {
            // Base types
            entity: Entity,
            player: Player,
            npc: NPC
        };
        
        // Implementation-specific registry - will be populated by implementations
        this.implementationRegistry = {};
    }
    
    // Register a new entity type
    registerType(type, constructor) {
        if (this.registry[type] || this.implementationRegistry[type]) {
            console.warn(`Entity type '${type}' is already registered. Overwriting.`);
        }
        
        // Determine if this is a core type or implementation-specific
        if (constructor.prototype instanceof Entity ||
            constructor === Entity ||
            constructor.prototype instanceof Player ||
            constructor === Player ||
            constructor.prototype instanceof NPC ||
            constructor === NPC) {
            this.registry[type] = constructor;
        } else {
            this.implementationRegistry[type] = constructor;
        }
    }
    
    // Register implementation-specific entity types
    registerImplementation(implementationName, entityTypes) {
        for (const [type, constructor] of Object.entries(entityTypes)) {
            const fullType = `${implementationName}.${type}`;
            this.registerType(fullType, constructor);
        }
    }
    
    // Create an entity based on type and parameters
    createEntity(type, params) {
        // Check if this is an implementation-specific type
        if (type.includes('.')) {
            const [implementationName, specificType] = type.split('.');
            const constructor = this.implementationRegistry[type];
            
            if (constructor) {
                return new constructor(params);
            } else {
                console.error(`Implementation-specific entity type '${type}' not found.`);
                return null;
            }
        }
        
        // Check core registry
        const Constructor = this.registry[type];
        if (Constructor) {
            return new Constructor(params);
        }
        
        // If no match found, log error and return null
        console.error(`Entity type '${type}' not found in registry.`);
        return null;
    }
    
    // Create a player entity
    createPlayer(params) {
        const type = params.type || 'player';
        params.isPlayer = true;
        
        return this.createEntity(type, params);
    }
    
    // Create an NPC entity
    createNPC(params) {
        const type = params.type || 'npc';
        
        return this.createEntity(type, params);
    }
}

// Create and export a singleton instance
const entityFactory = new EntityFactory();

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.EntityFactory = EntityFactory;
    window.entityFactory = entityFactory;
}

if (typeof module !== 'undefined') {
    module.exports = { EntityFactory, entityFactory };
}  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\core\game-engine.js 
===================================================== 
 
// 3D Game Platform - Game Engine
// Handles 3D scene, rendering, game loop, and core gameplay

// Debug support
const DEBUG = false; // Set to false to disable debug messages

function debug(message, isError = false) {
    if (!DEBUG) return;
    
    // Log to console only when debug is enabled
    if (isError) {
        console.error(`[ERROR] ${message}`);
    } else {
        console.log(`[DEBUG] ${message}`);
    }
}

// Game variables
let scene, camera, renderer, controls;
let player;  // Player object
let playerValue = 1;

// Add operator tracking without redeclaring variables
let heldOperator = null;
let lastOperatorSpawn = 0;

// Rotation variables for Q/E keys
let rotationQuaternion = new THREE.Quaternion();
let worldUp = new THREE.Vector3(0, 1, 0);
let rotationAxis = new THREE.Vector3();

// Global view mode tracking
window.isFirstPerson = true;  // Start in first-person view
window.isFreeCameraMode = false; // Not in free camera mode initially
window.playerPosition = null; // Store player position for returning from free camera mode

// HUD elements
const gameHUD = document.getElementById('game-hud');

// Global variables and UI elements
let viewToggleBtn = null; // Global reference for the view toggle button

// Initialize networking variables
let lastSentPosition = new THREE.Vector3();
let lastSentRotation = 0;
let positionUpdateInterval = 100; // ms between position updates
let lastPositionUpdate = 0;
let inputUpdateInterval = 1000 / 30; // 30Hz input updates
let lastInputUpdate = 0;

// Add variables for input throttling
window.inputThrottleMs = 16; // Send inputs roughly every frame (60fps = 16.67ms)
window.lastInputTime = 0;

// Array to store animation callbacks
window.animationCallbacks = [];

// Function to register callbacks to be executed during the animation loop
window.registerAnimationCallback = function(callback) {
    if (typeof callback === 'function' && !window.animationCallbacks.includes(callback)) {
        window.animationCallbacks.push(callback);
        console.log("Registered animation callback:", callback.name || "anonymous");
        return true;
    }
    return false;
};

// Function to unregister a callback from the animation loop
window.unregisterAnimationCallback = function(callback) {
    const index = window.animationCallbacks.indexOf(callback);
    if (index !== -1) {
        window.animationCallbacks.splice(index, 1);
        console.log("Unregistered animation callback:", callback.name || "anonymous");
        return true;
    }
    return false;
};

// Initialize physics variables and flags
function initPhysics() {
    try {
        debug('Initializing physics');
        
        // Basic physics setup
        window.velocity = new THREE.Vector3(0, 0, 0);
        window.direction = new THREE.Vector3(0, 0, 0);
        window.canJump = false;
        
        // Setup movement flags
        window.moveForward = false;
        window.moveBackward = false;
        window.moveLeft = false;
        window.moveRight = false;
        window.turnLeft = false;
        window.turnRight = false;
        
        // Setup rotation utilities
        window.worldUp = new THREE.Vector3(0, 1, 0);
        window.rotationAxis = new THREE.Vector3();
        window.rotationQuaternion = new THREE.Quaternion();
        
        debug('Physics initialized successfully');
    } catch (error) {
        debug(`Error initializing physics: ${error.message}`, true);
    }
}

// Initialize the floor
function initFloor() {
    try {
        debug('Creating floor');
        
        // Create a larger green floor with darker color
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x114411,
            roughness: 0.8, 
            metalness: 0.2 
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        
        // Rotate and position the floor
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Add a grid helper for visual reference
        const gridHelper = new THREE.GridHelper(100, 100, 0x000000, 0x444444);
        scene.add(gridHelper);
        
        debug('Floor created successfully');
    } catch (error) {
        debug(`Error creating floor: ${error.message}`, true);
    }
}

// Initialize the game
window.onload = function() {
    debug('Window loaded, initializing game...');
    
    // Add view toggle button
    addViewToggleButton();
    
    // Create a dummy OperatorManager if not defined (for default implementation)
    if (typeof OperatorManager === 'undefined') {
        window.OperatorManager = class OperatorManager {
            constructor() {
                this.operators = {};
            }
            
            createOperator() { return null; }
            updateOperator() {}
            removeOperator() {}
            createOperatorFromServer() { return { group: new THREE.Group() }; }
            updateOperatorFromServer() {}
            removeOperatorByServerId() {}
        };
    }
    
    // Initialize with window.viewMode and window.isFirstPerson set to first-person
    window.viewMode = 'firstPerson';
    window.isFirstPerson = true;
    window.isFreeCameraMode = false;
    window.playerLoaded = false; // Track if player has been created
    
    // Note: The 'v' keypress listener has been removed as it's handled in controls.js
    
    init();
};

// Add view toggle button to switch between first and third person
function addViewToggleButton() {
    try {
        // Create button if it doesn't exist
        viewToggleBtn = document.getElementById('view-toggle');
        
        if (!viewToggleBtn) {
            viewToggleBtn = document.createElement('button');
            viewToggleBtn.id = 'view-toggle';
            viewToggleBtn.textContent = 'First-Person View';  // Default view mode
            viewToggleBtn.style.position = 'absolute';
            viewToggleBtn.style.bottom = '20px';
            viewToggleBtn.style.right = '20px';
            viewToggleBtn.style.zIndex = '100';
            viewToggleBtn.style.padding = '8px 12px';
            viewToggleBtn.style.backgroundColor = 'rgba(0,0,0,0.6)';
            viewToggleBtn.style.color = 'white';
            viewToggleBtn.style.border = 'none';
            viewToggleBtn.style.borderRadius = '4px';
            viewToggleBtn.style.cursor = 'pointer';
            document.body.appendChild(viewToggleBtn);
        }
        
        // Add click event listener to use the function from controls.js
        viewToggleBtn.addEventListener('click', window.toggleCameraView);
        
        debug('View toggle button added');
    } catch (error) {
        debug(`Error adding view toggle button: ${error.message}`, true);
    }
}

// Toggle between first-person, third-person and free camera view functions have been moved to controls.js

// First-person setup
window.switchToFirstPersonView = function() {
    // Hide player's mesh in first-person
    if (window.playerEntity && window.playerEntity.mesh) {
        window.playerEntity.mesh.visible = false;
    }
    
    // Reset free camera variables
    window.freeCameraYaw = 0;
    window.freeCameraPitch = 0;
    
    // Set camera position based on the available player information
    // Try multiple sources to ensure we always have a position
    let playerX = 0, playerY = 0, playerZ = 0, rotationY = 0, pitch = 0;
    
    // First check server state if available
    if (window.room && window.room.state && window.room.state.players) {
        const playerState = window.room.state.players.get(window.room.sessionId);
        if (playerState) {
            playerX = playerState.x;
            playerY = playerState.y;
            playerZ = playerState.z;
            rotationY = playerState.rotationY || 0;
            pitch = playerState.pitch || 0;
        }
    }
    // Fallback to local player object if server state not available
    else if (window.playerEntity && window.playerEntity.mesh) {
        playerX = window.playerEntity.mesh.position.x;
        playerY = window.playerEntity.mesh.position.y;
        playerZ = window.playerEntity.mesh.position.z;
        rotationY = window.playerEntity.mesh.rotation.y || 0;
    }
    
    // Position camera at player's head
    if (window.camera) {
        window.camera.position.set(
            playerX,
            playerY + (window.playerHeight || 2.0),
            playerZ
        );
        
        // Set camera rotation using quaternions to prevent gimbal lock
        window.camera.quaternion.setFromEuler(new THREE.Euler(
            pitch,
            rotationY + Math.PI,
            0,
            'YXZ'  // Important for proper FPS controls
        ));
        
        // Update controls position if available
        if (controls) {
            controls.getObject().position.copy(window.camera.position);
        }
        
        // Force an immediate render to show the new view
        if (window.renderer && window.scene) {
            window.renderer.render(window.scene, window.camera);
        }
    }
    
    // If we were in free camera mode, tell the server we're back
    if (window.isFreeCameraMode) {
        window.isFreeCameraMode = false;
        if (window.sendInputUpdate) {
            window.sendInputUpdate();
        }
    }
    
    console.log("Switched to first-person view. Camera at:", window.camera.position);
};

// Third-person setup
window.switchToThirdPersonView = function() {
    // Show player's mesh in third-person
    if (window.playerEntity && window.playerEntity.mesh) {
        window.playerEntity.mesh.visible = true;
    }
    
    // Reset orbit angles if they don't exist
    window.thirdPersonCameraOrbitX = window.thirdPersonCameraOrbitX || 0;
    window.thirdPersonCameraOrbitY = window.thirdPersonCameraOrbitY || 0.5;
    
    // Make sure player state exists
    if (window.room && window.room.state && window.room.state.players) {
        const playerState = window.room.state.players.get(window.room.sessionId);
        if (playerState) {
            // Position camera based on player's current position/rotation
            const offsetX = window.thirdPersonCameraDistance * Math.sin(playerState.rotationY) * Math.cos(window.thirdPersonCameraOrbitY);
            const offsetZ = window.thirdPersonCameraDistance * Math.cos(playerState.rotationY) * Math.cos(window.thirdPersonCameraOrbitY);
            const offsetY = window.thirdPersonCameraDistance * Math.sin(window.thirdPersonCameraOrbitY);
            
            // Immediately position camera with offset for immediate visual feedback
            window.camera.position.set(
                playerState.x + offsetX,
                playerState.y + window.thirdPersonCameraHeight + offsetY,
                playerState.z + offsetZ
            );
            
            // Set camera to look at player
            const lookTarget = new THREE.Vector3(
                playerState.x, 
                playerState.y + window.thirdPersonCameraHeight * 0.8, // Look at upper body
                playerState.z
            );
            
            // Create look direction and rotation
            const direction = new THREE.Vector3().subVectors(lookTarget, window.camera.position).normalize();
            const quaternion = new THREE.Quaternion().setFromUnitVectors(
                new THREE.Vector3(0, 0, -1),
                direction
            );
            
            // Apply rotation to camera immediately
            window.camera.quaternion.copy(quaternion);
            
            // Force an immediate render to update the view
            if (window.renderer && window.scene) {
                window.renderer.render(window.scene, window.camera);
            }
        }
    }
    
    console.log("Switched to third-person view. Camera at:", window.camera.position);
};

// Free camera setup
window.switchToFreeCameraView = function() {
    // Store current camera position for when we return
    window.playerPosition = camera.position.clone();
    window.isFreeCameraMode = true;
    
    // Show player mesh since we're viewing from outside
    if (window.playerEntity && window.playerEntity.mesh) {
        window.playerEntity.mesh.visible = true;
    }
    
    // Keep pointer lock active but disable normal controls
    if (controls) {
        if (!controls.isLocked) {
            controls.lock();
        }
        controls.enabled = false;
    }
    
    // Initialize free camera movement speed
    window.freeCameraSpeed = 0.5;
    
    console.log("Switched to free camera view");
};

// Handle mouse movement for free camera
function onMouseMove(event) {
    if (!window.controls || !window.controls.isLocked) return;
    
    // Store mouse movement for input state
    window.inputState.mouseDelta.x += event.movementX;
    window.inputState.mouseDelta.y += event.movementY;
    
    if (window.isFreeCameraMode) {
        // Initialize Euler angles if they don't exist
        if (!window.freeCameraEuler) {
            window.freeCameraEuler = new THREE.Euler(0, 0, 0, 'YXZ');
        }
        
        // Update rotation with mouse movement
        const rotationSpeed = 0.002;
        
        // Update yaw (left/right) and pitch (up/down)
        window.freeCameraEuler.y -= event.movementX * rotationSpeed;
        window.freeCameraEuler.x = Math.max(
            -Math.PI/2,
            Math.min(Math.PI/2,
                window.freeCameraEuler.x - event.movementY * rotationSpeed
            )
        );
        
        // Keep roll (z-axis) at 0 to prevent tilting
        window.freeCameraEuler.z = 0;
        
        // Apply rotation to camera, maintaining upright orientation
        camera.quaternion.setFromEuler(window.freeCameraEuler);
    }
}

// Handle keyboard movement for free camera
function updateFreeCameraMovement() {
    if (!window.isFreeCameraMode) return;
    
    const speed = window.freeCameraSpeed;
    const moveVector = new THREE.Vector3();
    
    // Get camera's forward and right vectors
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
    
    // WASD movement
    if (window.inputState.keys.w) moveVector.add(forward.multiplyScalar(speed));
    if (window.inputState.keys.s) moveVector.sub(forward);
    if (window.inputState.keys.a) moveVector.sub(right);
    if (window.inputState.keys.d) moveVector.add(right);
    
    // Up/Down movement with Q/E
    if (window.inputState.keys.q) moveVector.y += speed;
    if (window.inputState.keys.e) moveVector.y -= speed;
    
    // Apply movement
    camera.position.add(moveVector.multiplyScalar(speed));
}

// Position camera behind player for third-person view - more responsive
window.updateThirdPersonCamera = function() {
    if (!window.room || !window.room.state || !window.room.state.players) return;
    
    const playerState = window.room.state.players.get(window.room.sessionId);
    if (!playerState) return;
    
    // Calculate offset based on orbit angles
    const offsetX = window.thirdPersonCameraDistance * Math.sin(window.thirdPersonCameraOrbitX) * Math.cos(window.thirdPersonCameraOrbitY);
    const offsetZ = window.thirdPersonCameraDistance * Math.cos(window.thirdPersonCameraOrbitX) * Math.cos(window.thirdPersonCameraOrbitY);
    const offsetY = window.thirdPersonCameraDistance * Math.sin(window.thirdPersonCameraOrbitY);
    
    // Calculate target camera position
    const targetX = playerState.x + offsetX;
    const targetY = playerState.y + window.thirdPersonCameraHeight + offsetY;
    const targetZ = playerState.z + offsetZ;
    
    // Use faster lerp for more responsive camera movement
    const lerpFactor = 0.3; // Higher = more responsive
    
    // Apply smooth but responsive camera movement
    window.camera.position.x = THREE.MathUtils.lerp(window.camera.position.x, targetX, lerpFactor);
    window.camera.position.y = THREE.MathUtils.lerp(window.camera.position.y, targetY, lerpFactor);
    window.camera.position.z = THREE.MathUtils.lerp(window.camera.position.z, targetZ, lerpFactor);
    
    // Instant position correction if too far away (prevents extreme lag)
    const distSq = Math.pow(window.camera.position.x - targetX, 2) +
                   Math.pow(window.camera.position.y - targetY, 2) +
                   Math.pow(window.camera.position.z - targetZ, 2);
                   
    if (distSq > 25) { // About 5 units away - immediately snap to correct position
        window.camera.position.set(targetX, targetY, targetZ);
    }
    
    // Point camera at player
    const lookTarget = new THREE.Vector3(
        playerState.x, 
        playerState.y + window.thirdPersonCameraHeight * 0.8, // Look at upper body
        playerState.z
    );
    
    // Create look direction and rotation
    const direction = new THREE.Vector3().subVectors(lookTarget, window.camera.position).normalize();
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 0, -1),
        direction
    );
    
    // Apply rotation to camera immediately for responsive look
    window.camera.quaternion.copy(quaternion);
    
    // Ensure player mesh is visible in third-person view
    if (window.playerEntity && window.playerEntity.mesh) {
        window.playerEntity.mesh.visible = true;
    }
};

// Main initialization function
function init() {
    try {
        debug('Initializing game');
        
        // Create the scene first
        initScene();
        
        // Initialize physics variables and flags
        initPhysics();
        
        // Create the camera
        debug('Creating camera');
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Only initialize with temporary position - actual position will be set when player is created
        camera.position.set(0, 0, 0);
        window.camera = camera; // Make globally available
        
        // Setup renderer
        debug('Setting up renderer');
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.gammaFactor = 2.2;
        
        // Add renderer to document
        document.body.appendChild(renderer.domElement);
        window.renderer = renderer;
        
        // Initialize the floor
        initFloor();

        // Explicitly set camera mode before initializing controls
        window.isFirstPerson = true;  

        // Setup controls for player movement
        setupPointerLockControls();
        
        // Player will be created after clicking "Click to play"
        
        // Add resize event listener
        window.addEventListener('resize', onWindowResize, false);
        
        // Make key handlers available for player movement
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        
        // Add mouse event listeners
        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('mouseup', onMouseUp, false);
        document.addEventListener('mousemove', onMouseMove, false);
        
        // Handle page visibility changes to reset input state when tab is not active
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Reset input state when tab loses focus
                window.moveForward = false;
                window.moveBackward = false;
                window.moveLeft = false;
                window.moveRight = false;
                window.turnLeft = false;
                window.turnRight = false;
                window.inputState.keys = { 
                    w: false, a: false, s: false, d: false, 
                    space: false, q: false, e: false, shift: false 
                };
                // Force an immediate input update
                if (window.sendInputUpdate) {
                    window.sendInputUpdate();
                }
            }
        });
        
        // Make sure global variables are properly declared
        window.scene = scene;
        window.camera = camera;
        window.renderer = renderer;
        window.controls = controls;
        
        // Expose sendInputUpdate to window for access from other modules
        window.sendInputUpdate = sendInputUpdate;
        
        // Start the animation loop
        requestAnimationFrame(animate);
        
        debug('Game successfully initialized');
    } catch (error) {
        debug(`Full initialization error: ${error.message}`, true);
        console.error('Full initialization error:', error);
    }
}


// Initialize the scene
function initScene() {
    try {
        debug('Creating scene');
        
        // Create the scene
        scene = new THREE.Scene();
        
        // Make scene globally available
        window.scene = scene;
        
        // Set background color
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        
        // Add fog for depth perception - COMMENTED OUT client-side terrain setting
        // scene.fog = new THREE.Fog(0x87CEEB, 10, 100);
        
        // Add proper lighting with reduced intensity
        // Ambient light - provides overall illumination to the scene
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Reduced from 0.8
        scene.add(ambientLight);
        
        // Directional light - mimics sunlight
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reduced from 1.0
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Hemisphere light - for natural outdoor lighting (sky/ground gradient)
        const hemisphereLight = new THREE.HemisphereLight(0xddeeff, 0x3e2200, 0.4); // Reduced from 0.7
        scene.add(hemisphereLight);
        
        // Initialize operator manager and make it globally available
        operatorManager = new OperatorManager(scene);
        window.operatorManager = operatorManager;
        
        debug('Scene created successfully');
    } catch (error) {
        debug(`Error creating scene: ${error.message}`, true);
    }
}

// Setup PointerLock controls
function setupPointerLockControls() {
    debug('Setting up PointerLock controls');
    
    try {
        controls = window.initControls(camera, renderer.domElement);
        
        let instructions = document.getElementById('lock-instructions');
        
        if (!instructions) {
            console.warn('Lock instructions element not found, creating one');
            instructions = document.createElement('div');
            instructions.id = 'lock-instructions';
            instructions.style.position = 'absolute';
            instructions.style.width = '100%';
            instructions.style.height = '100%';
            instructions.style.top = '0';
            instructions.style.left = '0';
            instructions.style.display = 'flex';
            instructions.style.flexDirection = 'column';
            instructions.style.justifyContent = 'center';
            instructions.style.alignItems = 'center';
            instructions.style.color = '#ffffff';
            instructions.style.textAlign = 'center';
            instructions.style.backgroundColor = 'rgba(0,0,0,0.5)';
            instructions.style.cursor = 'pointer';
            instructions.style.zIndex = '1000';
            instructions.innerHTML = '<p>Click to play</p>';
            document.body.appendChild(instructions);
        }

        // Add click event to the entire document
        document.addEventListener('click', () => {
            controls.lock();
        }, false);

        // Handle pointer lock change explicitly
        function onPointerLockChange() {
            if (document.pointerLockElement === renderer.domElement || 
                document.mozPointerLockElement === renderer.domElement ||
                document.webkitPointerLockElement === renderer.domElement) {
                
                debug('Pointer is now locked');
                instructions.style.display = 'none';
                document.body.classList.add('controls-enabled');
                window.canJump = true;
                window.isControlsEnabled = true;
                
                // Create the player's entity if not already created
                if (!window.playerLoaded) {
                    debug('Creating player entity after click to play');
                    // Initialize the player
                    window.playerEntity = window.createPlayerEntity(scene);
                    window.player = window.playerEntity;
                    window.playerLoaded = true;
                    
                    // Make sure player mesh is invisible in first-person view
                    if (window.playerEntity && window.playerEntity.mesh) {
                        window.playerEntity.mesh.visible = false;
                    }
                    
                    // Initialize networking if not already done
                    if (!window.room) {
                        window.initNetworking().then((roomInstance) => {
                            window.gameRoom = roomInstance;
                            window.room = roomInstance;
                            
                            // Start getting updates from the server
                            setInterval(sendInputUpdate, 1000 / 30);
                            
                            // Apply the first-person view once the room is joined
                            if (window.switchToFirstPersonView) {
                                window.switchToFirstPersonView();
                            }
                        }).catch((error) => {
                            debug(`Networking error: ${error.message}`, true);
                        });
                    } else {
                        // Apply the first-person view if we already have a room
                        if (window.switchToFirstPersonView) {
                            window.switchToFirstPersonView();
                        }
                    }
                }

                if (!window.isAnimating) {
                    window.isAnimating = true;
                    animate();
                }
            } else {
                // Only show instructions if we're not in free camera mode AND not already playing
                if (!window.isFreeCameraMode && !window.playerLoaded) {
                    instructions.style.display = 'block';
                } else {
                    instructions.style.display = 'none';
                }
                debug('Pointer is unlocked');
            }
        }

        // Attach pointer lock event listeners clearly to the document
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        document.addEventListener('mozpointerlockchange', onPointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', onPointerLockChange, false);

        scene.add(controls.getObject());
        window.isFirstPerson = true;

        debug('PointerLock controls setup complete');
    } catch (error) {
        debug(`Error setting up PointerLock controls: ${error.message}`, true);
    }
}

// Update player movement physics with more responsive server sync
function updatePlayerPhysics(delta) {
    if (!controls || !scene || !controls.isLocked) return;
    
    const controlsObject = controls.getObject();
    
    // Get current player state from server if available
    if (window.room && window.room.state && window.room.state.players) {
        const player = window.room.state.players.get(window.room.sessionId);
        if (player) {
            // Update the player's position based on the server position
            // Higher lerpFactor means more responsive but potentially less smooth
            const lerpFactor = 0.3; // Increased for more responsive movement
            
            // Smoothly interpolate to the server position
            controlsObject.position.x = THREE.MathUtils.lerp(
                controlsObject.position.x, 
                player.x, 
                lerpFactor
            );
            
            controlsObject.position.z = THREE.MathUtils.lerp(
                controlsObject.position.z, 
                player.z, 
                lerpFactor
            );
            
            // Use server Y position for jumping/falling
            controlsObject.position.y = THREE.MathUtils.lerp(
                controlsObject.position.y, 
                player.y, 
                lerpFactor * 2  // Faster vertical correction
            );
            
            // If there's a significant desync, instantly correct position
            const distanceSquared = 
                Math.pow(controlsObject.position.x - player.x, 2) + 
                Math.pow(controlsObject.position.z - player.z, 2);
                
            if (distanceSquared > 5) { // Lowered threshold for quicker corrections
                controlsObject.position.x = player.x;
                controlsObject.position.z = player.z;
                controlsObject.position.y = player.y;
                console.log("Position correction applied");
            }
            
            // Update the player's velocity
            window.velocity.y = player.velocityY;
            
            // Update player entity position and scale to match player value
            if (typeof updatePlayerEntity === 'function') {
                updatePlayerEntity(player.value);
            }
            
            // Update player info in UI if available
            if (window.playerUI && typeof window.playerUI.updatePlayerListUI === 'function') {
                window.playerUI.updatePlayerListUI();
            }
            
            // Force camera to update based on view mode for immediate feedback
            if (window.isFirstPerson && !window.isFreeCameraMode) {
                window.updateFirstPersonCamera();
            } else if (!window.isFreeCameraMode) {
                window.updateThirdPersonCamera();
            }
        }
    } else {
        // Use client-side physics for prediction if server data not available
        // Apply gravity
        window.velocity.y -= 9.8 * delta;
        controlsObject.position.y += window.velocity.y * delta;
        
        // Basic ground collision
        if (controlsObject.position.y < 1) {
            window.velocity.y = 0;
            controlsObject.position.y = 1;
            window.canJump = true;
        }
    }
}

// initialize your global visuals safely if not done already
window.visuals = window.visuals || { players: {}, operators: {}, staticEntities: {} };

// Animation loop
function animate(currentTime) {
    requestAnimationFrame(animate);
    
    if (!window.prevTime) window.prevTime = performance.now();
    if (!currentTime) currentTime = performance.now();
    
    const delta = Math.min((currentTime - window.prevTime) / 1000, 0.1);
    window.prevTime = currentTime;
    
    // Handle different camera modes
    if (window.isFreeCameraMode) {
        // Update free camera movement
        updateFreeCameraMovement();
    } else if (controls && controls.isLocked) {
        // Normal controls update for first/third person
        window.updateControls(controls, delta);
        updatePlayerPhysics(delta);
    }
    
    // Update player state from server
    if (window.room && window.room.state && window.room.state.players) {
        const playerState = window.room.state.players.get(window.room.sessionId);
        if (playerState) {
            // Update player mesh
            if (window.playerEntity && window.playerEntity.mesh) {
                window.playerEntity.mesh.position.set(playerState.x, playerState.y, playerState.z);
                window.playerEntity.mesh.rotation.y = playerState.rotationY;
                window.playerEntity.mesh.visible = window.isFreeCameraMode || !window.isFirstPerson;
            }
            
            // Only update camera for first/third person modes
            if (!window.isFreeCameraMode) {
                if (window.isFirstPerson) {
                    window.updateFirstPersonCamera();
                } else {
                    window.updateThirdPersonCamera();
                }
            }
        }
    }
    
    // Execute all registered animation callbacks
    if (window.animationCallbacks && window.animationCallbacks.length > 0) {
        for (let i = 0; i < window.animationCallbacks.length; i++) {
            try {
                window.animationCallbacks[i](delta);
            } catch (error) {
                console.error("Error in animation callback:", error);
            }
        }
    }
    
    // Explicitly call updateRemotePlayers to ensure other players are always rendered
    if (typeof window.updateRemotePlayers === 'function') {
        window.updateRemotePlayers();
    }
    
    renderer.render(scene, camera);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function sendInputUpdate() {
    // Don't send updates if we're in free camera mode or if player isn't loaded yet
    if (window.isFreeCameraMode || !window.playerLoaded) {
        return;
    }

    if (window.room) {
        const now = performance.now();
        if ((now - window.lastInputTime) > window.inputThrottleMs) {
            window.lastInputTime = now;
            
            // Make sure all key states are properly set before sending
            const keyStates = {
                w: window.moveForward,
                a: window.moveLeft, 
                s: window.moveBackward,
                d: window.moveRight,
                space: window.inputState.keys.space || false,
                q: window.turnLeft || window.inputState.keys.q || false,
                e: window.turnRight || window.inputState.keys.e || false,
                shift: window.shiftPressed || false
            };
            
            // Update the global input state to ensure everything is in sync
            window.inputState.keys = keyStates;
            
            // Send the updated input state to server
            window.room.send("updateInput", {
                keys: keyStates,
                mouseDelta: {
                    x: window.isFirstPerson ? window.inputState.mouseDelta.x : 0,
                    y: window.isFirstPerson ? window.inputState.mouseDelta.y : 0
                },
                viewMode: window.isFirstPerson ? "first-person" : "third-person",
                thirdPersonCameraAngle: window.thirdPersonCameraOrbitX,
                // Send direct rotation values for immediate application on server
                clientRotation: {
                    rotationY: window.playerRotationY || 0,
                    pitch: window.firstPersonCameraPitch || 0
                }
            });
            
            // Reset mouse delta after sending
            window.inputState.mouseDelta.x = 0;
            window.inputState.mouseDelta.y = 0;
            
            // Debug output to confirm inputs are sent
            if (keyStates.w || keyStates.a || keyStates.s || keyStates.d || keyStates.q || keyStates.e) {
                console.log("Sending input to server:", keyStates);
            }
        }
    }
}

setInterval(sendInputUpdate, 1000 / 30);

window.thirdPersonCameraDistance = 5;
window.thirdPersonCameraOrbitX = 0;
window.thirdPersonCameraOrbitY = 0;

// Update third-person camera position based on orbit angles
function updateThirdPersonCameraPosition() {
    if (!window.room || !window.room.state || !window.room.state.players) return;
    const playerState = window.room.state.players.get(window.room.sessionId);
    if (!playerState) return;
    
    // Get camera reference
    const camera = window.camera;
    
    // Calculate theta (horizontal orbit angle) and phi (vertical orbit angle)
    const theta = window.thirdPersonCameraOrbitX;
    const phi = window.thirdPersonCameraOrbitY;
    
    // Calculate camera position based on spherical coordinates
    const distance = window.thirdPersonCameraDistance;
    const offsetX = distance * Math.sin(theta) * Math.cos(phi);
    const offsetY = distance * Math.sin(phi);
    const offsetZ = distance * Math.cos(theta) * Math.cos(phi);
    
    // Calculate camera position relative to player
    const cameraPosition = new THREE.Vector3(
        playerState.x + offsetX,
        playerState.y + window.playerHeight / 2 + offsetY,
        playerState.z + offsetZ
    );
    
    // Set camera position
    camera.position.copy(cameraPosition);
    
    // Use our helper function to fix orientation
    setThirdPersonCameraOrientation(
        camera,
        cameraPosition,
        new THREE.Vector3(playerState.x, playerState.y, playerState.z)
    );
}

// Make updateFirstPersonCamera globally accessible
window.updateFirstPersonCamera = function() {
    if (!window.room || !window.room.state || !window.room.state.players) return;
    
    const playerState = window.room.state.players.get(window.room.sessionId);
    if (!playerState) return;
    
    // Update camera position to be exactly at player's position (with head height)
    if (window.camera && controls) {
        // Position camera exactly at player position with head height
        window.camera.position.set(
            playerState.x,
            playerState.y + (window.playerHeight || 2.0),
            playerState.z
        );
        
        // Apply proper rotation using player's server-side rotation values
        // and any local camera pitch changes for immediate feedback
        const pitch = typeof window.firstPersonCameraPitch !== 'undefined' 
            ? window.firstPersonCameraPitch 
            : (playerState.pitch || 0);
            
        const rotationY = typeof window.playerRotationY !== 'undefined'
            ? window.playerRotationY
            : (playerState.rotationY || 0);
            
        window.camera.quaternion.setFromEuler(new THREE.Euler(
            pitch,
            rotationY,
            0,
            'YXZ' // Important for proper FPS rotation order
        ));
        
        // Update the controls object to match camera position
        if (controls.getObject) {
            controls.getObject().position.copy(window.camera.position);
        }
        
        // Make sure the player mesh is invisible in first-person
        if (window.playerEntity && window.playerEntity.mesh) {
            window.playerEntity.mesh.visible = false;
        }
    }
};

// Handle view-specific camera updates
function updateThirdPersonCamera() {
    // Get player state
    const playerState = window.room.state.players.get(window.room.sessionId);
    if (!playerState) return;
    
    // Third-person: Position camera behind player with smooth follow
    
    // First, update the camera orbit angle to match the player's rotation
    // This makes the camera follow behind the player when they rotate with Q and E
    window.thirdPersonCameraOrbitX = playerState.rotationY;
    
    // Calculate ideal camera position based on orbit angles
    const theta = window.thirdPersonCameraOrbitX;
    const phi = window.thirdPersonCameraOrbitY;
    
    // Calculate camera position based on spherical coordinates
    const distance = window.thirdPersonCameraDistance;
    const offsetX = distance * Math.sin(theta) * Math.cos(phi);
    const offsetY = distance * Math.sin(phi);
    const offsetZ = distance * Math.cos(theta) * Math.cos(phi);
    
    // Target position (slightly above player's head)
    const lookAtPosition = new THREE.Vector3(
        playerState.x,
        playerState.y + window.playerHeight * 0.7, // Look at player's upper body
        playerState.z
    );
    
    // Set camera position
    const targetCameraPos = new THREE.Vector3(
        playerState.x + offsetX,
        playerState.y + offsetY + window.playerHeight * 0.5,
        playerState.z + offsetZ
    );
    
    // Smooth camera movement
    camera.position.lerp(targetCameraPos, 0.2);
    
    // Fix camera orientation
    setThirdPersonCameraOrientation(camera, lookAtPosition, playerState);
    
    // Show player mesh in third-person and make sure it's updated
    if (window.playerEntity && window.playerEntity.mesh) {
        window.playerEntity.mesh.visible = true;
        
        // Update position
        window.playerEntity.mesh.position.set(playerState.x, playerState.y, playerState.z);
        
        // Smooth rotation
        const currentRot = window.playerEntity.mesh.rotation.y;
        const targetRot = playerState.rotationY;
        
        // Find the shortest rotation path
        let rotDiff = targetRot - currentRot;
        if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        
        // Apply smooth rotation
        window.playerEntity.mesh.rotation.y += rotDiff * 0.1;
    }
}

// Mouse down event handler
function onMouseDown(event) {
    // Left button: 0, Middle: 1, Right: 2
    if (event.button === 2) {
        window.rightMouseDown = true;
    } else if (event.button === 1) {
        window.middleMouseDown = true;
    }
}

// Mouse up event handler
function onMouseUp(event) {
    if (event.button === 2) {
        window.rightMouseDown = false;
    } else if (event.button === 1) {
        window.middleMouseDown = false;
    }
}
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\core\main.js 
===================================================== 
 
// 3D Game Platform - Main Entry Point

// Parse URL parameters for customization
function getUrlParams() {
    const params = {};
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    
    // Get custom player name if provided
    if (urlParams.has('playerName')) {
        params.playerName = urlParams.get('playerName');
    }
    
    // Get custom player color if provided
    if (urlParams.has('playerColor')) {
        // Convert hex string to number
        const colorStr = urlParams.get('playerColor');
        params.playerColor = parseInt(colorStr, 16);
    }
    
    return params;
}

// Get URL parameters
const urlParams = getUrlParams();

// Game configuration
const gameConfig = {
    debug: false,                 // Debug mode
    sceneSettings: {
        groundSize: 100,          // Size of the ground plane
        skyColor: 0x87CEEB,       // Sky color
        groundColor: 0x228B22     // Ground color
    },
    playerSettings: {
        startPosition: {
            x: 0,
            y: 1,
            z: 0
        },
        viewMode: 'firstPerson',   // 'firstPerson', 'thirdPerson', or 'freeRoam'
        // Use custom player name if provided in URL, otherwise generate random name
        playerName: urlParams.playerName || `Player_${Math.floor(Math.random() * 1000)}`,
        // Use custom player color if provided in URL
        playerColor: urlParams.playerColor || 0xFFFF00 // Default to yellow
    },
    networkSettings: {
        serverUrl: window.location.hostname.includes('localhost') 
            ? `ws://${window.location.hostname}:3000` // Local development
            : `wss://${window.location.hostname}`,    // Production
        roomName: 'active'       // Default active room
    }
};

// Store config globally for access by other modules
window.gameConfig = gameConfig;

// Main game initialization
function initGame() {
    console.log('Initializing 3D Game Platform...');
    
    // Display player name in loading screen if custom name provided
    if (urlParams.playerName) {
        const loadingStatus = document.getElementById('loading-status');
        loadingStatus.textContent = `Loading game engine for ${urlParams.playerName}...`;
    }
    
    // Load core modules
    loadCoreModules()
        .then(() => {
            // Initialize the game engine
            initGameEngine();
        })
        .catch(error => {
            console.error('Error initializing game:', error);
        });
}

// Load core platform modules
function loadCoreModules() {
    return new Promise((resolve, reject) => {
        try {
            console.log('Loading core modules...');
            
            // Create core module paths
            const corePath = 'js/core/';
            const coreModules = [
                'Entity.js',
                'Player.js',
                'NPC.js',
                'EntityFactory.js',
                'collision.js',
                'player-ui.js',
                'network-core.js',
                'controls.js'
            ];
            
            // Load each module in sequence
            let loadPromise = Promise.resolve();
            
            coreModules.forEach(module => {
                loadPromise = loadPromise.then(() => {
                    return loadScript(corePath + module);
                });
            });
            
            // Resolve when all core modules are loaded
            loadPromise.then(() => {
                console.log('Core modules loaded successfully');
                resolve();
            }).catch(error => {
                reject(error);
            });
        } catch (error) {
            reject(error);
        }
    });
}

// Initialize the main game engine
function initGameEngine() {
    console.log('Initializing game engine...');
    
    // Initialize default player factory first
    window.createPlayerEntity = function(scene, value = 1) {
        // Create a player with color from gameConfig
        const player = new window.Player({
            id: 'player',
            isLocalPlayer: true,
            color: gameConfig.playerSettings.playerColor
        });
        
        if (scene && player.mesh) {
            scene.add(player.mesh);
        }
        
        return player;
    };
    
    // Load default implementation
    loadScript('js/implementations/default/DefaultPlayer.js')
        .then(() => {
            // Load the game engine
            return loadScript('js/core/game-engine.js');
        })
        .then(() => {
            console.log('Game engine loaded');
            // Remove the loading screen once everything is loaded
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
            
            // Set isFirstPerson based on viewMode
            window.isFirstPerson = gameConfig.playerSettings.viewMode === 'firstPerson';
            window.viewMode = gameConfig.playerSettings.viewMode;
        })
        .catch(error => {
            console.error('Error loading game engine:', error);
        });
}

// Helper function to load a script asynchronously
function loadScript(src) {
    return new Promise((resolve, reject) => {
        // Check if this script has already been loaded
        if (document.querySelector(`script[src="${src}"]`)) {
            console.log(`Script already loaded: ${src}`);
            resolve();
            return;
        }
        
        const script = document.createElement('script');
        script.src = src;
        script.onload = () => resolve();
        script.onerror = (error) => reject(new Error(`Failed to load script: ${src}`));
        document.head.appendChild(script);
    });
}

// Start the game when the document is ready
document.addEventListener('DOMContentLoaded', initGame);  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\core\network-core.js 
===================================================== 
 

// Handles connection to the server and basic network setup

// Network configuration
const endpoint = 'ws://localhost:3000';
let client = null;
let room = null;

// Helper function to generate random colors
function getRandomColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

// Import CSS2D renderer for player names if not already defined
let CSS2DObject;
let CSS2DRenderer;
try {
    // First check if THREE.CSS2D is available (Three.js r137+)
    if (THREE.CSS2D) {
        console.log("Using THREE.CSS2D namespace");
        CSS2DObject = THREE.CSS2D.CSS2DObject;
        CSS2DRenderer = THREE.CSS2D.CSS2DRenderer;
    } 
    // For older Three.js versions
    else if (THREE.CSS2DObject && THREE.CSS2DRenderer) {
        console.log("Using THREE.CSS2DObject directly");
        CSS2DObject = THREE.CSS2DObject;
        CSS2DRenderer = THREE.CSS2DRenderer;
    } 
    else {
        throw new Error("CSS2D modules not found in THREE");
    }
} catch (error) {
    console.warn("CSS2DObject not available, player name labels will not be shown:", error.message);
    
    // Create dummy versions that do nothing to prevent errors
    CSS2DObject = class DummyCSS2DObject {
        constructor(element) {
            this.element = element;
            this.position = new THREE.Vector3();
            this.rotation = new THREE.Euler();
            this.scale = new THREE.Vector3(1, 1, 1);
            this.visible = true;
        }
    };
    
    CSS2DRenderer = class DummyCSS2DRenderer {
        constructor() {
            this.domElement = document.createElement('div');
        }
        setSize() {}
        render() {}
    };
}

// Global tracking of all visuals
const visuals = {
    players: {},
    operators: {},
    staticEntities: {},
    trees: {},
    rocks: {}
};

// Visual tracking containers
const visualTracking = {
    players: {},
    operators: {},
    staticEntities: {},
};

// Function to get color based on entity value
function getColorForValue(value) {
    // Default colors for values 1-10
    const colors = [
        '#FF0000', // 1 - Red
        '#FF7F00', // 2 - Orange
        '#FFFF00', // 3 - Yellow
        '#00FF00', // 4 - Green
        '#0000FF', // 5 - Blue
        '#4B0082', // 6 - Indigo
        '#8B00FF', // 7 - Violet
        '#964B00', // 8 - Brown
        '#808080', // 9 - Gray
        '#800080'  // 10 - Purple
    ];
    
    // Use value as index (adjusted for zero-based array)
    if (value >= 1 && value <= colors.length) {
        return colors[value - 1];
    }
    
    // Fall back to random color for higher values
    return getRandomColor();
}

// Setup automatic reconnection
function setupReconnection(room, client) {
    if (!room) return;
    
    // Handle WebSocket connection error
    room.onError((error) => {
        console.error("Connection error:", error);
        showErrorMessage("Connection error. Trying to reconnect...");
        addReconnectButton();
    });
    
    // Handle WebSocket disconnection
    room.onLeave((code) => {
        console.log(`Client left the room with code: ${code}`);
        showErrorMessage("Connection lost. Trying to reconnect...");
        
        // Attempt to reconnect automatically
        setTimeout(() => {
            console.log("Attempting to reconnect...");
            
            // Call initNetworking again
            initNetworking()
                .then(() => {
                    console.log("Reconnected successfully!");
                    showInfoMessage("Reconnected successfully!");
                    
                    // Remove reconnect button if it exists
                    const reconnectBtn = document.getElementById('reconnect-button');
                    if (reconnectBtn) {
                        reconnectBtn.remove();
                    }
                })
                .catch((e) => {
                    console.error("Failed to reconnect:", e);
                    showErrorMessage("Failed to reconnect. Please try again later.");
                });
        }, 2000);
    });
}

// Show error message
function showErrorMessage(message) {
    // Check if error message container exists
    let errorContainer = document.getElementById('error-message');
    
    // Create error container if it doesn't exist
    if (!errorContainer) {
        errorContainer = document.createElement('div');
        errorContainer.id = 'error-message';
        errorContainer.style.position = 'fixed';
        errorContainer.style.top = '10px';
        errorContainer.style.left = '50%';
        errorContainer.style.transform = 'translateX(-50%)';
        errorContainer.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
        errorContainer.style.color = 'white';
        errorContainer.style.padding = '10px';
        errorContainer.style.borderRadius = '5px';
        errorContainer.style.zIndex = '1000';
        errorContainer.style.transition = 'opacity 0.5s';
        document.body.appendChild(errorContainer);
    }
    
    // Set message
    errorContainer.textContent = message;
    errorContainer.style.opacity = '1';
    
    // Hide message after 5 seconds
    setTimeout(() => {
        errorContainer.style.opacity = '0';
    }, 5000);
}

// Show info message
function showInfoMessage(message) {
    // Check if info message container exists
    let infoContainer = document.getElementById('info-message');
    
    // Create info container if it doesn't exist
    if (!infoContainer) {
        infoContainer = document.createElement('div');
        infoContainer.id = 'info-message';
        infoContainer.style.position = 'fixed';
        infoContainer.style.top = '10px';
        infoContainer.style.left = '50%';
        infoContainer.style.transform = 'translateX(-50%)';
        infoContainer.style.backgroundColor = 'rgba(0, 128, 0, 0.8)';
        infoContainer.style.color = 'white';
        infoContainer.style.padding = '10px';
        infoContainer.style.borderRadius = '5px';
        infoContainer.style.zIndex = '1000';
        infoContainer.style.transition = 'opacity 0.5s';
        document.body.appendChild(infoContainer);
    }
    
    // Set message
    infoContainer.textContent = message;
    infoContainer.style.opacity = '1';
    
    // Hide message after 3 seconds
    setTimeout(() => {
        infoContainer.style.opacity = '0';
    }, 3000);
}

// Add reconnect button
function addReconnectButton() {
    // Check if reconnect button already exists
    if (document.getElementById('reconnect-button')) {
        return;
    }
    
    // Create button
    const reconnectBtn = document.createElement('button');
    reconnectBtn.id = 'reconnect-button';
    reconnectBtn.textContent = 'Reconnect to Server';
    reconnectBtn.style.position = 'fixed';
    reconnectBtn.style.top = '50%';
    reconnectBtn.style.left = '50%';
    reconnectBtn.style.transform = 'translate(-50%, -50%)';
    reconnectBtn.style.padding = '10px 20px';
    reconnectBtn.style.backgroundColor = '#4CAF50';
    reconnectBtn.style.color = 'white';
    reconnectBtn.style.border = 'none';
    reconnectBtn.style.borderRadius = '5px';
    reconnectBtn.style.cursor = 'pointer';
    reconnectBtn.style.zIndex = '1000';
    reconnectBtn.style.fontSize = '16px';
    
    // Add hover effect
    reconnectBtn.onmouseover = function() {
        this.style.backgroundColor = '#45a049';
    };
    
    reconnectBtn.onmouseout = function() {
        this.style.backgroundColor = '#4CAF50';
    };
    
    // Add click handler
    reconnectBtn.onclick = function() {
        console.log("Reconnect button clicked");
        this.textContent = 'Connecting...';
        this.disabled = true;
        
        // Try to reconnect
        initNetworking()
            .then(() => {
                console.log("Reconnected successfully!");
                this.remove();
            })
            .catch((e) => {
                console.error("Failed to reconnect:", e);
                this.textContent = 'Reconnect to Server';
                this.disabled = false;
                showErrorMessage("Failed to reconnect. Please try again.");
            });
    };
    
    // Add to body
    document.body.appendChild(reconnectBtn);
}

// Function to initialize networking for multiplayer
async function initNetworking() {
    // Get endpoint from gameConfig if available, or use default
    const endpoint = window.gameConfig?.networkSettings?.serverUrl || "ws://localhost:3000";
    // Get room name from gameConfig if available, or use default
    const roomName = window.gameConfig?.networkSettings?.roomName || "default";
    
    console.log("Initializing networking system...");
    
    try {
        console.log(`Connecting to Colyseus server at: ${endpoint}`);
        
        // Create client if needed
        if (!client) {
            try {
                client = new Colyseus.Client(endpoint);
                console.log("Colyseus client created");
            } catch (clientError) {
                console.error("Failed to create Colyseus client:", clientError);
                throw new Error(`Failed to create client: ${clientError.message}`);
            }
        }
        
        // Try to join the room
        try {
            console.log(`Attempting to join room: ${roomName}`);
            room = await client.joinOrCreate(roomName, {
                name: `Player_${Math.floor(Math.random() * 1000)}`,
                color: getRandomColor()
            });
            console.log(`Joined room successfully: ${room.name}`);
            
            // Store room in global scope
            window.room = room;
            
            // Initialize object collections - use a single source of truth
            window.otherPlayers = {};
            window.operators = {};
            window.staticEntities = {};
            window.trees = {};
            window.rocks = {};
            
            // Setup message handlers
            setupMessageHandlers();
            
            // Setup automatic reconnection
            setupReconnection(room, client);
            
            // Wait for the initial state before setting up listeners
            room.onStateChange.once((state) => {
                console.log("Initial state received:", state);
                setupRoomListeners(room);
                setupRoomPlayerListeners(room);
                
                // Register updateRemotePlayers with the animation loop
                if (typeof window.registerAnimationCallback === 'function') {
                    window.registerAnimationCallback(window.updateRemotePlayers);
                    console.log("Registered updateRemotePlayers with animation loop");
                } else {
                    // Set up a fallback timer if animation callback registration is not available
                    console.log("Setting up fallback timer for remote player updates");
                    window.playerUpdateInterval = setInterval(window.updateRemotePlayers, 1000/60); // 60fps
                }
                
                // Explicitly create local player object
                window.myPlayer = new Player({ 
                    id: window.room.sessionId, 
                    isLocalPlayer: true,
                    value: 1, 
                    color: "#FFFF00"
                });
                console.log("Local player created and linked to existing entity mesh:", window.myPlayer);
                
                if (typeof animate === 'function') {
                    animate();
                }
                window.dispatchEvent(new CustomEvent('avatarReady'));
            });
            
            return room;
        } catch (roomError) {
            console.error("Error joining room:", roomError);
            throw roomError;
        }
    } catch (error) {
        console.error("Error connecting to server:", error);
        throw error;
    }
}

// Setup message handlers
function setupMessageHandlers() {
    if (!room) return;
    
    // Listen for custom messages from the server
    room.onMessage("player-collision", (message) => {
        console.log("Collision message received:", message);
        
        // Update player value if needed
        if (window.player && window.player.value !== undefined && message.newValue) {
            window.player.value = message.newValue;
            
            // Update HUD
            if (window.updateHUD) {
                window.updateHUD();
            }
        }
    });
    
    room.onMessage("server-event", (message) => {
        console.log("Server event received:", message);
        // Process server events if needed
    });
}

// Send player collision message
function sendPlayerCollision(targetId) {
    if (!room) return;
    
    room.send("player-collision", { targetId: targetId });
}

// Player joined callback
function onPlayerJoin(player) {
    console.log(`Player joined! ID: ${player.sessionId}`);
    
    // If it's our own join, update the interface
    if (player.sessionId === room.sessionId) {
        console.log("This is us joining!");
        
        // Set initial player values on the server
        player.name = window.playerName || "Player";
        player.color = window.playerColor || "#3366cc";
        
        // Show multiplayer notification
        showInfoMessage("Connected to multiplayer server!");
    } else {
        console.log(`Other player joined: ${player.name || "Unnamed player"}`);
        
        // Create a new entity for this player
        createRemotePlayerObject(player);
    }
    
    // Update the player list in the UI
    updatePlayerListUI();
}

// Create 3D object for remote player
function createRemotePlayerObject(player) {
    // Validate that the player object and sessionId exist
    if (!player || !player.sessionId) {
        console.error("Invalid player data received - missing sessionId:", player);
        return null;
    }
    
    if (!window.scene) {
        console.error("Scene not available to create remote player object");
        return null;
    }
    
    console.log("Creating remote player:", player);
    
    try {
        // Create a player object for the remote player
        // Use DefaultPlayer if available, otherwise fallback to base Player
        const PlayerClass = window.DefaultPlayer || window.Player;
        const remotePlayer = new PlayerClass({
            id: player.sessionId,  // Use the sessionId as the id
            isLocalPlayer: false,
            color: player.color || 0x3366CC,
            value: player.value || 1
        });
        
        // Set position and rotation
        remotePlayer.mesh.position.set(player.x || 0, player.y || 0, player.z || 0);
        remotePlayer.mesh.rotation.y = player.rotationY || 0;
        
        // Add to scene
        window.scene.add(remotePlayer.mesh);
        
        // Store in global collections - use otherPlayers as the single source of truth
        window.otherPlayers = window.otherPlayers || {};
        window.otherPlayers[player.sessionId] = remotePlayer;
        
        // Also store in visuals collection
        window.visuals = window.visuals || {};
        window.visuals.players = window.visuals.players || {};
        window.visuals.players[player.sessionId] = remotePlayer;
        
        console.log(`Created remote player object for ${player.sessionId}`);
        return remotePlayer;
    } catch (error) {
        console.error("Failed to create remote player:", error);
        return null;
    }
}

// Player left callback
function onPlayerLeave(player) {
    // Validate player data
    if (!player || !player.sessionId) {
        console.error("Invalid player in onPlayerLeave:", player);
        return;
    }
    
    console.log(`Player left: ${player.sessionId}`);
    
    try {
        // Remove player from the scene - check multiple collections
        // Check otherPlayers collection
        if (window.otherPlayers && window.otherPlayers[player.sessionId]) {
            console.log(`Removing player from otherPlayers: ${player.sessionId}`);
            
            // Remove mesh from scene
            if (window.scene && window.otherPlayers[player.sessionId].mesh) {
                window.scene.remove(window.otherPlayers[player.sessionId].mesh);
            }
            
            // Delete player object
            delete window.otherPlayers[player.sessionId];
        }
        
        // Also check visuals.players collection
        if (window.visuals && window.visuals.players && window.visuals.players[player.sessionId]) {
            console.log(`Removing player from visuals: ${player.sessionId}`);
            
            // Remove mesh from scene if not already removed
            if (window.scene && window.visuals.players[player.sessionId].mesh) {
                window.scene.remove(window.visuals.players[player.sessionId].mesh);
            }
            
            // Delete from visuals
            delete window.visuals.players[player.sessionId];
        }
        
        // Update the player list in the UI
        if (window.playerUI && typeof window.playerUI.updatePlayerListUI === 'function') {
            window.playerUI.updatePlayerListUI();
        } else {
            updatePlayerListUI();
        }
    } catch (error) {
        console.error("Error removing player:", error);
    }
}

// Update player list UI
window.updatePlayerListUI = function() {
    const playerListElement = document.getElementById('player-list');
    if (!playerListElement) return;
    
    // Clear current list
    playerListElement.innerHTML = '';
    
    // Ensure room and state are available
    if (!window.room || !window.room.state) {
        playerListElement.innerHTML = '<li>Not connected to server</li>';
        return;
    }
    
    // Add each player to the list
    window.room.state.players.forEach((player, key) => {
        const playerElement = document.createElement('li');
        
        // Highlight current player
        if (key === window.room.sessionId) {
            playerElement.classList.add('current-player');
        }
        
        // Show player info
        playerElement.innerHTML = `
            <span class="player-name">${player.name || 'Unnamed'}</span>
            <span class="player-value">${player.value || 1}</span>
        `;
        
        // Add to list
        playerListElement.appendChild(playerElement);
    });
};

// Update remote players in the scene - this runs in the animation loop
window.updateRemotePlayers = function() {
    if (!window.room || !window.room.state || !window.scene) {
        return;
    }
    
    // Debug log periodically to confirm this is running
    if (Math.random() < 0.001) {
        console.log("updateRemotePlayers running, player count:", window.room.state.players.size);
    }
    
    // First, collect all valid sessionIds from the server
    const serverPlayerIds = new Set();
    window.room.state.players.forEach((player, sessionId) => {
        if (sessionId && sessionId !== window.room.sessionId) {
            serverPlayerIds.add(sessionId);
        }
    });
    
    // Now process each player from the server
    window.room.state.players.forEach((player, sessionId) => {
        // Skip local player and invalid sessionIds
        if (!sessionId || sessionId === window.room.sessionId) return;
        
        // Create remote player object if it doesn't exist
        if (!window.otherPlayers || !window.otherPlayers[sessionId]) {
            console.log(`Creating missing remote player: ${sessionId}`);
            // Ensure we pass the sessionId in the player object
            const playerWithId = {
                ...player,
                sessionId: sessionId  // Explicitly set the sessionId
            };
            createRemotePlayerObject(playerWithId);
            return;
        }
        
        // Update remote player position and rotation using otherPlayers collection
        const remotePlayer = window.otherPlayers[sessionId];
        if (remotePlayer && remotePlayer.mesh) {
            // Update position with smooth lerping
            const lerpFactor = 0.3; // Smoothing factor for remote player movement
            
            remotePlayer.mesh.position.x = THREE.MathUtils.lerp(
                remotePlayer.mesh.position.x, 
                player.x, 
                lerpFactor
            );
            
            remotePlayer.mesh.position.y = THREE.MathUtils.lerp(
                remotePlayer.mesh.position.y, 
                player.y, 
                lerpFactor
            );
            
            remotePlayer.mesh.position.z = THREE.MathUtils.lerp(
                remotePlayer.mesh.position.z, 
                player.z, 
                lerpFactor
            );
            
            // Update rotation
            remotePlayer.mesh.rotation.y = player.rotationY;
            
            
            if (remotePlayer.value !== player.value) {
                try {
                    // Remove old mesh
                    if (remotePlayer.mesh.parent) {
                        remotePlayer.mesh.parent.remove(remotePlayer.mesh);
                    }
                    
                    // Create new entity with updated value
                    const newPlayerEntity = new PlayerEntity(player.value);
                    newPlayerEntity.id = sessionId;
                    newPlayerEntity.mesh.position.copy(remotePlayer.mesh.position);
                    newPlayerEntity.mesh.rotation.y = remotePlayer.mesh.rotation.y;
                    
                    // Add to scene
                    window.scene.add(newPlayerEntity.mesh);
                    
                    // Update reference in otherPlayers collection
                    window.otherPlayers[sessionId] = newPlayerEntity;
                    // Also update in visuals collection
                    if (window.visuals && window.visuals.players) {
                        window.visuals.players[sessionId] = newPlayerEntity;
                    }
                } catch (error) {
                    console.error("Error updating player value:", error);
                }
            }
        }
    });
    
    // Check for players in otherPlayers that no longer exist in the server state
    if (window.otherPlayers) {
        for (const sessionId in window.otherPlayers) {
            // Validate sessionId to avoid issues with undefined
            if (!sessionId || sessionId === "undefined") {
                console.error("Invalid sessionId in otherPlayers:", sessionId);
                delete window.otherPlayers[sessionId];
                continue;
            }
            
            // Check if this player still exists on the server
            if (!serverPlayerIds.has(sessionId)) {
                console.log(`Removing stale player: ${sessionId}`);
                onPlayerLeave({ sessionId: sessionId });
            }
        }
    }
};

// Setup room-level listeners specifically for Players
function setupRoomPlayerListeners(room) {
    if (!room || !room.state) {
        console.warn('[setupRoomPlayerListeners] Room or state not available yet.');
        return;
    }

    console.log('[setupRoomPlayerListeners] Setting up player listeners...');
    console.log('[setupRoomPlayerListeners] Current state structure:', Object.keys(room.state));
    console.log('[setupRoomPlayerListeners] Players collection exists:', !!room.state.players);
    
    if (room.state.players) {
        console.log('[setupRoomPlayerListeners] Current player count:', room.state.players.size);
        
        // Process existing players
        console.log('[setupRoomPlayerListeners] Processing existing players');
        room.state.players.forEach((player, sessionId) => {
            // Skip players without valid sessionId or local player
            if (!sessionId || sessionId === room.sessionId) return;
            
            console.log(`Setting up existing player: ${sessionId}`, player);
            
            // Create remote player for other players
            createRemotePlayerObject({...player, sessionId: sessionId});
        });
        
        // Update UI immediately to show all players
        if (window.playerUI && typeof window.playerUI.updatePlayerListUI === 'function') {
            window.playerUI.updatePlayerListUI();
        } else {
            updatePlayerListUI();
        }
        
        // Listen for player added events
        room.state.players.onAdd = (player, sessionId) => {
            // Skip invalid sessionIds or local player
            if (!sessionId || sessionId === room.sessionId) return;
            
            console.log(`Player added: ${sessionId}`, player);
            
            // Ensure the player object has a sessionId field
            const playerWithId = {...player, sessionId: sessionId};
            
            // Create remote player object
            createRemotePlayerObject(playerWithId);
            
            // Update UI
            if (window.playerUI && typeof window.playerUI.updatePlayerListUI === 'function') {
                window.playerUI.updatePlayerListUI();
            } else {
                updatePlayerListUI();
            }
        };
        
        // Listen for player removed events
        room.state.players.onRemove = (player, sessionId) => {
            // Skip invalid sessionIds or local player
            if (!sessionId || sessionId === room.sessionId) return;
            
            console.log(`Player removed: ${sessionId}`);
            
            // Remove player
            onPlayerLeave({ sessionId: sessionId });
            
            // Update UI
            if (window.playerUI && typeof window.playerUI.updatePlayerListUI === 'function') {
                window.playerUI.updatePlayerListUI();
            } else {
                updatePlayerListUI();
            }
        };
        
        // Listen for player changes
        room.state.players.onChange = (player, sessionId) => {
            // Skip invalid sessionIds or local player
            if (!sessionId || sessionId === room.sessionId) return;
            
            // For debugging
            if (Math.random() < 0.01) {
                console.log(`Player changed: ${sessionId}, pos: (${player.x.toFixed(2)}, ${player.y.toFixed(2)}, ${player.z.toFixed(2)})`);
            }
            
            // Update remote player - using otherPlayers consistently
            if (window.otherPlayers && window.otherPlayers[sessionId]) {
                // Update position with lerping for smooth movement
                const remotePlayer = window.otherPlayers[sessionId];
                const lerpFactor = 0.3; // Adjust for smoother/faster movement
                
                if (remotePlayer && remotePlayer.mesh) {
                    // Update position with lerping
                    remotePlayer.mesh.position.x = THREE.MathUtils.lerp(
                        remotePlayer.mesh.position.x,
                        player.x,
                        lerpFactor
                    );
                    
                    remotePlayer.mesh.position.y = THREE.MathUtils.lerp(
                        remotePlayer.mesh.position.y,
                        player.y,
                        lerpFactor
                    );
                    
                    remotePlayer.mesh.position.z = THREE.MathUtils.lerp(
                        remotePlayer.mesh.position.z,
                        player.z,
                        lerpFactor
                    );
                    
                    // Update rotation (no lerping for simplicity)
                    remotePlayer.mesh.rotation.y = player.rotationY;
                    
                    // Update player info in UI periodically
                    if (Math.random() < 0.01) { // Only update UI occasionally to save performance
                        if (window.playerUI && typeof window.playerUI.updatePlayerListUI === 'function') {
                            window.playerUI.updatePlayerListUI();
                        } else {
                            updatePlayerListUI();
                        }
                    }
                }
            } else {
                // If player exists in server state but not in otherPlayers, create it
                console.log(`Creating missing player from onChange: ${sessionId}`);
                createRemotePlayerObject({...player, sessionId: sessionId});
            }
        };
    } else {
        console.error('[setupRoomPlayerListeners] state.players not found!');
    }
    
    console.log('[setupRoomPlayerListeners] Room player listeners setup complete');
}

// Setup entity listeners for the room
function setupRoomListeners(room) {
    if (!room || !room.state) {
        console.error('[setupRoomListeners] Room or state not available');
        return;
    }
    
    console.log('[setupRoomListeners] Setting up entity listeners');
    
    // Ensure visuals collections exist
    window.visuals = window.visuals || {};
    window.visuals.operators = window.visuals.operators || {};
    window.visuals.staticEntities = window.visuals.staticEntities || {};
    
    // Check for entities collection
    if (room.state.entities) {
        console.log('[setupRoomListeners] Processing entities:', room.state.entities.size);
        
        // Process existing entities
        room.state.entities.forEach((entity, entityId) => {
            console.log(`Processing entity: ${entityId}, type: ${entity.type}`);
            
            // Handle different entity types
            if (entity.type === 'operator') {
                if (typeof window.createOperatorVisual === 'function') {
                    window.createOperatorVisual(entity, entityId);
                }
            } else if (entity.type === 'staticValueEntity') {
                if (typeof window.createStaticEntityVisual === 'function') {
                    window.createStaticEntityVisual(entity, entityId);
                }
            }
        });
        
        // Listen for entity added events
        if (typeof room.state.entities.onAdd === 'function') {
            room.state.entities.onAdd = (entity, entityId) => {
                console.log(`Entity added: ${entityId}, type: ${entity.type}`);
                
                // Handle different entity types
                if (entity.type === 'operator') {
                    if (typeof window.createOperatorVisual === 'function') {
                        window.createOperatorVisual(entity, entityId);
                    }
                } else if (entity.type === 'staticValueEntity') {
                    if (typeof window.createStaticEntityVisual === 'function') {
                        window.createStaticEntityVisual(entity, entityId);
                    }
                }
            };
        }
        
        // Listen for entity removed events
        if (typeof room.state.entities.onRemove === 'function') {
            room.state.entities.onRemove = (entity, entityId) => {
                console.log(`Entity removed: ${entityId}, type: ${entity.type}`);
                
                // Handle different entity types
                if (entity.type === 'operator') {
                    if (typeof window.removeOperatorVisual === 'function') {
                        window.removeOperatorVisual(entityId);
                    }
                } else if (entity.type === 'staticValueEntity') {
                    if (typeof window.removeStaticEntityVisual === 'function') {
                        window.removeStaticEntityVisual(entityId);
                    }
                }
            };
        }
    } else {
        console.log('[setupRoomListeners] No entities collection found');
    }
    
    console.log('[setupRoomListeners] Entity listeners setup complete');
}

// Clean up network resources when leaving
window.cleanupNetworking = function() {
    console.log("Cleaning up network resources");
    
    // Clear the player update interval if it exists
    if (window.playerUpdateInterval) {
        clearInterval(window.playerUpdateInterval);
        window.playerUpdateInterval = null;
    }
    
    // Unregister updateRemotePlayers if it was registered with the animation loop
    if (typeof window.unregisterAnimationCallback === 'function' && 
        typeof window.updateRemotePlayers === 'function') {
        window.unregisterAnimationCallback(window.updateRemotePlayers);
    }
    
    // Clean up other players
    if (window.otherPlayers) {
        for (const sessionId in window.otherPlayers) {
            if (sessionId) {  // Skip undefined keys
                try {
                    if (window.scene && window.otherPlayers[sessionId] && window.otherPlayers[sessionId].mesh) {
                        window.scene.remove(window.otherPlayers[sessionId].mesh);
                    }
                } catch (error) {
                    console.error(`Error removing player ${sessionId} from scene:`, error);
                }
            }
        }
        window.otherPlayers = {};
    }
    
    // Clean up visuals
    if (window.visuals && window.visuals.players) {
        window.visuals.players = {};
    }
    
    // Leave the room if connected
    if (window.room) {
        try {
            window.room.leave();
        } catch (error) {
            console.error("Error leaving room:", error);
        }
        window.room = null;
    }
    
    // Reset client
    client = null;
    room = null;
    
    console.log("Network resources cleaned up successfully");
};

// Make functions available globally
window.initNetworking = initNetworking;
window.setupMessageHandlers = setupMessageHandlers;
window.sendPlayerCollision = sendPlayerCollision;
window.getRandomColor = getRandomColor;
window.getColorForValue = getColorForValue;
window.CSS2DObject = CSS2DObject;
window.CSS2DRenderer = CSS2DRenderer;
window.onPlayerJoin = onPlayerJoin;
window.onPlayerLeave = onPlayerLeave;
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\core\NPC.js 
===================================================== 
 
// 3D AI Game Platform - Core NPC entity class

class NPC extends Entity {
    constructor(params) {
        super(params);
        
        // NPC-specific properties
        this.isStatic = params.isStatic || false;
        this.behaviorType = params.behaviorType || 'static';
        this.target = params.target || null;
        
        // Animation properties - base implementation
        this.animationState = {
            floating: {
                enabled: !this.isStatic,
                height: 0.5,
                speed: 1.0,
                time: Math.random() * Math.PI * 2 // Random start phase
            },
            rotating: {
                enabled: false,
                speed: 0.5
            }
        };
        
        // Set initial animation state
        this.setupAnimation();
    }
    
    setupAnimation() {
        // Only set up animation for non-static NPCs
        if (this.isStatic) {
            this.animationState.floating.enabled = false;
            this.animationState.rotating.enabled = false;
        }
    }
    
    // Base animation method - can be extended by implementations
    animate(deltaTime) {
        if (!this.mesh) return;
        
        // Handle floating animation
        if (this.animationState.floating.enabled) {
            this.animationState.floating.time += deltaTime * this.animationState.floating.speed;
            const floatHeight = Math.sin(this.animationState.floating.time) * this.animationState.floating.height;
            
            // Apply floating motion
            this.mesh.position.y = this.y + floatHeight;
        }
        
        // Handle rotation animation (if enabled)
        if (this.animationState.rotating.enabled) {
            this.mesh.rotation.y += this.animationState.rotating.speed * deltaTime;
        }
    }
    
    // Update position and also handle any animations
    updatePosition(position) {
        super.updatePosition(position);
        
        // Re-enable animations if needed
        this.setupAnimation();
    }
    
    // Base createMesh method - should be overridden by implementation-specific NPC classes
    createMesh() {
        console.warn("createMesh() method not implemented in NPC base class");
        
        // Create a simple placeholder mesh
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({ color: this.color || 0xFFFFFF });
        return new THREE.Mesh(geometry, material);
    }

    // Base methods for updating value and color - to be overridden by implementations
    updateValue(newValue) {
        super.updateValue(newValue);
    }

    updateColor(newColor) {
        super.updateColor(newColor);
    }
    
    // NPCs can have behavior in their update method
    update(deltaTime) {
        // Implement different behaviors
        switch (this.behaviorType) {
            case 'idle':
                // Do nothing
                break;
                
            case 'wander':
                // Random movement could be implemented by subclasses
                break;
                
            case 'follow':
                // Follow logic could be implemented by subclasses
                break;
        }
        
        // Animate the NPC
        this.animate(deltaTime);
    }
}

// Export the NPC class
if (typeof window !== 'undefined') {
    window.NPC = NPC;
}

if (typeof module !== 'undefined') {
    module.exports = { NPC };
}  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\core\player-ui.js 
===================================================== 
 
// 3D AI Game Platform - Player UI module
// Handles player list UI and related functionality

class PlayerUI {
    constructor() {
        this.initialized = false;
    }
    
    // Initialize the player UI
    init() {
        if (this.initialized) return;
        
        this.initPlayerListState();
        this.setupPlayerListKeyControls();
        this.initialized = true;
    }
    
    // Update player list in UI
    updatePlayerListUI() {
        // Get player list container
        const playerList = document.getElementById('player-list');
        if (!playerList) {
            console.warn("Player list element not found");
            this.createPlayerListUI(); // Create if missing
            return;
        }
        
        try {
            // Clear current list
            playerList.innerHTML = '';
            
            let playerCount = 0;
            
            // Add myself first if available
            if (window.room && window.room.state && window.room.state.players) {
                try {
                    const mySessionId = window.room.sessionId;
                    let myPlayer = null;
                    
                    // Try different methods to get the player data
                    if (typeof window.room.state.players.get === 'function') {
                        myPlayer = window.room.state.players.get(mySessionId);
                    } else if (window.room.state.players[mySessionId]) {
                        myPlayer = window.room.state.players[mySessionId];
                    }
                    
                    if (myPlayer) {
                        this.addPlayerToList(myPlayer, mySessionId, true);
                        playerCount++;
                    } else if (window.playerEntity) {
                        // Show connected player UI
                        this.updatePlayerUI({
                            value: window.playerEntity.value || 1,
                            color: window.playerEntity.color || "#FFFF00"
                        });
                        playerCount++;
                    }
                    
                    // Log for debugging
                    console.log("Added local player to list. Players map size:", window.room.state.players.size);
                    
                    // Add other players - directly iterate over the Schema MapSchema
                    window.room.state.players.forEach((player, sessionId) => {
                        if (sessionId !== mySessionId) {
                            this.addPlayerToList(player, sessionId, false);
                            playerCount++;
                            console.log("Added remote player to list:", sessionId, player);
                        }
                    });
                } catch (e) {
                    console.error("Error iterating through players:", e);
                }
            }
            
            // Update player count in UI
            const playerCountElement = document.getElementById('player-count');
            if (playerCountElement) {
                playerCountElement.textContent = `(${playerCount})`;
            }
        } catch (error) {
            console.error("Error updating player list UI:", error);
        }
    }

    // Helper function to add a player to the list UI
    addPlayerToList(player, sessionId, isCurrentPlayer) {
        if (!player) return;
        
        try {
            // Get player list element
            const playerList = document.getElementById('player-list');
            if (!playerList) return;
            
            // Create player entry
            const playerEntry = document.createElement('div');
            playerEntry.className = 'player-entry';
            playerEntry.id = `player-${sessionId}`;
            
            // Add highlighting for current player
            if (isCurrentPlayer) {
                playerEntry.style.fontWeight = 'bold';
                playerEntry.style.backgroundColor = 'rgba(255,255,255,0.2)';
            }
            
            // Create color indicator
            const colorIndicator = document.createElement('div');
            colorIndicator.className = 'player-color';
            colorIndicator.style.backgroundColor = player.color || '#FFFFFF';
            
            // Create player info
            const playerInfo = document.createElement('div');
            playerInfo.className = 'player-info';
            
            // Format player name with value
            const playerName = player.name || `Player ${sessionId.substring(0, 4)}`;
            const playerValue = player.value || 1;
            playerInfo.textContent = `${playerName} (${playerValue})`;
            
            // Build entry
            playerEntry.appendChild(colorIndicator);
            playerEntry.appendChild(playerInfo);
            playerList.appendChild(playerEntry);
        } catch (error) {
            console.error("Error adding player to UI list:", error);
        }
    }

    // Set up key event listeners for player list toggle
    setupPlayerListKeyControls() {
        // Toggle player list on 'Tab' key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Tab') {
                event.preventDefault(); // Prevent default tab behavior
                this.togglePlayerList();
            }
        });
        
        // Set up click listener for header
        const playerListHeader = document.getElementById('player-list-header');
        if (playerListHeader) {
            playerListHeader.addEventListener('click', () => this.togglePlayerList());
        }
    }

    // Function to toggle player list visibility
    togglePlayerList() {
        const playerList = document.getElementById('player-list');
        const collapseIcon = document.getElementById('collapse-icon');
        
        if (!playerList || !collapseIcon) return;
        
        // Check current state
        const isCollapsed = playerList.style.display === 'none';
        
        // Toggle display
        playerList.style.display = isCollapsed ? 'block' : 'none';
        
        // Update icon
        collapseIcon.textContent = isCollapsed ? '▼' : '▶';
        
        // Save state in localStorage
        localStorage.setItem('playerListCollapsed', !isCollapsed);
    }

    // Initialize player list state from saved preference
    initPlayerListState() {
        try {
            // Get saved state
            const isCollapsed = localStorage.getItem('playerListCollapsed') === 'true';
            
            // Get elements
            const playerList = document.getElementById('player-list');
            const collapseIcon = document.getElementById('collapse-icon');
            
            if (playerList && collapseIcon) {
                // Set initial state
                playerList.style.display = isCollapsed ? 'none' : 'block';
                collapseIcon.textContent = isCollapsed ? '▶' : '▼';
            }
        } catch (error) {
            console.warn("Error initializing player list state:", error);
        }
    }
    
    // Create the player list UI elements if they don't exist
    createPlayerListUI() {
        // Check if player list UI already exists
        if (document.getElementById('player-list-container')) {
            return;
        }
        
        // Create container
        const container = document.createElement('div');
        container.id = 'player-list-container';
        container.className = 'ui-panel';
        
        // Create header
        const header = document.createElement('div');
        header.id = 'player-list-header';
        header.className = 'ui-panel-header';
        header.innerHTML = '<span id="collapse-icon">▼</span> Players <span id="player-count">(0)</span>';
        
        // Create list
        const list = document.createElement('div');
        list.id = 'player-list';
        list.className = 'ui-panel-content';
        
        // Build UI
        container.appendChild(header);
        container.appendChild(list);
        
        // Add to document
        document.body.appendChild(container);
        
        // Initialize state
        this.initPlayerListState();
    }
}

// Create and export a singleton instance
const playerUI = new PlayerUI();

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.PlayerUI = PlayerUI;
    window.playerUI = playerUI;
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        playerUI.init();
    });
}

if (typeof module !== 'undefined') {
    module.exports = { PlayerUI, playerUI };
}  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\core\Player.js 
===================================================== 
 
// 3D AI Game Platform - Core Player entity class

class Player extends Entity {
    constructor(params) {
        super(params);
        this.isPlayer = true;
        this.isLocalPlayer = params.isLocalPlayer || false;
        
        // Player-specific properties
        this.moveSpeed = params.moveSpeed || 5.0;
        this.jumpHeight = params.jumpHeight || 5.0;
        this.isJumping = false;
        this.isColliding = false;
        this.controls = null;
        
        // Create the player mesh if not already created
        if (!this.mesh && window.createPlayerEntity && window.scene) {
            this.value = params.value || 1;
            this.color = params.color || "#FFFF00";
            
            // Use createPlayerEntity function if available
            const playerEntity = window.createPlayerEntity(window.scene, this.value);
            if (playerEntity) {
                this.mesh = playerEntity.mesh;
                this.group = playerEntity.group;
            }
            
            // Apply color if specified
            if (playerEntity && playerEntity.updateColor && this.color) {
                playerEntity.updateColor(this.color);
            }
        }
        
        // This will be overridden in implementation-specific player classes
        if (this.isLocalPlayer && this.initLocalPlayer) {
            this.initLocalPlayer();
        }
    }
    
    // For local player, position is controlled by PointerLockControls
    // For remote players, position is updated via network
    updatePosition(position) {
        // Only update remote players via network updates
        if (!this.isLocalPlayer && this.mesh) {
            super.updatePosition(position);
        }
    }
    
    // Base method for creating player camera - to be implemented by subclasses
    createPlayerCamera() {
        if (this.isLocalPlayer) {
            console.warn("createPlayerCamera() method not implemented in Player base class");
        }
    }
    
    // Base method for handling player input - to be implemented by subclasses
    handleInput(inputState) {
        if (this.isLocalPlayer) {
            console.warn("handleInput() method not implemented in Player base class");
        }
    }
    
    // Base createMesh method - should be overridden by implementation-specific player classes
    createMesh() {
        // Create a simple box player
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({ 
            color: this.color || 0xFFFF00,
            roughness: 0.7,
            metalness: 0.2
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        // Add shadow casting
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        return mesh;
    }

    // Base methods for updating value and color - to be overridden by implementations
    updateValue(newValue) {
        super.updateValue(newValue);
    }

    updateColor(newColor) {
        super.updateColor(newColor);
    }
}

// Make available globally
window.Player = Player;

// Export for use in other modules
if (typeof module !== 'undefined') {
    module.exports = { Player };
}  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\implementations\default\DefaultPlayer.js 
===================================================== 
 
// Default Implementation - Player class
// Simple player with a box representation

class DefaultPlayer extends Player {
    constructor(params) {
        super(params);
        
        // Use color from params, gameConfig, or fallback to default blue
        this.color = params.color || 
                     (window.gameConfig && window.gameConfig.playerSettings.playerColor) || 
                     0x3366CC;
    }
    
    // Create a simple box mesh
    createMesh() {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({ 
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        return mesh;
    }
    
    // Override update function for any player-specific logic
    update(deltaTime) {
        // Any default player-specific update logic goes here
        
        // Always call the parent update function
        super.update(deltaTime);
    }
}

// Register this class with the entity factory if available
if (window.entityFactory) {
    window.entityFactory.registerType('defaultPlayer', DefaultPlayer);
}

// Make available globally
if (typeof window !== 'undefined') {
    window.DefaultPlayer = DefaultPlayer;
}

if (typeof module !== 'undefined') {
    module.exports = { DefaultPlayer };
}  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\implementations\numberblocks\entity-sync.js 
===================================================== 
 
// Numberblocks - Entity synchronization module
// Handles entity synchronization (operators, static numberblocks)

// Global tracking of all visuals 
window.visuals = window.visuals || {};
window.visuals.operators = window.visuals.operators || {};
window.visuals.staticNumberblocks = window.visuals.staticNumberblocks || {};

// Helper functions for visual management
function createOperatorVisual(operator, operatorId) {
    try {
        const visual = new OperatorsVisual(operator);
        window.visuals.operators[operatorId] = visual;
        
        if (window.scene) {
            window.scene.add(visual.group || visual.mesh);
        }
        
        // Setup change listener if available
        if (operator.onChange) {
            operator.onChange(() => {
                if (window.visuals.operators[operatorId]) {
                    window.visuals.operators[operatorId].update(operator);
                }
            });
        }
    } catch (error) {
        console.error(`Error creating operator visual (${operatorId}):`, error);
    }
}

function removeOperatorVisual(operatorId) {
    try {
        if (window.visuals.operators && window.visuals.operators[operatorId]) {
            if (window.scene) {
                window.scene.remove(window.visuals.operators[operatorId].group || 
                                  window.visuals.operators[operatorId].mesh);
            }
            delete window.visuals.operators[operatorId];
        }
    } catch (error) {
        console.error(`Error removing operator visual (${operatorId}):`, error);
    }
}

function createStaticNumberblockVisual(block, blockId) {
    try {
        const visual = new StaticNumberblocksVisual(block);
        window.visuals.staticNumberblocks[blockId] = visual;
        
        if (window.scene) {
            window.scene.add(visual.group || visual.mesh);
        }
        
        // Setup change listener if available
        if (block.onChange) {
            block.onChange(() => {
                if (window.visuals.staticNumberblocks[blockId]) {
                    window.visuals.staticNumberblocks[blockId].update(block);
                }
            });
        }
    } catch (error) {
        console.error(`Error creating static numberblock visual (${blockId}):`, error);
    }
}

function removeStaticNumberblockVisual(blockId) {
    try {
        if (window.visuals.staticNumberblocks && window.visuals.staticNumberblocks[blockId]) {
            if (window.scene) {
                window.scene.remove(window.visuals.staticNumberblocks[blockId].group || 
                                  window.visuals.staticNumberblocks[blockId].mesh);
            }
            delete window.visuals.staticNumberblocks[blockId];
        }
    } catch (error) {
        console.error(`Error removing static numberblock visual (${blockId}):`, error);
    }
}

function setupRoomListeners() {
    if (!window.room) {
        console.error("No room available!");
        return;
    }

    window.room.onStateChange.once((state) => {
        console.log("✅ State synchronized, setting up entity listeners.");

        // Check if we have entities collection
        if (state.entities) {
            // Process all entities and create appropriate visuals
            state.entities.forEach((entity, entityId) => {
                // Check entity type to determine how to handle it
                if (entity.type === "operator") {
                    createOperatorVisual(entity, entityId);
                } else if (entity.type === "staticNumberblock") {
                    createStaticNumberblockVisual(entity, entityId);
                }
            });

            // Set up listeners for entity changes
            try {
                state.entities.onAdd = (entity, entityId) => {
                    console.log(`Entity added: ${entityId}, type: ${entity.type}`);
                    if (entity.type === "operator") {
                        createOperatorVisual(entity, entityId);
                    } else if (entity.type === "staticNumberblock") {
                        createStaticNumberblockVisual(entity, entityId);
                    }
                };

                state.entities.onRemove = (entity, entityId) => {
                    console.log(`Entity removed: ${entityId}, type: ${entity.type}`);
                    if (entity.type === "operator") {
                        removeOperatorVisual(entityId);
                    } else if (entity.type === "staticNumberblock") {
                        removeStaticNumberblockVisual(entityId);
                    }
                };

                // Listen for changes to individual entities
                state.entities.onChange = (entity, entityId) => {
                    if (entity.type === "operator") {
                        updateOperatorVisual(entity, entityId);
                    } else if (entity.type === "staticNumberblock") {
                        updateStaticNumberblockVisual(entity, entityId);
                    }
                };
            } catch (error) {
                console.warn("Could not set up Colyseus schema handlers:", error);
            }
        } else {
            console.error("❌ state.entities not found");
        }

        console.log("✅ Entity listeners fully set up");
    });

    // Continuous state updates as fallback if onChange is not working
    window.room.onStateChange((state) => {
        // Update entities (if onChange not working properly)
        if (state.entities) {
            state.entities.forEach((entity, entityId) => {
                if (entity.type === "operator") {
                    updateOperatorVisual(entity, entityId);
                } else if (entity.type === "staticNumberblock") {
                    updateStaticNumberblockVisual(entity, entityId);
                }
            });
        }
    });
}

function updateOperatorVisual(operator, operatorId) {
    const operatorVisual = window.visuals.operators[operatorId];
    if (operatorVisual) {
        operatorVisual.update({
            x: operator.x,
            y: operator.y,
            z: operator.z,
            type: operator.operatorType
        });
    }
}

function updateStaticNumberblockVisual(block, blockId) {
    const blockVisual = window.visuals.staticNumberblocks[blockId];
    if (blockVisual) {
        blockVisual.update({
            x: block.x,
            y: block.y,
            z: block.z,
            value: block.value,
            color: block.color
        });
    }
}

// Define Operators Visual class
window.OperatorsVisual = class OperatorsVisual {
    constructor(operatorData) {
        // Store operator data
        this.id = operatorData.id;
        this.type = operatorData.operatorType === "plus" ? "plus" : "minus";
        
        // Use the OperatorManager to create the operator if available
        if (window.operatorManager) {
            this.operator = window.operatorManager.createOperatorFromServer(
                this.id,
                this.type,
                operatorData.x || 0,
                operatorData.y || 0.6,
                operatorData.z || 0
            );
            
            // Use the operator's group as our visual representation
            this.group = this.operator.group || this.operator.mesh;
        } else {
            console.warn("OperatorManager not available - creating simple operator visual");
            // Create a fallback visual
            this.createFallbackMesh(this.type === "plus" ? 0x00ff00 : 0xff0000);
        }
    }
    
    // Create a simple fallback mesh if operatorManager is not available
    createFallbackMesh(color) {
        this.group = new THREE.Group();
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const material = new THREE.MeshStandardMaterial({ 
            color: color,
            roughness: 0.7,
            metalness: 0.2 
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.group.add(this.mesh);
    }
    
    update(operatorData) {
        if (!operatorData) return;
        
        // Update position
        if (window.operatorManager && this.id) {
            window.operatorManager.updateOperatorFromServer(
                this.id,
                operatorData.x,
                operatorData.y,
                operatorData.z
            );
        } else if (this.group) {
            // Fallback update directly if OperatorManager not available
            this.group.position.set(
                operatorData.x,
                operatorData.y,
                operatorData.z
            );
        }
        
        // Update type if changed
        if (operatorData.type !== undefined && this.type !== operatorData.type) {
            this.type = operatorData.type;
            console.log(`Operator ${this.id} type changed to ${this.type}`);
        }
    }
    
    // Method called when this operator is removed
    remove() {
        if (window.operatorManager && this.id) {
            window.operatorManager.removeOperatorByServerId(this.id);
        } else if (this.group && this.group.parent) {
            this.group.parent.remove(this.group);
        }
    }
};

// Define StaticNumberblocks Visual class
window.StaticNumberblocksVisual = class StaticNumberblocksVisual {
    constructor(blockData) {
        this.group = new THREE.Group();
        this.id = blockData.id;
        this.value = blockData.value || 1;
        this.color = blockData.color || this.getColorForNumber(this.value);
        
        // Create numberblock mesh
        this.createNumberblockMesh();
        
        // Set initial position
        this.update(blockData);
    }
    
    createNumberblockMesh() {
        try {
            // Clear existing meshes
            while (this.group.children.length > 0) {
                this.group.remove(this.group.children[0]);
            }
            
            // Use Numberblock class if available for consistent visuals
            if (window.Numberblock) {
                const numberblock = new window.Numberblock(this.value, this.color);
                this.group.add(numberblock.mesh);
                // Store reference for future updates
                this.numberblockRef = numberblock;
                return;
            }
            
            // Fallback to manual creation if Numberblock class isn't available
            console.log("Creating static numberblock with value:", this.value);
            
            // Block size and spacing
            const blockSize = 1;
            const blockSpacing = 0.05;
            
            // Get color based on value
            const color = this.color;
            
            // Create basic geometry for a single block
            const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.7,
                metalness: 0.2
            });
            
            // Create separate blocks for each value unit
            const totalHeight = this.value;
            
            // Determine arrangement (1D, 2D, or 3D) based on value
            if (this.value <= 5) {
                // 1D arrangement (stack)
                for (let i = 0; i < this.value; i++) {
                    const cube = new THREE.Mesh(geometry, material);
                    cube.position.y = i * (blockSize + blockSpacing);
                    this.group.add(cube);
                }
            } else if (this.value <= 10) {
                // 2D arrangement (2x stack)
                const halfValue = Math.ceil(this.value / 2);
                for (let i = 0; i < halfValue; i++) {
                    const cube1 = new THREE.Mesh(geometry, material);
                    cube1.position.set(
                        -(blockSize + blockSpacing) / 2,
                        i * (blockSize + blockSpacing),
                        0
                    );
                    this.group.add(cube1);
                    
                    // Add second column if needed
                    if (i + halfValue < this.value) {
                        const cube2 = new THREE.Mesh(geometry, material);
                        cube2.position.set(
                            (blockSize + blockSpacing) / 2,
                            i * (blockSize + blockSpacing),
                            0
                        );
                        this.group.add(cube2);
                    }
                }
            } else {
                // For larger numbers, create a uniform block with a text label
                const scale = Math.pow(this.value, 1/3); // Cube root scaling
                const bigCube = new THREE.Mesh(geometry, material);
                bigCube.scale.set(scale, scale, scale);
                this.group.add(bigCube);
            }
            
            // Add number label
            this.addNumberLabel();
        } catch (error) {
            console.error("Error creating static numberblock mesh:", error);
        }
    }
    
    addNumberLabel() {
        // Create a simple canvas with the number
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        // Fill canvas with white background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw centered number
        ctx.fillStyle = 'black';
        ctx.font = 'bold 80px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.value.toString(), canvas.width / 2, canvas.height / 2);
        
        // Create texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        
        // Create a plane with the texture
        const labelGeometry = new THREE.PlaneGeometry(0.8, 0.8);
        const labelMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide
        });
        
        const label = new THREE.Mesh(labelGeometry, labelMaterial);
        
        // Position the label in front of the numberblock
        // For stack arrangements, put it at the top
        if (this.value <= 5) {
            label.position.set(0, this.value + 0.5, 0.6);
        } else {
            // For other arrangements, center it
            label.position.set(0, this.value / 3, 0.6);
        }
        
        this.group.add(label);
    }
    
    getColorForNumber(number) {
        // Color mapping for numberblocks
        const colors = {
            1: 0xFF0000, // Red (One)
            2: 0xFFA500, // Orange (Two)
            3: 0xFFFF00, // Yellow (Three)
            4: 0x00FF00, // Green (Four)
            5: 0x0000FF, // Blue (Five)
            6: 0x800080, // Purple (Six)
            7: 0xFFC0CB, // Pink (Seven)
            8: 0xA52A2A, // Brown (Eight)
            9: 0x808080  // Grey (Nine)
        };
        
        // For values > 9, cycle through colors
        return colors[number % 9] || 0xFFFFFF;
    }
    
    update(blockData) {
        if (!blockData) return;
        
        // Update position
        if (blockData.x !== undefined && 
            blockData.y !== undefined && 
            blockData.z !== undefined) {
            this.group.position.set(
                blockData.x,
                blockData.y,
                blockData.z
            );
        }
        
        // Update value if changed
        if (blockData.value !== undefined && this.value !== blockData.value) {
            this.value = blockData.value;
            // Update color if needed based on new value
            this.color = blockData.color || this.getColorForNumber(this.value);
            // Recreate mesh with new value
            this.createNumberblockMesh();
        }
        
        // Update color if explicitly changed
        if (blockData.color !== undefined && this.color !== blockData.color) {
            this.color = blockData.color;
            // Update existing numberblock if possible
            if (this.numberblockRef && typeof this.numberblockRef.updateColor === 'function') {
                this.numberblockRef.updateColor(this.color);
            } else {
                // Otherwise recreate the mesh with new color
                this.createNumberblockMesh();
            }
        }
    }
};

// Make functions available globally
window.setupRoomListeners = setupRoomListeners;
window.createOperatorVisual = createOperatorVisual;
window.removeOperatorVisual = removeOperatorVisual;
window.createStaticNumberblockVisual = createStaticNumberblockVisual;
window.removeStaticNumberblockVisual = removeStaticNumberblockVisual;
window.updateOperatorVisual = updateOperatorVisual;
window.updateStaticNumberblockVisual = updateStaticNumberblockVisual;
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\implementations\numberblocks\index.js 
===================================================== 
 
// 3D AI Game Platform - Numberblocks Implementation Index
// Registers all Numberblocks implementation components with the core platform

// Note: These should already be globally available through window object
// Use existing objects if they're already declared to avoid conflicts
let entityFactory = window.entityFactory;

// Registration function to set up all Numberblocks implementation components
function registerNumberblocksImplementation() {
    console.log("Registering Numberblocks implementation...");
    
    if (!entityFactory) {
        console.error("EntityFactory not found. Make sure core platform is loaded first.");
        return false;
    }
    
    // Check if the implementation is already registered
    if (entityFactory.implementationRegistry && 
        entityFactory.implementationRegistry['numberblocks.numberblock']) {
        console.log("Numberblocks implementation already registered");
        return true;
    }
    
    // Register Numberblocks-specific entity types only if not already registered
    try {
        // If NumberBlock is defined in both new structure and legacy system,
        // prefer to keep the one that's already being used
        const NumberBlockImpl = window.NumberBlock || {};
        const OperatorImpl = window.Operator || {};
        
        entityFactory.registerImplementation('numberblocks', {
            'numberblock': NumberBlockImpl,
            'operator': OperatorImpl
        });
        
        // Set up global configs for Numberblocks implementation
        window.gameImplementation = window.gameImplementation || {
            name: 'numberblocks',
            description: 'Mathematical blocks implementation',
            version: '1.0.0',
            
            // Create a player entity for this implementation
            createPlayer: function(params) {
                params.type = 'numberblocks.numberblock';
                return entityFactory.createPlayer(params);
            },
            
            // Create an operator entity for this implementation
            createOperator: function(params) {
                params.type = 'numberblocks.operator';
                return entityFactory.createEntity(params.type, params);
            },
            
            // Initialize the implementation
            init: function(scene) {
                console.log("Initializing Numberblocks implementation...");
                
                // Use existing operator manager if available
                window.operatorManager = window.operatorManager || {};
                
                return true;
            },
            
            // Clean up the implementation
            cleanup: function() {
                console.log("Cleaning up Numberblocks implementation...");
                
                // Clean up operator manager if it exists
                if (window.operatorManager && window.operatorManager.clearAll) {
                    window.operatorManager.clearAll();
                }
            }
        };
        
        console.log("Numberblocks implementation registered successfully");
        return true;
    } catch (error) {
        console.error("Error registering Numberblocks implementation:", error);
        return false;
    }
}

// Auto-register if window is available
if (typeof window !== 'undefined') {
    // Only define the function if it doesn't already exist
    if (!window.registerNumberblocksImplementation) {
        window.registerNumberblocksImplementation = registerNumberblocksImplementation;
    }
    
    // Auto-register if the page is already loaded
    if (document.readyState === 'complete') {
        registerNumberblocksImplementation();
    } else {
        // Otherwise wait for DOM content to load
        window.addEventListener('DOMContentLoaded', registerNumberblocksImplementation);
    }
}

// If using as a module
if (typeof module !== 'undefined') {
    module.exports = { registerNumberblocksImplementation };
}  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\implementations\numberblocks\NumberBlock.js 
===================================================== 
 
// Numberblocks game - Numberblock model implementation

class Numberblock {
    constructor(value = 1, color = null) {
        this.value = value;
        this.mesh = new THREE.Group();
        this.mesh.userData.numberblock = this; // Store reference for easy access
        this.blockSize = 1; // Size of each cube
        this.blockSpacing = 0.01; // Small gap between blocks
        this.totalHeight = 0;
        
        // Set color based on the Numberblock value, following show colors if no color specified
        if (!color) {
            this.color = this.getColorForNumber(value);
        } else {
            this.color = color;
        }
        
        this.createNumberblock();
    }
    
    // Get the standard Numberblocks color based on value
    getColorForNumber(number) {
        const colors = {
            1: 0xFF0000,   // Red (One)
            2: 0xFFA500,   // Orange (Two)
            3: 0xFFFF00,   // Yellow (Three)
            4: 0x00FF00,   // Green (Four)
            5: 0x0000FF,   // Blue (Five)
            6: 0x800080,   // Purple (Six)
            7: 0xFFC0CB,   // Pink (Seven)
            8: 0xA52A2A,   // Brown (Eight)
            9: 0x808080    // Grey (Nine)
        };
        
        // For numbers greater than 9, cycle through the colors or use white
        return colors[number % 9] || 0xFFFFFF;
    }
    
    // Create the complete Numberblock with all features
    createNumberblock() {
        this.mesh.clear(); // Clear any existing meshes
        this.totalHeight = 0;
        
        // Create the stack of blocks
        for (let i = 0; i < this.value; i++) {
            const block = this.createBlock();
            
            // Position each block on top of the previous one
            block.position.y = this.totalHeight;
            this.totalHeight += this.blockSize + this.blockSpacing;
            
            this.mesh.add(block);
            
            // Add face only to the top block
            if (i === this.value - 1) {
                const face = this.createFace();
                block.add(face);
            }
            
            // Add feet to the bottom block
            if (i === 0) {
                const leftFoot = this.createFoot('left');
                const rightFoot = this.createFoot('right');
                block.add(leftFoot);
                block.add(rightFoot);
            }
        }
        
        // Add arms to the middle block or the second block from the bottom if more than 3 blocks
        const armBlockIndex = this.value <= 3 ? Math.floor(this.value / 2) : 1;
        if (this.value > 0 && armBlockIndex < this.value) {
            const leftArm = this.createArm('left');
            const rightArm = this.createArm('right');
            
            this.mesh.children[armBlockIndex].add(leftArm);
            this.mesh.children[armBlockIndex].add(rightArm);
        }
        
        // Set initial position to 0 - we'll handle positioning in the game logic
        this.mesh.position.y = 0;
    }
    
    // Get the height of the Numberblock (for physics calculations)
    getHeight() {
        // Return the total height calculated during creation
        // If value is 0, return a minimum height
        return this.value > 0 ? this.totalHeight - this.blockSpacing : this.blockSize;
    }
    
    // Update the color of the Numberblock
    updateColor(newColor) {
        this.color = newColor;
        
        // Update the color of all blocks in the Numberblock
        this.mesh.children.forEach(child => {
            // Only update the blocks, not other attachments like arms or face
            if (child.geometry && child.geometry.type === 'BoxGeometry') {
                child.material.color.set(newColor);
            }
        });
    }
    
    // Create a single block with the Numberblock's color
    createBlock() {
        const geometry = new THREE.BoxGeometry(this.blockSize, this.blockSize, this.blockSize);
        const material = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        return new THREE.Mesh(geometry, material);
    }
    
    // Create a face with eyes and mouth
    createFace() {
        const face = new THREE.Group();
        
        // Eyes (white spheres with black pupils)
        const eyeSize = this.blockSize * 0.15;
        const eyeSpacing = this.blockSize * 0.3;
        const eyeHeight = this.blockSize * 0.1;
        const eyeDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        
        // Create and position left eye
        const leftEye = this.createEye(eyeSize);
        leftEye.position.set(-eyeSpacing, eyeHeight, eyeDepth);
        face.add(leftEye);
        
        // Create and position right eye
        const rightEye = this.createEye(eyeSize);
        rightEye.position.set(eyeSpacing, eyeHeight, eyeDepth);
        face.add(rightEye);
        
        // Mouth (curved line or small cylinder)
        const mouthWidth = this.blockSize * 0.4;
        const mouthHeight = this.blockSize * 0.1;
        const mouthDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        const mouthY = -eyeHeight * 2; // Position below the eyes
        
        const mouthGeometry = new THREE.CylinderGeometry(
            mouthHeight/2, mouthHeight/2, mouthWidth, 16, 1, false, 0, Math.PI
        );
        mouthGeometry.rotateZ(Math.PI / 2); // Rotate to correct orientation
        
        const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, mouthY, mouthDepth);
        face.add(mouth);
        
        return face;
    }
    
    // Create an eye (white sphere with black pupil)
    createEye(size) {
        const eye = new THREE.Group();
        
        // White part of the eye
        const eyeWhiteGeometry = new THREE.SphereGeometry(size, 16, 16);
        const eyeWhiteMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const eyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
        eye.add(eyeWhite);
        
        // Black pupil
        const pupilSize = size * 0.5;
        const pupilGeometry = new THREE.SphereGeometry(pupilSize, 16, 16);
        const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        pupil.position.z = size * 0.6; // Position the pupil slightly in front of the eye
        eye.add(pupil);
        
        return eye;
    }
    
    // Create an arm (left or right)
    createArm(side) {
        const arm = new THREE.Group();
        
        // Arm dimensions
        const armLength = this.blockSize * 0.6;
        const armWidth = this.blockSize * 0.2;
        const armHeight = this.blockSize * 0.2;
        
        // Create the arm geometry
        const armGeometry = new THREE.BoxGeometry(armLength, armHeight, armWidth);
        const armMaterial = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        const armMesh = new THREE.Mesh(armGeometry, armMaterial);
        
        // Position the arm on the side of the block
        const xOffset = (this.blockSize / 2 + armLength / 2) * (side === 'left' ? -1 : 1);
        armMesh.position.set(xOffset, 0, 0);
        
        arm.add(armMesh);
        
        // Add a hand at the end of the arm
        const handRadius = armWidth * 0.8;
        const handGeometry = new THREE.SphereGeometry(handRadius, 16, 16);
        const handMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF, // White hands
            roughness: 0.7,
            metalness: 0.2
        });
        
        const hand = new THREE.Mesh(handGeometry, handMaterial);
        
        // Position the hand at the end of the arm
        const handX = armLength / 2 * (side === 'left' ? -1 : 1);
        hand.position.set(handX, 0, 0);
        
        // Name the hand for easy reference
        hand.name = side + 'Hand';
        
        armMesh.add(hand);
        
        return arm;
    }
    
    // Create a foot (left or right)
    createFoot(side) {
        const foot = new THREE.Group();
        
        // Foot dimensions
        const footLength = this.blockSize * 0.4;
        const footWidth = this.blockSize * 0.3;
        const footHeight = this.blockSize * 0.15;
        
        // Create the foot geometry
        const footGeometry = new THREE.BoxGeometry(footLength, footHeight, footWidth);
        const footMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000, // Black feet
            roughness: 0.7,
            metalness: 0.2
        });
        
        const footMesh = new THREE.Mesh(footGeometry, footMaterial);
        
        // Position the foot on the bottom of the block
        const xOffset = (this.blockSize / 4) * (side === 'left' ? -1 : 1);
        const yOffset = -this.blockSize / 2 - footHeight / 2;
        const zOffset = this.blockSize / 4; // Push feet slightly forward
        footMesh.position.set(xOffset, yOffset, zOffset);
        
        foot.add(footMesh);
        
        return foot;
    }
    
    // Update the Numberblock value and regenerate the model
    setValue(newValue) {
        if (newValue < 1) newValue = 1; // Ensure minimum value of 1
        if (newValue !== this.value) {
            this.value = newValue;
            this.color = this.getColorForNumber(newValue);
            this.createNumberblock();
        }
    }
    
    // Update value (used for network synchronization)
    updateValue(newValue) {
        return this.setValue(newValue);
    }
    
    // Update the position of the HTML number tag in render loop
    updateNumberTagPosition(camera, renderer) {
        // Previous functionality disabled - no longer using HTML elements for tags
        // Now fully using the HUD we created in index.html and main-fixed.js
    }
    
    // Dispose any allocated resources
    dispose() {
        // We no longer need to remove HTML elements since we aren't creating them
    }
}

// Function to create a player Numberblock and add it to the scene
function createPlayerNumberblock(scene, value = 1) {
    // Create the Numberblock
    const playerBlock = new Numberblock(value);
    
    // Position it slightly above the ground
    const totalHeight = playerBlock.totalHeight;
    playerBlock.mesh.position.y = totalHeight / 2;
    
    // Add to scene
    scene.add(playerBlock.mesh);
    
    return playerBlock;
}

// Export for use in other modules
if (typeof module !== 'undefined') {
    module.exports = {
        Numberblock,
        createPlayerNumberblock
    };
}

// Always make Numberblock available globally
window.Numberblock = Numberblock;
console.log('Numberblock class exported to window object'); 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\client\js\implementations\numberblocks\operator.js 
===================================================== 
 
// 3D AI Game Platform - Numberblocks Implementation
// Operator class for mathematical operators (+ and -)

// Class to represent mathematical operators (+ and -)
class Operator extends NPC {
    constructor(params) {
        super(params);
        this.type = 'operator';
        this.operatorType = params.value; // 'plus' or 'minus'
        this.scene = params.scene;
        
        // Set the radius for collision detection
        this.collisionRadius = 0.5;
        
        // Animation properties specific to operators
        this.animationState.rotating.enabled = true;
        this.setupAnimation();
    }
    
    // Create the 3D mesh for the operator
    createMesh() {
        const operatorGroup = new THREE.Group();
        operatorGroup.userData.operator = this; // Store reference for easy access
        
        // Create a semi-transparent white sphere as the base
        const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const sphereMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF, // White sphere
            roughness: 0.3,
            metalness: 0.2,
            transparent: true, // Make it transparent
            opacity: 0.6 // 60% opacity
        });
        
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        operatorGroup.add(sphere);
        
        // Create the operator symbol (plus or minus)
        if (this.operatorType === 'plus') {
            // Create a plus sign (+) using two intersecting cubes
            this.createPlusSign(operatorGroup);
        } else if (this.operatorType === 'minus') {
            // Create a minus sign (-) using a single cube
            this.createMinusSign(operatorGroup);
        }
        
        return operatorGroup;
    }
    
    // Create a plus sign inside the sphere
    createPlusSign(parentGroup) {
        // Horizontal part of the plus sign
        const horizontalGeometry = new THREE.BoxGeometry(0.6, 0.15, 0.15);
        const horizontalMaterial = new THREE.MeshStandardMaterial({
            color: 0x00FF00, // Green for plus sign
            roughness: 0.5,
            metalness: 0.3
        });
        
        const horizontalPart = new THREE.Mesh(horizontalGeometry, horizontalMaterial);
        parentGroup.add(horizontalPart);
        
        // Vertical part of the plus sign
        const verticalGeometry = new THREE.BoxGeometry(0.15, 0.6, 0.15);
        const verticalMaterial = new THREE.MeshStandardMaterial({
            color: 0x00FF00, // Green for plus sign
            roughness: 0.5,
            metalness: 0.3
        });
        
        const verticalPart = new THREE.Mesh(verticalGeometry, verticalMaterial);
        parentGroup.add(verticalPart);
    }
    
    // Create a minus sign inside the sphere
    createMinusSign(parentGroup) {
        // Horizontal part (minus sign is just horizontal)
        const horizontalGeometry = new THREE.BoxGeometry(0.6, 0.15, 0.15);
        const horizontalMaterial = new THREE.MeshStandardMaterial({
            color: 0xFF0000, // Red for minus sign
            roughness: 0.5,
            metalness: 0.3
        });
        
        const horizontalPart = new THREE.Mesh(horizontalGeometry, horizontalMaterial);
        parentGroup.add(horizontalPart);
    }
    
    // Set the position of the operator
    setPosition(x, y, z) {
        if (this.mesh) {
            this.mesh.position.set(x, y, z);
            this.x = x;
            this.y = y;
            this.z = z;
        }
    }
    
    // Remove the operator from the scene
    remove() {
        if (this.mesh && this.mesh.parent) {
            this.mesh.parent.remove(this.mesh);
        }
    }
    
    // Special animation for operators
    animate(deltaTime) {
        super.animate(deltaTime);
        
        // Make operators face the player
        if (this.animationState.rotating.enabled && window.playerNumberblock) {
            // Rotate to face the player
            const playerPos = window.playerNumberblock.mesh.position;
            const direction = new THREE.Vector3();
            direction.subVectors(playerPos, this.mesh.position);
            
            // Calculate the angle but only on the Y axis (horizontal rotation)
            const targetRotation = Math.atan2(direction.x, direction.z);
            
            // Smooth rotation
            const rotationSpeed = this.animationState.rotating.speed;
            const angleDiff = (targetRotation - this.mesh.rotation.y + Math.PI) % (Math.PI * 2) - Math.PI;
            this.mesh.rotation.y += angleDiff * rotationSpeed * deltaTime;
        }
    }
}

// Operator Manager class for handling multiple operators
class OperatorManager {
    constructor(scene) {
        this.scene = scene;
        this.operators = {}; // Map of operator IDs to operator objects
        this.heldOperator = null; // Currently held operator
        this.heldOperatorMesh = null; // Visual representation of held operator
        
        // Create a floating position for held operators
        this.heldOperatorPosition = {
            offsetX: 0.5, // Position to the right of the player
            offsetY: 0.5, // Position above the player
            offsetZ: -0.5, // Position in front of the player
        };
    }
    
    // Update all operators
    update(deltaTime) {
        // Update held operator position if there is one
        if (this.heldOperator && this.heldOperatorMesh && window.playerNumberblock) {
            // Position the held operator relative to the player
            const playerPos = window.playerNumberblock.mesh.position;
            this.heldOperatorMesh.position.set(
                playerPos.x + this.heldOperatorPosition.offsetX,
                playerPos.y + this.heldOperatorPosition.offsetY,
                playerPos.z + this.heldOperatorPosition.offsetZ
            );
        }
    }
    
    // Create a new operator based on server data
    createOperatorFromServer(id, type, x, y, z) {
        if (this.operators[id]) {
            console.warn(`Operator with ID ${id} already exists`);
            return this.operators[id];
        }
        
        const params = {
            id: id,
            value: type, // Using value to store the operator type
            type: 'operator',
            x: x,
            y: y,
            z: z,
            scene: this.scene
        };
        
        const operator = new Operator(params);
        this.operators[id] = operator;
        
        return operator;
    }
    
    // Get an operator by its server ID
    getOperatorByServerId(id) {
        return this.operators[id] || null;
    }
    
    // Update an operator's position based on server data
    updateOperatorFromServer(id, x, y, z) {
        const operator = this.getOperatorByServerId(id);
        if (operator) {
            operator.setPosition(x, y, z);
        }
    }
    
    // Remove an operator
    removeOperator(operator) {
        if (!operator) return;
        
        // Remove from scene
        operator.remove();
        
        // Remove from operators map
        const id = operator.id;
        if (this.operators[id]) {
            delete this.operators[id];
        }
    }
    
    // Remove an operator by its server ID
    removeOperatorByServerId(id) {
        const operator = this.getOperatorByServerId(id);
        if (operator) {
            this.removeOperator(operator);
        }
    }
    
    // Set the currently held operator
    setHeldOperator(operator, numberblock) {
        // Clear any currently held operator first
        this.clearHeldOperator();
        
        if (!operator) return;
        
        // Store the operator
        this.heldOperator = operator;
        
        // Make the original operator invisible
        if (operator.mesh) {
            operator.mesh.visible = false;
        }
        
        // Create a visual representation for the held operator
        this.heldOperatorMesh = this.createHeldOperatorMesh(operator.operatorType);
        
        // Position it relative to the player
        if (this.heldOperatorMesh && numberblock && numberblock.mesh) {
            const playerPos = numberblock.mesh.position;
            this.heldOperatorMesh.position.set(
                playerPos.x + this.heldOperatorPosition.offsetX,
                playerPos.y + this.heldOperatorPosition.offsetY,
                playerPos.z + this.heldOperatorPosition.offsetZ
            );
            
            // Add it to the scene
            this.scene.add(this.heldOperatorMesh);
        }
        
        // Create a smaller version of the operator and attach it to the numberblock
        if (numberblock) {
            this.attachOperatorToNumberblock(numberblock);
        }
        
        return this.heldOperator;
    }
    
    // Clear currently held operator
    clearHeldOperator() {
        if (this.heldOperator) {
            // Make the original operator visible again if it still exists
            const id = this.heldOperator.id;
            const originalOperator = this.getOperatorByServerId(id);
            if (originalOperator && originalOperator.mesh) {
                originalOperator.mesh.visible = true;
            }
        }
        
        // Remove the held operator mesh
        if (this.heldOperatorMesh && this.heldOperatorMesh.parent) {
            this.heldOperatorMesh.parent.remove(this.heldOperatorMesh);
        }
        
        this.heldOperator = null;
        this.heldOperatorMesh = null;
    }
    
    // Get the currently held operator
    getHeldOperator() {
        return this.heldOperator;
    }
    
    // Create a smaller version of the operator and attach it to the numberblock
    createHeldOperatorMesh(type) {
        // Create a smaller version of the operator for display
        const params = {
            value: type,
            type: 'operator',
            scene: this.scene
        };
        
        const operatorVisual = new Operator(params);
        const mesh = operatorVisual.mesh;
        
        // Scale it down
        mesh.scale.set(0.5, 0.5, 0.5);
        
        return mesh;
    }
    
    // Create a smaller version of the operator and attach it to the numberblock
    attachOperatorToNumberblock(numberblock) {
        if (!this.heldOperator || !numberblock || !numberblock.mesh) return;
        
        // We could add a small visual indicator on the numberblock to show the held operator
        // For now, we'll just log it
        console.log(`Numberblock ${numberblock.value} is holding a ${this.heldOperator.operatorType} operator`);
    }
    
    // Clear all operators
    clearAll() {
        // Clear held operator
        this.clearHeldOperator();
        
        // Remove all operators
        for (const id in this.operators) {
            this.removeOperator(this.operators[id]);
        }
        
        this.operators = {};
    }
    
    // Get all operators
    getOperators() {
        return Object.values(this.operators);
    }
}

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.Operator = Operator;
    window.OperatorManager = OperatorManager;
}

if (typeof module !== 'undefined') {
    module.exports = { Operator, OperatorManager };
}  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\memory bank\architecture.md 
===================================================== 
 
# 3D AI Game Platform - Architecture

## Overview
3D AI Game is a modular 3D web-based game platform built with Three.js and Colyseus, utilizing a client-server architecture for multiplayer functionality. Players control customizable characters and interact with a colorful 3D environment. The platform is designed to support various game implementations.

## Core Components

### 1. Server (server/core/server.js)
**Technology:** Built with Node.js and Colyseus.

**Responsibilities:**
- Manages game rooms and player connections/disconnections
- Maintains the authoritative game state
- Processes player inputs (e.g., movement, collisions)
- Broadcasts state updates to all connected clients
- Handles entity spawning and lifecycle management

**Key Features:**
- Room-based multiplayer with session persistence
- State synchronization using Colyseus schema
- Server-authoritative position tracking
- Dynamic entity spawning system

### 2. Client Core Platform (/client/js/core)
The core platform provides foundational functionality that all game implementations can leverage.

**Key components:**
- **main.js:**
  - Entry point for client-side code
  - Loads core modules and initializes the game engine
  - Sets up default player factory

- **controls.js:**
  - Handles player movement and camera controls
  - Supports first-person, third person, and free roam view modes
  - Manages input handling for keyboard and mouse
  - Implements quaternion-based rotation for smooth camera movement

- **game-engine.js:**
  - Initializes the Three.js scene, renderer, and camera
  - Sets up player controls and world objects
  - Manages the animation loop for continuous rendering
  - Implements three distinct camera systems:
    - First-person view: Camera attached to player's head position
    - Third-person view: Camera follows behind player with intelligent rotation alignment
    - Free camera mode: Independent camera with WASD/QE movement and mouse look functionality
  - Handles smooth camera transitions between view modes
  - Maintains proper camera orientation with Euler angles to prevent unwanted roll

- **network-core.js:**
  - Establishes and maintains WebSocket connection to the server via Colyseus
  - Sends player actions to the server
  - Processes state updates from the server
  - Handles player joining/leaving events

- **Entity.js:**
  - Base class for all game entities
  - Provides core entity functionality (position, rotation, scale)
  - Defines interface for entity behaviors
  - Handles common entity lifecycle events

- **Player.js:**
  - Extends Entity for player-specific functionality
  - Manages player state and input handling
  - Provides interface for implementation-specific player behaviors

- **NPC.js:**
  - Extends Entity for non-player characters
  - Implements basic AI behaviors
  - Provides interface for implementation-specific NPC behaviors

- **EntityFactory.js:**
  - Factory pattern for creating entities
  - Registers entity types and their constructors
  - Used by both core platform and game implementations

- **collision.js:**
  - Handles collision detection and resolution
  - Provides interfaces for implementation-specific collision behaviors

- **player-ui.js:**
  - Manages common UI elements for player information
  - Provides hooks for implementation-specific UI components

### 3. Game Implementations (/client/js/implementations and /server/implementations)
Each game implementation extends the core platform with specific gameplay mechanics and visuals.

**Implementation Structure:**
- Client-side implementation code in /client/js/implementations/
- Server-side implementation code in /server/implementations/
- Each implementation folder contains its own set of entities, rooms, and behaviors

**Future Implementations:**
- Will follow similar patterns, extending the core components
- Each implementation will be contained in its own directory
- Will register custom entity factories and behaviors

### 4. Main Engine (game-engine.js)
- Initializes the Three.js scene, renderer, and camera
- Sets up player controls and world objects
- Loads the appropriate game implementation based on configuration
- Manages view modes (first-person, third person, free roam)
- Updates visual components based on server state

### 5. Networking Architecture
**Technology:** Colyseus for WebSocket-based real-time multiplayer.

**Implementation:**
- Server maintains authoritative game state using Colyseus Schema
- Client sends player actions to the server at regular intervals
- Server validates actions, updates game state, and broadcasts to all clients
- Efficient state synchronization with delta updates
- Robust player synchronization with proper sessionId handling
- Smooth interpolation of remote player movements using lerping

**Key Features:**
- Session persistence with reconnection support
- Room-based multiplayer with shared state
- Message-based communication for game events
- Schema-based state synchronization with type annotations
- Player list UI showing all connected players
- Automatic remote player creation and cleanup
- Smooth remote player movement interpolation
- Proper handling of player value updates and mesh recreation
- Resilient error handling for network disconnections
- Automatic cleanup of stale player instances

**Schema Implementation:**
- Proper MapSchema collections for players, operators, and static objects
- Type annotations for all schema properties
- Structured synchronization patterns for consistent state updates
- Robust sessionId tracking for player identification
- Proper player state management with value updates

**Player Synchronization:**
- Automatic creation of remote player instances with proper sessionId tracking
- Smooth position interpolation using Three.js lerping
- Proper cleanup of disconnected player instances
- Value-based mesh updates
- Efficient player collection management using Set data structure
- Proper separation of local and remote player handling
- Resilient error handling for edge cases

## File Structure
```
/
├── package.json            # Node.js dependencies
├── client/                 # Client-side code
│   ├── index.html          # Main HTML file
│   ├── css/                # Stylesheets
│   └── js/                 # JavaScript files
│       ├── core/           # Core platform code
│       │   ├── main.js     # Entry point and module loader
│       │   ├── game-engine.js # Main game engine and rendering
│       │   ├── Entity.js   # Base entity class
│       │   ├── Player.js   # Base player class
│       │   ├── NPC.js      # Base NPC class
│       │   ├── controls.js # Camera and movement controls
│       │   ├── network-core.js # Networking functionality
│       │   ├── collision.js    # Collision detection
│       │   ├── EntityFactory.js # Entity creation factory
│       │   └── player-ui.js    # UI components
│       └── implementations/ # Game-specific client implementations
│           ├── default/     # Default box implementation
│           │   └── DefaultPlayer.js # Simple box player
│           └── numberblocks/  # Example implementation
│               ├── entity-sync.js # Entity synchronization
│               ├── operator.js    # Mathematical operators
│               └── index.js       # Implementation entry point
├── server/                 # Server-side code
│   ├── core/               # Core server components
│   │   ├── server.js       # Main server entry point
│   │   ├── index.js        # Core server initialization
│   │   ├── BaseRoom.js     # Base room implementation
│   │   └── schemas/        # All schema definitions
│   │       ├── BaseEntity.js # Base entity schema
│   │       ├── DefaultRoom.js # Default room implementation
│   │       ├── GameState.js  # Game state schema
│   │       ├── Player.js     # Player schema
│   │       ├── InputState.js # Input state schema
│   │       └── GameConfigSchema.js # Game configuration schema
│   └── implementations/    # Server-side implementations
│       ├── default/        # Default implementation
│       │   └── index.js    # Default implementation entry point
│       └── numberblocks/   # Example implementation
│           ├── index.js    # Implementation entry point
│           ├── schemas.js  # Implementation-specific schemas
│           └── NumberblocksRoom.js # Implementation room
├── four_player_setup.html  # HTML for 4-player split-screen setup
├── open_4player_direct.bat # Batch script to launch 4-player mode
└── memory bank/            # Documentation and reference materials
```

## Communication Flow
1. **Initialization:**
   - Server starts and creates a game room
   - Client connects to server and joins the room
   - Server assigns a session ID and initializes player state
   - Client loads the appropriate game implementation

2. **Gameplay Loop:**
   - Client captures user inputs and sends movements that affect player character to server (movements, actions, etc.)
   - Server validates and processes inputs
   - Server updates game state
   - Server broadcasts updated state to all clients
   - Each client renders the updated game state based on its implementation

3. **Interactions:**
   - Client detects local collisions and sends interaction events to server
   - Server validates interaction and updates game state accordingly
   - Server broadcasts the updated state to all clients
   - Each client renders the interaction effects based on its implementation

## Modular Design Approach
The platform is designed with modularity in mind, allowing for different game implementations to share core functionality:

1. **Base Classes:**
   - Core Entity, Player, and NPC classes define common behavior
   - Implementation-specific classes extend these base classes

2. **Factory Pattern:**
   - EntityFactory creates appropriate entity instances based on entity type
   - New implementations register their entity types with the factory

3. **Dependency Injection:**
   - Core components are injected into implementation-specific classes
   - Allows implementations to focus on behavior rather than infrastructure

4. **Interface-Based Design:**
   - Clear interfaces define what implementations must provide
   - Core platform handles common functionality and lifecycle management

## Key Features
- **Triple View Modes:** 
  - First-person view with player model hidden
  - Third-person view with camera following player and aligning with player's facing direction
  - Free roam camera with independent movement and rotation, maintaining proper orientation
- **Camera Controls:**
  - Mouse wheel zoom for third-person view
  - Mouse-based rotation with proper Euler angle handling to prevent camera roll
  - View-specific movement and interaction behaviors
  - Seamless transitions between camera modes
- **Multiplayer Support:** Multiple players can join the same game world
- **Multi-Player Setup:** Supports a 4-player split-screen mode for local multiplayer gameplay
- **Persistence:** Session reconnection support
- **Browser Tab Synchronization:** Automatically updates game state when inactive tabs become active
- **Entity Component System:** Flexible architecture for game entity management
- **Modular Implementation System:** Support for various game types and mechanics

## Multi-Player Local Setup
The platform supports flexible local multiplayer configurations through a dynamic split-screen system:

### Screen Layout Configurations
1. **Single Player:**
   - Full screen display
   - Utilizes entire window space

2. **Two Players:**
   - Vertical split (top-bottom)
   - Equal screen space allocation
   - Clean separation with minimal gap

3. **Three Players:**
   - Top row split horizontally (left and right)
   - Bottom row left occupied, right empty
   - Maintains visual balance with empty fourth quadrant

4. **Four Players:**
   - 2x2 grid layout
   - Equal quadrants for all players
   - Minimal gaps between screens

### Implementation Details
- **Dynamic Layout System:**
  - CSS Grid-based layout management
  - Responsive to window resizing
  - Automatic adjustment based on player count
  - Clean separation between viewports

- **Technical Components:**
  ```html
  four_player_setup.html   # Handles multi-player screen layouts
  ```
  - Dynamically creates required number of game instances
  - Manages viewport organization
  - Handles implementation selection display
  - Maintains proper aspect ratios

- **Launch System:**
  ```batch
  start_game.bat          # Unified game launcher
  ```
  - Manages server startup
  - Handles implementation selection
  - Controls player count configuration
  - Launches appropriate screen layout

### Key Features
- **Flexible Configuration:** Supports 1-4 players
- **Clean Interface:** Minimal gaps between viewports
- **Implementation Awareness:** Displays current game implementation
- **Dynamic Resizing:** Maintains proper ratios on window resize
- **Efficient Resource Usage:** Only creates needed game instances
- **Seamless Integration:** Works with all game implementations 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\memory bank\game design document.md 
===================================================== 
 
# 3D AI Game Platform
## Introduction
The 3D AI Game platform is a modular, web-based 3D game environment built with Three.js and Colyseus, utilizing a client-server architecture for multiplayer functionality. Players control customizable characters and interact with a colorful 3D environment. The platform is designed to support various game implementations, with Numberblocks being the first example.

## Platform Overview
This game platform allows players to navigate a 3D world with customizable characters, interact with other players and objects, and participate in various game modes. The platform's modular design enables developers to implement different themes and gameplay mechanics while maintaining the core 3D multiplayer functionality.

## Core Components

### 1. Game Engine
- Three.js for 3D rendering
- Colyseus for multiplayer functionality
- Modular entity system for extensible game objects

### 2. Player System
- Customizable player characters based on game implementation
- Support for various movement modes and camera perspectives
- Collision detection and interaction systems

### 3. Game World
- Visual Style: Configurable environment themes
- Features include platforms, ramps, hiding spots, and open areas for player interaction
- Maps encourage exploration and strategic positioning

### 4. Multiplayer Features
- Client-Server Model: Uses Colyseus for WebSocket communication
- Room-Based Gameplay: Players join game rooms with unique session IDs
- Cross-Platform Support: Play on various devices and browsers

## Implementation: Numberblocks

### Character Design
- Players are represented as Numberblocks, with a block count matching their current number
- The model dynamically adjusts as the number changes (e.g., growing from 1 block to 10 blocks)
- Size can optionally affect movement speed (larger numbers move slower)

### Game Mechanics
- **Operators**: Plus (+) and minus (-) operators spawn throughout the map
- **Collection**: Players collect operators by touching them
- **Interaction**: Operators activate upon bumping into another player
- **Number Changes**: Players' numbers change based on the operator used

### Game Modes
1. **Target Number Mode**: Reach a specific number (e.g., 100) by adding to your value
2. **Elimination Mode**: Reduce other players to zero using the minus operator
3. **Score-Based Mode**: Earn points for each operation performed

## Multiplayer Features

### Local Split-Screen Multiplayer
- Supports 2-4 players on a single device
- Screen division options based on player count
- Input management for multiple local players

### Online Multiplayer
- Connect to game servers via unique room codes or matchmaking
- Session reconnection support if temporarily disconnected
- Up to 10 players per online game room

### Player Interaction
- Core interaction mechanics defined by the specific game implementation
- Cooperative and competitive actions
- Strategic positioning and tactical play

## Technical Architecture

### Client-Side Structure
- **Main Engine**: Initializes the Three.js scene, renderer, and camera
- **Network Core**: Manages connection to the server
- **Controls**: Handles player movement and camera controls
- **Entity System**: 
  - Base Entity class for all game objects
  - Specialized entity classes (Player, NPC, etc.)
  - EntityFactory for creating various game objects

### Server-Side Structure
- Game state management
- Player connection handling
- Physics and collision processing
- Entity spawning and lifecycle management

### Modular Implementation System
- Base classes for core functionality
- Extension points for custom game logic
- Theme-specific assets and behaviors
- Pluggable game modes and rules

## User Interface (UI)
- Heads-Up Display (HUD): Shows player information and game status
- Menus: Main menu, lobby, settings
- Controls: Configurable keyboard/mouse controls

## Audio
- Background Music: Theme-appropriate music
- Sound Effects: Action-based audio feedback
- Spatial Audio: Directional sound for immersion

## Technical Considerations
- Browser-based, using WebGL for 3D rendering
- Real-time multiplayer with server-side state management
- Optimized for performance across devices




## Conclusion
The 3D AI Game platform provides a flexible foundation for creating multiplayer 3D web games with different themes and mechanics. By separating core functionality from specific implementations, developers can create new games while leveraging the existing multiplayer infrastructure, 3D rendering capabilities, and entity management system.
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\memory bank\RULES.md 
===================================================== 
 
# Development Rules and Notes

## Server Management

### Restarting the Game Server
When testing changes, you'll need to properly stop and restart the Node.js server:

# STEP 1: Kill all Node.js processes (safer and more reliable method)
taskkill /F /IM node.exe

# STEP 2: Start the server using npm
npm start

> NOTE: The previous method using `Get-Process -Name "node" -ErrorAction SilentlyContinue | Stop-Process -Force` 
> has been found to be unreliable and may cause issues.

### Directory Creation
- When creating multiple directories at once with PowerShell's `mkdir` command, you must use quotes when specifying paths with spaces or multiple directories:
  ```
  # INCORRECT (will fail):
  mkdir css js assets assets\images assets\models assets\sounds
  
  # CORRECT (individual commands):
  mkdir css
  mkdir js
  mkdir assets
  mkdir "assets\images"
  mkdir "assets\models"
  mkdir "assets\sounds"
  ```

- PowerShell's `mkdir` doesn't support multiple directory arguments like in Linux/macOS. Create directories one by one or use a loop.

## Project Structure

### Core vs. Implementation
- All core components must be kept in their respective core directories:
  - Server core: `/server/core/`
  - Client core: `/client/js/core/`
- Implementation-specific code must be in the implementations directories:
  - Server implementations: `/server/implementations/`
  - Client implementations: `/client/js/implementations/`

### Core Components Location
- The main server entry point must be in `/server/core/server.js`
- The main client entry point must be in `/client/js/core/main.js`
- All schema definitions must be in `/server/core/schemas/`
- Core room implementations must be in `/server/core/` (e.g., BaseRoom.js)

### Schema Organization
- All schemas (including implementation-specific ones) should properly extend the base schemas
- Core schemas must be in `/server/core/schemas/`
- Implementation-specific schemas should be in their respective implementation directory
- Never create schemas outside of these designated locations

## Implementation Guidelines

### Modular Design Principles
- Keep core platform code separate from specific game implementations
- Use interfaces and base classes for common functionality
- Create extension points for game-specific features
- Implement factory patterns for creating game-specific entities
- Core code must remain implementation-agnostic

### Implementation-Agnostic Code
- Core code must never refer to specific implementations by name
- Use generic terms in core code (e.g., "player" instead of specific implementation names)
- Always provide generic interfaces that implementations can extend
- Implementations should identify themselves via their "implementationType" property

### Three.js Implementation Notes

- Always include the Three.js library before your own JavaScript files in the HTML
- When testing, make sure to run a local HTTP server rather than opening the HTML file directly due to CORS restrictions with resource loading
- Use a thin BoxGeometry instead of PlaneGeometry for the ground to ensure proper lighting on both sides
- Always implement window resize handling for responsive design (update camera aspect ratio and renderer size)
- For better performance, set renderer.setPixelRatio to match the device's pixel ratio

### Browser API Considerations

- The Pointer Lock API (used by PointerLockControls) may not work in some environments, especially in embedded preview browsers or when served through certain proxies
- Always implement a fallback mechanism for critical browser APIs in case they fail
- Use try-catch blocks around browser API calls that might not be supported in all environments
- Check browser console for API-related errors when testing in different environments
- When implementing mouse controls:
  - Proper event listener management is essential (add/remove listeners appropriately)
  - Always provide visual feedback when controls are locked/unlocked
  - Ensure complete disengagement of controls when user presses ESC

### JavaScript Best Practices

- When using event handlers, store references to them for proper removal later to prevent memory leaks
- For event-based systems (like controls), implement a proper event dispatcher mechanism
- Use class-based or module patterns for complex components to keep code organized
- When dealing with 3D rotations:
  - Separate axes of rotation (yaw, pitch, roll) to prevent gimbal lock issues
  - Always clamp vertical rotation (pitch) to prevent camera flipping

### Game Implementation Guidelines
- Each game implementation should be contained in its own directory
- Game-specific logic should extend the core platform classes
- Assets specific to a game implementation should be in their own directory
- Implement the required interfaces for entity creation and behavior

## Git Workflow

- Always update documentation when making significant changes
- Keep commit messages descriptive and related to implementation changes
- Use feature branches for new game implementations or major features

## Adding New Game Implementations
- Create both client-side and server-side implementation directories
- Extend core classes for your implementation needs
- Register your implementation components with the appropriate factories
- Follow the structure established by existing implementations
- Ensure full implementation-agnostic separation between core and implementation code

## Modules Loading
- Client modules must follow the pattern established in main.js for proper loading order
- Core modules must be loaded before implementation-specific modules
- Use proper dependency management to avoid circular references

## 4-Player Local Multiplayer Setup
- The 4-player setup consists of two key files: `four_player_setup.html` and `open_4player_direct.bat`
- **Do not delete** these files as they are essential for the 4-player functionality
- When making changes that affect the client interface, test with the 4-player setup to ensure compatibility
- The 4-player setup requires Chrome to be installed on the system

### Running the 4-Player Setup
- Use the `open_4player_direct.bat` script to launch the 4-player setup
- The script automatically opens Chrome in app mode with the required HTML file
- Press F11 in the browser for fullscreen mode
- Ensure the game server is running at http://localhost:3000 before launching

### Modifying the 4-Player Setup
- If you need to modify the layout, edit the CSS grid properties in `four_player_setup.html`
- The default setup is a 2×2 grid with minimal spacing between the viewports
- Each viewport is an iframe that loads the game client independently
- Changes to the main client should automatically reflect in all viewports

## Always follow the architecture.md - if there is any discrepancy then stop and bring it to my attention 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\memory bank\tech stack.md 
===================================================== 
 
# 3D AI Game Platform - Tech Stack

## Front-End
- **HTML5:** Provides the structure for the game, including the canvas element for 3D rendering and UI components like the heads-up display (HUD) and menus.

- **CSS3:** Styles the UI elements, such as the HUD, player stats, and overlays, ensuring they look polished and are positioned correctly over the game canvas.

- **JavaScript (ES6+):** Drives the client-side game logic, handling player input, visual rendering, and network communication.

- **Three.js:** A JavaScript library that simplifies WebGL for 3D rendering, used to create the game world, dynamic models, and environmental elements.

- **Web Audio API:** Manages audio, including sound effects for actions and background music, providing immersive audio experiences for different game implementations.

## Back-End
- **Node.js:** Server-side JavaScript runtime that hosts the game server, manages player connections, and maintains the authoritative game state.

- **Colyseus:** Framework for multiplayer game server development that handles room-based multiplayer, state synchronization, and client message processing.

- **Colyseus Schema:** Provides efficient state synchronization between server and clients with binary encoding and delta updates.

## Networking
- **WebSockets:** Underlying protocol for real-time bidirectional communication between clients and server.

- **Client-Server Architecture:** Maintains authoritative game state on the server to prevent cheating and ensure consistent gameplay.

- **Room-Based Multiplayer:** Organizes players into game rooms with shared state and scoped communication.

## Development Tools
- **Git:** Version control system to track changes and manage the project's codebase.

- **npm:** Package manager for JavaScript, used to manage dependencies and run scripts.

- **Nodemon:** Development utility that monitors server.js changes and automatically restarts the server during development.

- **ESLint:** JavaScript linter that helps maintain code quality and consistency.

## Project Organization
- **Modular Architecture:** Core platform code separated from specific game implementations to allow for extensibility.

- **Client-Server Separation:** Distinct code organization with `/client` directory for front-end and root-level server code.

- **Component-Based Design:** Separate JavaScript modules for different game systems (networking, rendering, game logic, entities).

- **Implementation Framework:** Pluggable system for creating new game themes and mechanics while reusing core platform code.

## Deployment
- **Node.js Hosting:** Server deployed on Node.js compatible hosting platforms (e.g., Heroku, AWS, DigitalOcean).

- **Static Asset Serving:** Client-side assets (HTML, CSS, JS) served by the Node.js server.

## Why This Stack?

- **Three.js:** Provides powerful 3D rendering capabilities with a manageable learning curve, ideal for creating diverse game environments and character models.

- **Colyseus:** Purpose-built for multiplayer games with efficient state synchronization and room management, simplifying networked gameplay implementation.

- **Client-Server Model:** Ensures fair gameplay by maintaining authoritative state on the server, preventing client-side cheating.

- **Node.js:** Enables JavaScript throughout the stack, reducing context switching and allowing code sharing between client and server when appropriate.

- **Modular Design:** Supports the creation of different game implementations on top of a shared core platform, maximizing code reuse and maintainability.

This tech stack supports the core functionality of the 3D AI Game platform, including the dynamic 3D rendering, multiplayer capabilities, and flexible implementation system. It provides a solid foundation for creating various game themes and mechanics while maintaining a consistent technical architecture.
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\public\minimal.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal Three.js Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        #debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            max-width: 500px;
            overflow: auto;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="debug-panel"></div>
    
    <!-- Three.js library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    
    <script>
        // Debug function
        function debug(message) {
            const debugPanel = document.getElementById('debug-panel');
            const messageElement = document.createElement('div');
            messageElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            debugPanel.appendChild(messageElement);
            debugPanel.scrollTop = debugPanel.scrollHeight;
            console.log(`[DEBUG] ${message}`);
        }
        
        // Simple Three.js scene
        let scene, camera, renderer;
        let cube;
        
        function init() {
            debug('Starting minimal test...');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            debug('Scene created');
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            debug('Camera created');
            
            // Create renderer directly on the document body
            try {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                debug('Renderer created and appended to document body');
            } catch (error) {
                debug(`Error creating renderer: ${error.message}`);
                return;
            }
            
            // Create a simple cube
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            debug('Cube created and added to scene');
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);
            debug('Lights added');
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation
            debug('Starting animation');
            animate();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            debug('Window resized');
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate cube
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;
            
            // Render
            renderer.render(scene, camera);
        }
        
        // Start everything when window loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\core\BaseRoom.js 
===================================================== 
 
const { Room } = require("colyseus");
const { GameState } = require("./schemas/GameState");
const { Player } = require("./schemas/Player");
const { BaseEntity } = require("./schemas/BaseEntity");

/**
 * Base room class for all game implementations
 * Provides common functionality for all game rooms
 */
class BaseRoom extends Room {
    /**
     * Called when room is created
     * @param {Object} options Room creation options
     */
    onCreate(options) {
        console.log("BaseRoom created!", options);
        
        // Initialize room state with a new GameState
        this.setState(new GameState());
        
        // Set maximum number of clients
        this.maxClients = 10;
        
        // Set frequency of patches to send
        this.setPatchRate(1000 / 30); // 30 fps
        
        // Set simulation interval for server-side logic
        this.setSimulationInterval(() => this.update());
        
        // Initialize spawn system
        this.initializeSpawnSystem();
        
        // Initialize implementation - to be implemented by subclasses
        this.initializeImplementation(options);
        
        // Listen for input updates
        this.onMessage("updateInput", (client, message) => {
            this.handleInputUpdate(client, message);
        });
        
        // Listen for entity interaction messages
        this.onMessage("entityInteraction", (client, message) => {
            this.handleEntityInteraction(client, message);
        });
    }
    
    /**
     * Initialize entity spawn system
     * Provides base functionality for spawning entities periodically
     */
    initializeSpawnSystem() {
        // Base spawn system properties
        this.spawnTimer = 0;
        this.spawnInterval = 10; // Default 10 seconds
        this.maxEntities = 20;   // Default maximum entities
        this.spawnEnabled = false; // Disabled by default
    }
    
    /**
     * Initialize implementation-specific functionality
     * To be overridden by subclasses
     * @param {Object} options Room creation options
     */
    initializeImplementation(options) {
        // Base implementation does nothing
        console.log("Base implementation initialized");
    }
    
    /**
     * Handle input update message from client
     * @param {Client} client The client that sent the message
     * @param {Object} message The message sent by the client
     */
    handleInputUpdate(client, message) {
        const player = this.state.players.get(client.sessionId);
        if (!player) return;
        
        // Update individual keys instead of replacing the entire keys object
        if (message.keys) {
            player.input.keys.w = !!message.keys.w;
            player.input.keys.a = !!message.keys.a;
            player.input.keys.s = !!message.keys.s;
            player.input.keys.d = !!message.keys.d;
            player.input.keys.space = !!message.keys.space;
            player.input.keys.q = !!message.keys.q;
            player.input.keys.e = !!message.keys.e;
            player.input.keys.shift = !!message.keys.shift;
        }
        
        // Fix mouseDelta assignment - update properties instead of replacing the object
        if (message.mouseDelta) {
            player.input.mouseDelta.x = message.mouseDelta.x || 0;
            player.input.mouseDelta.y = message.mouseDelta.y || 0;
        } else {
            player.input.mouseDelta.x = 0;
            player.input.mouseDelta.y = 0;
        }
        
        player.input.viewMode = message.viewMode || "third-person";
        player.input.thirdPersonCameraAngle = message.thirdPersonCameraAngle || 0;
        
        // Apply direct client rotation if provided (for immediate, responsive feel)
        if (message.clientRotation) {
            player.rotationY = message.clientRotation.rotationY;
            player.pitch = message.clientRotation.pitch;
        }
    }
    
    /**
     * Handle entity interaction message from client
     * Base implementation for entity interactions like collecting or triggering entities
     * @param {Client} client The client that sent the message
     * @param {Object} message The message containing entityId and interaction type
     */
    handleEntityInteraction(client, message) {
        const player = this.state.players.get(client.sessionId);
        const entity = this.state.entities.get(message.entityId);
        
        if (!player || !entity) return;
        
        // Call implementation-specific entity interaction handler
        this.onEntityInteraction(player, entity, message.interactionType);
    }
    
    /**
     * Implementation-specific entity interaction handler
     * To be overridden by subclasses
     * @param {Player} player The player that interacted
     * @param {BaseEntity} entity The entity that was interacted with
     * @param {string} interactionType The type of interaction
     */
    onEntityInteraction(player, entity, interactionType) {
        // Base implementation does nothing
        console.log(`Player ${player.id} interacted with entity ${entity.id} (${interactionType})`);
    }
    
    /**
     * Update game state - called once per simulation interval
     * Base implementation handles player movement and physics
     */
    update() {
        // Calculate delta time (assuming 30fps)
        const deltaTime = 1/30;
        
        // Process player inputs and update positions
        this.state.players.forEach((player, sessionId) => {
            // Skip if no input data
            if (!player.input) return;
            
            // Handle player movement based on input state
            this.updatePlayerFromInput(sessionId, player, player.input, deltaTime);
        });
        
        // Handle entity spawning if enabled
        if (this.spawnEnabled) {
            this.updateEntitySpawning(deltaTime);
        }
        
        // Call implementation-specific update
        this.implementationUpdate(deltaTime);
    }
    
    /**
     * Update entity spawning system
     * @param {number} deltaTime Time since last update
     */
    updateEntitySpawning(deltaTime) {
        this.spawnTimer += deltaTime;
        if (this.spawnTimer >= this.spawnInterval) {
            // Count current spawned entities
            let entityCount = 0;
            this.state.entities.forEach(entity => {
                if (entity.isSpawned) {
                    entityCount++;
                }
            });
            
            // Spawn entity if below maximum
            if (entityCount < this.maxEntities) {
                this.spawnEntity();
            }
            
            this.spawnTimer = 0;
            this.spawnInterval = this.getSpawnInterval();
        }
    }
    
    /**
     * Get spawn interval - can be overridden for random intervals
     * @returns {number} Spawn interval in seconds
     */
    getSpawnInterval() {
        return this.spawnInterval; // Default implementation returns fixed interval
    }
    
    /**
     * Spawn a new entity - to be implemented by subclasses
     */
    spawnEntity() {
        // Base implementation does nothing - to be overridden
        console.log("spawnEntity called but not implemented");
    }
    
    /**
     * Create and add entity to the game state
     * @param {string} id Entity ID
     * @param {BaseEntity} entity Entity instance
     * @param {Object} position Position {x, y, z}
     * @param {Object} rotation Rotation {x, y, z}
     * @returns {BaseEntity} The created entity
     */
    createEntity(id, entity, position, rotation) {
        // Set entity properties
        entity.id = id;
        
        // Set position
        if (position) {
            entity.x = position.x || 0;
            entity.y = position.y || 0;
            entity.z = position.z || 0;
        }
        
        // Set rotation if provided
        if (rotation) {
            entity.rotationX = rotation.x || 0;
            entity.rotationY = rotation.y || 0; 
            entity.rotationZ = rotation.z || 0;
        }
        
        // Add to state
        this.state.entities.set(id, entity);
        console.log(`Created entity ${id} at (${entity.x}, ${entity.y}, ${entity.z})`);
        
        return entity;
    }
    
    /**
     * Delete an entity from the game state
     * @param {string} id Entity ID
     * @returns {boolean} Whether entity was found and deleted
     */
    deleteEntity(id) {
        if (this.state.entities.has(id)) {
            this.state.entities.delete(id);
            console.log(`Deleted entity ${id}`);
            return true;
        }
        return false;
    }
    
    /**
     * Implementation-specific update logic
     * To be overridden by subclasses
     * @param {number} deltaTime Time since last update
     */
    implementationUpdate(deltaTime) {
        // Base implementation does nothing
    }
    
    /**
     * Update player position based on input state
     * @param {string} playerSessionId Player session ID
     * @param {Player} player Player object
     * @param {InputState} input Input state
     * @param {number} delta Time since last update
     */
    updatePlayerFromInput(playerSessionId, player, input, delta) {
        // Increase speed to make movement more noticeable
        const speed = 0.2;
        
        // Calculate movement based on the current player rotation or camera angle
        let dx = 0, dz = 0;
        
        // Determine which angle to use based on view mode
        const moveAngle = input.viewMode === "third-person" 
            ? input.thirdPersonCameraAngle // For third-person, move relative to camera angle
            : player.rotationY;            // For first-person, move relative to player facing
        
        // Check each movement key and apply appropriate movement
        if (input.keys && typeof input.keys === 'object') {
            // Remove verbose key logging
            
            if (input.keys.w) {
                // Forward movement: Move in the direction the player/camera is facing
                dx -= Math.sin(moveAngle) * speed;
                dz -= Math.cos(moveAngle) * speed;
            }
            
            if (input.keys.s) {
                // Backward movement: Move in the opposite direction
                dx += Math.sin(moveAngle) * speed;
                dz += Math.cos(moveAngle) * speed;
            }
            
            if (input.keys.a) {
                // Strafe left: Move perpendicular to the facing direction
                dx -= Math.sin(moveAngle + Math.PI/2) * speed;
                dz -= Math.cos(moveAngle + Math.PI/2) * speed;
            }
            
            if (input.keys.d) {
                // Strafe right: Move perpendicular to the facing direction
                dx += Math.sin(moveAngle + Math.PI/2) * speed;
                dz += Math.cos(moveAngle + Math.PI/2) * speed;
            }
            
            // Handle Q and E for rotating the player in third-person mode
            const rotationSpeed = 0.1;  // Increased rotation speed
            
            if (input.keys.q) {
                // Rotate player left (counter-clockwise)
                player.rotationY += rotationSpeed;
                // Normalize rotation
                player.rotationY = player.rotationY % (Math.PI * 2);
                if (player.rotationY < 0) player.rotationY += Math.PI * 2;
            }
            
            if (input.keys.e) {
                // Rotate player right (clockwise)
                player.rotationY -= rotationSpeed;
                // Normalize rotation
                player.rotationY = player.rotationY % (Math.PI * 2);
                if (player.rotationY < 0) player.rotationY += Math.PI * 2;
            }
            
            // Apply diagonal movement speed correction for all movement
            if ((input.keys.w || input.keys.s) && 
                (input.keys.a || input.keys.d)) {
                // Normalize diagonal movement speed
                const magnitude = Math.sqrt(dx * dx + dz * dz);
                if (magnitude > 0) {
                    dx = (dx / magnitude) * speed;
                    dz = (dz / magnitude) * speed;
                }
            }
        }
        
        // Update player position
        player.x += dx;
        player.z += dz;
        
        // Handle physics - gravity
        player.velocityY -= 0.01; // gravity
        player.y += player.velocityY;
        if (player.y < 1) {
            player.y = 1;
            player.velocityY = 0;
        }
        
        // Handle jumps
        if (input.keys && input.keys.space && player.y <= 1) {
            player.velocityY = 0.2; // Jump velocity
        }
        
        // Handle mouse movement (rotation) for players not sending direct rotation
        if (input.mouseDelta && input.mouseDelta.x !== 0 && input.mouseDelta.y !== 0) {
            // Apply mouse X movement to player rotation (horizontal looking)
            player.rotationY += input.mouseDelta.x * 0.002;
            
            // Normalize rotation to keep it within 0 to 2π range
            player.rotationY = player.rotationY % (Math.PI * 2);
            if (player.rotationY < 0) player.rotationY += Math.PI * 2;
            
            // Apply mouse Y movement to pitch (vertical looking, with limits)
            player.pitch += input.mouseDelta.y * 0.002;
            
            // Clamp pitch to prevent over-rotation
            player.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, player.pitch));
            
            // Reset mouseDelta after applying
            input.mouseDelta.x = 0;
            input.mouseDelta.y = 0;
        }
    }
    
    /**
     * Called when a client joins the room
     * @param {Client} client The client that joined
     * @param {Object} options Join options
     */
    onJoin(client, options) {
        console.log(`Client joined: ${client.sessionId}`);
        
        // Create a new player instance
        const player = new Player();
        
        // Set initial player position
        player.x = 0;
        player.y = 1;
        player.z = 0;
        
        // Set session ID as player ID
        player.id = client.sessionId;
        
        // Allow subclasses to modify player setup
        this.setupPlayer(player, client, options);
        
        // Add player to the game state
        this.state.players.set(client.sessionId, player);
    }
    
    /**
     * Player setup - to be implemented by subclasses
     * @param {Player} player The player object
     * @param {Client} client The client that joined
     * @param {Object} options Join options
     * @returns {Player} The modified player object
     */
    setupPlayer(player, client, options) {
        // Base implementation just returns the player
        return player;
    }
    
    /**
     * Called when a client leaves the room
     * @param {Client} client The client that left
     * @param {boolean} consented Whether the client consented to leaving
     */
    onLeave(client, consented) {
        console.log(`Client left: ${client.sessionId}`);
        
        // Remove player from the game state
        this.state.players.delete(client.sessionId);
    }
    
    /**
     * Generate a random position within the map
     * @param {number} minHeight Minimum height (y-coordinate)
     * @returns {Object} Position object {x, y, z}
     */
    generateRandomPosition(minHeight = 0) {
        const mapSize = this.state.gameConfig.mapSize;
        return {
            x: (Math.random() * mapSize) - (mapSize / 2),
            y: minHeight,
            z: (Math.random() * mapSize) - (mapSize / 2)
        };
    }
}

module.exports = { BaseRoom };  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\core\index.js 
===================================================== 
 
/**
 * 3D AI Game Platform - Server
 * Main entry point for the server
 */

const http = require('http');
const express = require('express');
const { Server } = require('colyseus');
const path = require('path');

// Import implementations
const DefaultImpl = require('../implementations/default');
const MathBlocksImpl = require('../implementations/numberblocks');

// Available implementations
const implementations = {
    "default": DefaultImpl,
    "numberblocks": MathBlocksImpl
};

// Server-side configuration
const serverConfig = {
    // Set the active implementation here - change this value to switch implementations
    activeImplementation: "default", // Options: "default", "numberblocks"
    port: process.env.PORT || 3000
};

/**
 * Main server class
 */
class GameServer {
    constructor() {
        // Create Express app and HTTP server
        this.app = express();
        this.server = http.createServer(this.app);
        
        // Configure app
        this.configureApp();
        
        // Create Colyseus server with correct configuration
        this.gameServer = new Server({
            server: this.server
        });
        
        // Register rooms for each implementation
        this.registerRooms();
    }
    
    /**
     * Configure Express app
     */
    configureApp() {
        // Set up static file serving
        this.app.use(express.static(path.join(__dirname, '../..', 'client')));
        
        // Serve the main index.html
        this.app.get('/', (req, res) => {
            res.sendFile(path.join(__dirname, '../..', 'client', 'index.html'));
        });
        
        // API endpoint to get current active implementation
        this.app.get('/api/config', (req, res) => {
            res.json({ 
                activeImplementation: serverConfig.activeImplementation,
                availableImplementations: Object.keys(implementations)
            });
        });
    }
    
    /**
     * Register room handlers for all implementations
     */
    registerRooms() {
        // Register each implementation's room
        for (const [implName, impl] of Object.entries(implementations)) {
            // Register implementation without logging each one
            const roomType = impl.implementation.roomType;
            const RoomClass = this.getRoomClass(impl);
            
            if (RoomClass) {
                this.gameServer.define(roomType, RoomClass);
            } else {
                console.warn(`No room class found for implementation: ${implName}`);
            }
        }
        
        // Set the active implementation as the default room
        if (implementations[serverConfig.activeImplementation]) {
            const activeImpl = implementations[serverConfig.activeImplementation];
            // Get the appropriate room from the implementation
            const RoomClass = this.getRoomClass(activeImpl);
            
            if (RoomClass) {
                this.gameServer.define('active', RoomClass);
            } else {
                console.warn(`No room class found for active implementation: ${serverConfig.activeImplementation}`);
                // Fallback to default if no room class found
                if (implementations.default && this.getRoomClass(implementations.default)) {
                    this.gameServer.define('active', this.getRoomClass(implementations.default));
                }
            }
        } else {
            // Fallback to default if specified implementation doesn't exist
            console.warn(`Specified implementation "${serverConfig.activeImplementation}" not found. Using "default" instead.`);
            const defaultRoomClass = this.getRoomClass(implementations.default);
            if (defaultRoomClass) {
                this.gameServer.define('active', defaultRoomClass);
            }
        }
    }
    
    /**
     * Helper method to get the room class from an implementation
     * @param {Object} implementation The implementation object
     * @returns {Class} The room class, or null if not found
     */
    getRoomClass(implementation) {
        if (implementation.DefaultRoom) {
            return implementation.DefaultRoom;
        } else if (implementation.NumberblocksRoom) {
            return implementation.NumberblocksRoom;
        } else if (implementation.ImplementationRoom) {
            return implementation.ImplementationRoom;
        }
        
        // Log what's available in the implementation for debugging
        console.log(`Available properties in implementation: ${Object.keys(implementation).join(', ')}`);
        return null;
    }
    
    /**
     * Start the server
     * @param {number} port Port to listen on
     */
    start(port = 3000) {
        this.server.listen(port, () => {
            console.log(`3D Game Platform server running on http://localhost:${port}`);
            console.log(`Available implementations: ${Object.keys(implementations).join(', ')}`);
            console.log(`Active implementation: ${serverConfig.activeImplementation}`);
        });
    }
    
    /**
     * Change the active implementation
     * @param {string} implementationName Name of the implementation to use
     */
    setActiveImplementation(implementationName) {
        if (implementations[implementationName]) {
            serverConfig.activeImplementation = implementationName;
            console.log(`Active implementation changed to: ${implementationName}`);
            
            // Re-register rooms to update active room
            this.registerRooms();
            
            return true;
        } else {
            console.warn(`Implementation "${implementationName}" not found. Active implementation remains unchanged.`);
            return false;
        }
    }
}

// Create and start server
const gameServer = new GameServer();
gameServer.start(serverConfig.port);

// Export server instance and configuration for external access and control
module.exports = { 
    gameServer,
    serverConfig,
    setActiveImplementation: (implName) => gameServer.setActiveImplementation(implName)
};  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\core\server.js 
===================================================== 
 
/**
 * 3D AI Game Platform
 * Entry point for the game server
 */

// Import the server module and implementation config
const { gameServer, serverConfig, setActiveImplementation } = require('./index');

// Simple implementation selector
console.log('\n===== 3D AI Game Platform =====');
console.log('Available implementations:');
console.log('1. default' + (serverConfig.activeImplementation === 'default' ? ' (current)' : ''));
console.log('2. numberblocks' + (serverConfig.activeImplementation === 'numberblocks' ? ' (current)' : ''));
console.log('\nCurrent implementation: ' + serverConfig.activeImplementation);

// Set up stdin to capture keypresses
process.stdin.setRawMode(true);
process.stdin.resume();
process.stdin.setEncoding('utf8');

let countdown = 10;
let countdownTimer;
let selected = false;

console.log(`\nPress 1 or 2 to select an implementation`);
console.log(`Starting with current implementation in ${countdown} seconds...`);

// Start countdown
countdownTimer = setInterval(() => {
    countdown--;
    
    if (countdown <= 0) {
        clearInterval(countdownTimer);
        if (!selected) {
            console.log(`\nUsing current implementation: ${serverConfig.activeImplementation}`);
            console.log('Server running on http://localhost:3000');
            process.stdin.setRawMode(false);
            process.stdin.pause();
        }
    } else {
        process.stdout.write(`\rStarting with current implementation in ${countdown} seconds...`);
    }
}, 1000);

// Handle key presses
process.stdin.on('data', (key) => {
    // Check for implementation selection keys
    if (key === '1') {
        selected = true;
        clearInterval(countdownTimer);
        if (serverConfig.activeImplementation !== 'default') {
            setActiveImplementation('default');
            console.log('\nImplementation set to: default');
        } else {
            console.log('\nImplementation already set to: default');
        }
        console.log('Server running on http://localhost:3000');
        process.stdin.setRawMode(false);
        process.stdin.pause();
    } else if (key === '2') {
        selected = true;
        clearInterval(countdownTimer);
        if (serverConfig.activeImplementation !== 'numberblocks') {
            setActiveImplementation('numberblocks');
            console.log('\nImplementation set to: numberblocks');
        } else {
            console.log('\nImplementation already set to: numberblocks');
        }
        console.log('Server running on http://localhost:3000');
        process.stdin.setRawMode(false);
        process.stdin.pause();
    } else if (key === '\u0003') { // Ctrl+C
        process.exit();
    }
});
 
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\core\schemas\BaseEntity.js 
===================================================== 
 
const { Schema, type } = require("@colyseus/schema");

/**
 * Base entity schema for all game entities
 * This class provides common properties and methods for all entities
 */
class BaseEntity extends Schema {
    constructor() {
        super();
        this.id = "";             // Unique identifier
        this.type = "";           // Entity type (e.g., "player", "npc", "static")
        this.x = 0;               // Position X
        this.y = 0;               // Position Y 
        this.z = 0;               // Position Z
        this.rotationY = 0;       // Rotation around Y axis (yaw)
        this.value = 1;           // Generic value - meaning depends on implementation
        this.color = "#FFFFFF";   // Color in hex format
    }
}

// Register schema types
type("string")(BaseEntity.prototype, "id");
type("string")(BaseEntity.prototype, "type");
type("number")(BaseEntity.prototype, "x");
type("number")(BaseEntity.prototype, "y");
type("number")(BaseEntity.prototype, "z");
type("number")(BaseEntity.prototype, "rotationY");
type("number")(BaseEntity.prototype, "value");
type("string")(BaseEntity.prototype, "color");

module.exports = { BaseEntity };  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\core\schemas\DefaultRoom.js 
===================================================== 
 
const { BaseRoom } = require("../BaseRoom");

/**
 * Default Room
 * Basic implementation with box players
 */
class DefaultRoom extends BaseRoom {
    /**
     * Initialize the default room implementation
     * @param {Object} options Room creation options
     */
    initializeImplementation(options) {
        console.log("Default room implementation initialized");
        
        // Update game config
        this.state.gameConfig.implementation = "default";
        
        // Everything else is handled by BaseRoom
    }
    
    /**
     * Default implementation update logic is not needed
     * BaseRoom handles all necessary functionality
     * @param {number} deltaTime Time since last update
     */
    implementationUpdate(deltaTime) {
        // Nothing to do in the default implementation
    }
    
    /**
     * Default player setup - just basic box
     * @param {Player} player The player object
     * @param {Client} client The client that joined
     * @param {Object} options Join options
     * @returns {Player} The player object
     */
    setupPlayer(player, client, options) {
        // Set player name
        player.name = options.name || client.sessionId;
        
        // Set a default color
        player.color = "#" + Math.floor(Math.random()*16777215).toString(16);
        
        return player;
    }
}

module.exports = { DefaultRoom };  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\core\schemas\GameConfigSchema.js 
===================================================== 
 
const { Schema, type } = require("@colyseus/schema");

/**
 * Game configuration schema
 * Replaces the generic object type with a properly typed schema
 */
class GameConfigSchema extends Schema {
    constructor() {
        super();
        this.implementation = "default"; 
        this.mode = "standard";               // Game mode
        this.maxPlayers = 10;                 // Maximum number of players
        this.mapSize = 40;                    // Size of the map
    }
}

// Register schema types
type("string")(GameConfigSchema.prototype, "implementation");
type("string")(GameConfigSchema.prototype, "mode");
type("number")(GameConfigSchema.prototype, "maxPlayers");
type("number")(GameConfigSchema.prototype, "mapSize");

module.exports = { GameConfigSchema };  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\core\schemas\GameState.js 
===================================================== 
 
const { Schema, MapSchema, type } = require("@colyseus/schema");
const { Player } = require("./Player");
const { GameConfigSchema } = require("./GameConfigSchema");

/**
 * Game state schema for the entire game
 * Contains collections of all entities in the game
 */
class GameState extends Schema {
    constructor() {
        super();
        // All players in the game
        this.players = new MapSchema();
        
        // All entities in the game - can be implementation-specific
        this.entities = new MapSchema();
        
        // Game configuration and state - using schema instead of plain object
        this.gameConfig = new GameConfigSchema();
    }
}

// Register schema types
type({ map: Player })(GameState.prototype, "players");
type({ map: Schema })(GameState.prototype, "entities");
type(GameConfigSchema)(GameState.prototype, "gameConfig");

module.exports = { GameState };  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\core\schemas\ImplementationDataSchema.js 
===================================================== 
 
const { Schema, type, MapSchema } = require("@colyseus/schema");

/**
 * Implementation data schema
 * Replaces the generic object type with a properly typed schema
 * Uses a MapSchema to allow for dynamic key-value pairs
 */
class ImplementationDataSchema extends Schema {
    constructor() {
        super();
        // Using a MapSchema to store dynamic properties for implementation-specific data
        this.properties = new MapSchema();
        
        // Common implementation properties
        this.value = 1;   // Default value
        this.color = "";  // Color value as string
    }
}

// Register schema types
type({ map: "string" })(ImplementationDataSchema.prototype, "properties");
type("number")(ImplementationDataSchema.prototype, "value");
type("string")(ImplementationDataSchema.prototype, "color");

module.exports = { ImplementationDataSchema };  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\core\schemas\InputState.js 
===================================================== 
 
const { Schema, type } = require("@colyseus/schema");

/**
 * Input state schema for player input
 */
class InputState extends Schema {
    constructor() {
        super();
        // Initialize keys as a KeysSchema instance, not a plain object
        this.keys = new KeysSchema();
        this.mouseDelta = new MouseDeltaSchema();
        this.viewMode = "third-person"; // Default view mode - "first-person", "third-person", "free-roam"
        this.thirdPersonCameraAngle = 0; // Camera angle for third-person view
    }
}

// Define nested schemas for proper serialization
class KeysSchema extends Schema {
    constructor() {
        super();
        this.w = false;
        this.a = false;
        this.s = false;
        this.d = false;
        this.space = false;
        this.q = false;
        this.e = false;
        this.shift = false;
    }
}

class MouseDeltaSchema extends Schema {
    constructor() {
        super();
        this.x = 0;
        this.y = 0;
    }
}

// Register schema types for nested schemas
type("boolean")(KeysSchema.prototype, "w");
type("boolean")(KeysSchema.prototype, "a");
type("boolean")(KeysSchema.prototype, "s");
type("boolean")(KeysSchema.prototype, "d");
type("boolean")(KeysSchema.prototype, "space");
type("boolean")(KeysSchema.prototype, "q");
type("boolean")(KeysSchema.prototype, "e");
type("boolean")(KeysSchema.prototype, "shift");

type("number")(MouseDeltaSchema.prototype, "x");
type("number")(MouseDeltaSchema.prototype, "y");

// Register the schema types for InputState
type(KeysSchema)(InputState.prototype, "keys");
type(MouseDeltaSchema)(InputState.prototype, "mouseDelta");
type("string")(InputState.prototype, "viewMode");
type("number")(InputState.prototype, "thirdPersonCameraAngle");

module.exports = { InputState, KeysSchema, MouseDeltaSchema };  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\core\schemas\Player.js 
===================================================== 
 
const { type } = require("@colyseus/schema");
const { BaseEntity } = require("./BaseEntity");
const { InputState } = require("./InputState");
const { ImplementationDataSchema } = require("./ImplementationDataSchema");

/**
 * Player schema for all player entities
 * Extends BaseEntity with player-specific properties
 */
class Player extends BaseEntity {
    constructor() {
        super();
        this.type = "player";      // Entity type
        this.name = "";            // Player name
        this.pitch = 0;            // Camera pitch (looking up/down)
        this.velocityY = 0;        // Vertical velocity (for physics)
        this.input = new InputState(); // Player input state
        
        // Implementation-specific properties can be added by subclasses
        this.implementationType = ""; // Type of implementation
        this.implementationData = new ImplementationDataSchema(); // Implementation-specific data
    }
}

// Register schema types - inherit from BaseEntity
type("string")(Player.prototype, "name");
type("number")(Player.prototype, "pitch");
type("number")(Player.prototype, "velocityY");
type(InputState)(Player.prototype, "input");
type("string")(Player.prototype, "implementationType");
type(ImplementationDataSchema)(Player.prototype, "implementationData");

module.exports = { Player };  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\implementations\default\index.js 
===================================================== 
 
/**
 * Default Implementation
 * A simple implementation with basic box players
 */

const { DefaultRoom } = require("../../core/schemas/DefaultRoom");

// Default implementation information
const implementation = {
    name: "default",
    description: "A simple implementation with basic box players",
    roomType: "default"
};

module.exports = {
    implementation,
    DefaultRoom
};  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\implementations\numberblocks\index.js 
===================================================== 
 
/**
 * Numberblocks Implementation Index
 * Exports all components of the Numberblocks implementation
 */

const { ImplementationPlayer, Operator, StaticValueEntity } = require('./schemas');
const { NumberblocksRoom } = require('./NumberblocksRoom');

module.exports = {
    // Schemas
    ImplementationPlayer,
    Operator,
    StaticValueEntity,
    
    // Room
    NumberblocksRoom,
    
    // Implementation information
    implementation: {
        name: "numberblocks",
        description: "Mathematical building blocks game",
        version: "1.0.0",
        roomType: "numberblocks"
    }
};  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\implementations\numberblocks\NumberblocksRoom.js 
===================================================== 
 
const { BaseRoom } = require("../../core/BaseRoom");
const { ImplementationPlayer, Operator, StaticValueEntity } = require("./schemas");

/**
 * Numberblocks implementation of the game room
 * Extends BaseRoom with Numberblocks-specific functionality
 */
class NumberblocksRoom extends BaseRoom {
    /**
     * Initialize Numberblocks-specific functionality
     * @param {Object} options Room creation options
     */
    initializeImplementation(options) {
        console.log("Numberblocks implementation initialized");
        
        // Update game config
        this.state.gameConfig.implementation = "numberblocks";
        
        // Setup operator spawning system
        this.spawnEnabled = true;
        this.spawnInterval = this.getRandomSpawnInterval();
        this.maxEntities = 10; // Maximum operators in the world
        
        // Setup static value entities
        this.createStaticValueEntity("static1", 2, 2, 0, -5);
        this.createStaticValueEntity("static2", 3, 5, 0, -5);
        this.createStaticValueEntity("static3", 4, -5, 0, -5);
        this.createStaticValueEntity("static4", 5, 0, 0, -10);
        this.createStaticValueEntity("static5", 1, 5, 0, -10);
        
        // Listen for implementation-specific messages
        this.onMessage("playerCollision", (client, message) => {
            this.handlePlayerCollision(client, message);
        });
    }
    
    /**
     * Override the base entity interaction handler
     */
    onEntityInteraction(player, entity, interactionType) {
        if (interactionType === "collect" && entity.type === "operator") {
            // Set the player's operator
            player.operator = entity.operatorType;
            
            // Remove operator from state
            this.deleteEntity(entity.id);
            console.log(`Player ${player.id} collected ${entity.operatorType} operator`);
        }
    }
    
    /**
     * Handle player collision message from client
     * @param {Client} client The client that sent the message
     * @param {Object} message The message sent by the client
     */
    handlePlayerCollision(client, message) {
        const player = this.state.players.get(client.sessionId);
        const targetId = message.targetId;
        let target;
        
        // Check if target is another player or a static value entity
        if (this.state.players.has(targetId)) {
            target = this.state.players.get(targetId);
        } else if (this.state.entities.has(targetId) && 
                   this.state.entities.get(targetId).type === "staticValueEntity") {
            target = this.state.entities.get(targetId);
        }
        
        if (player && target) {
            // Handle the collision based on operator
            if (player.operator === "plus") {
                player.value += target.value;
                player.operator = "";
            } else if (player.operator === "minus" && player.value > target.value) {
                player.value -= target.value;
                player.operator = "";
            }
        }
    }
    
    /**
     * Override the base spawn interval method
     * @returns {number} Random spawn interval between 5-10 seconds
     */
    getSpawnInterval() {
        return 5 + Math.random() * 5; // 5-10 seconds
    }
    
    /**
     * Override the base spawn entity method
     * Spawns a new operator entity
     */
    spawnEntity() {
        const id = `op_${Math.floor(Math.random() * 10000)}`;
        const operatorType = Math.random() > 0.5 ? "plus" : "minus";
        
        // Create operator
        const operator = new Operator();
        operator.operatorType = operatorType;
        operator.isSpawned = true;
        
        // Set position slightly above ground
        const position = this.generateRandomPosition(0.6);
        
        // Use base createEntity method
        this.createEntity(id, operator, position);
        
        console.log(`Spawned ${operatorType} operator at (${position.x.toFixed(2)}, ${position.y}, ${position.z.toFixed(2)})`);
    }
    
    /**
     * Create a static value entity
     * @param {string} id Unique identifier
     * @param {number} value Entity value
     * @param {number} x X-coordinate
     * @param {number} y Y-coordinate
     * @param {number} z Z-coordinate
     */
    createStaticValueEntity(id, value, x, y, z) {
        // Create static value entity
        const staticEntity = new StaticValueEntity();
        staticEntity.value = value;
        
        // Create using the base createEntity method
        this.createEntity(id, staticEntity, { x, y, z });
        
        console.log(`Created static value entity ${id} with value ${value} at (${x}, ${y}, ${z})`);
    }
    
    /**
     * Setup player for implementation
     * @param {Player} player The player object
     * @param {Client} client The client that joined
     * @param {Object} options Join options
     * @returns {ImplementationPlayer} The implementation player
     */
    setupPlayer(player, client, options) {
        // Create an implementation player
        const implementationPlayer = new ImplementationPlayer();
        
        // Copy base player properties to the implementation player
        implementationPlayer.id = player.id;
        implementationPlayer.x = player.x;
        implementationPlayer.y = player.y;
        implementationPlayer.z = player.z;
        implementationPlayer.rotationY = player.rotationY || 0;
        
        // Set name and color
        implementationPlayer.name = options.name || client.sessionId;
        implementationPlayer.color = this.getColorForNumber(1);
        
        // Set initial value
        implementationPlayer.value = 1;
        
        console.log(`Created player ${implementationPlayer.name} with value ${implementationPlayer.value}`);
        
        return implementationPlayer;
    }
    
    /**
     * Get color for a value
     * @param {number} number The number to get color for
     * @returns {string} Color in hex format
     */
    getColorForNumber(number) {
        const colors = [
            "#FFFFFF", // White (placeholder, not used)
            "#FF0000", // 1: Red
            "#FFA500", // 2: Orange
            "#FFFF00", // 3: Yellow
            "#00FF00", // 4: Green
            "#0000FF", // 5: Blue
            "#800080", // 6: Purple
            "#FFC0CB", // 7: Pink
            "#A52A2A", // 8: Brown
            "#00FFFF", // 9: Cyan
            "#FF00FF"  // 10: Magenta
        ];
        
        // Use modulo for numbers greater than our color array
        return colors[number % colors.length] || "#FFFFFF";
    }
}

module.exports = { NumberblocksRoom };  
 
===================================================== 
FILE: C:\Users\ksbad\OneDrive\Documents\3D-AI-GAME\server\implementations\numberblocks\schemas.js 
===================================================== 
 
const { Schema, type, defineTypes } = require("@colyseus/schema");
const { BaseEntity } = require("../../core/schemas/BaseEntity");
const { Player } = require("../../core/schemas/Player");

/**
 * Implementation player schema - extends the Player schema
 * Adds implementation-specific properties
 */
class ImplementationPlayer extends Player {
    constructor() {
        super();
        this.implementationType = "numberblocks"; // Keep this one reference to the implementation
        this.operator = ""; // "plus" or "minus"
    }
}

// Register schema types
type("string")(ImplementationPlayer.prototype, "operator");

/**
 * Operator entity schema - extends BaseEntity
 * Represents mathematical operators in the game
 */
class Operator extends BaseEntity {
    constructor() {
        super();
        this.type = "operator";
        this.operatorType = ""; // "plus" or "minus"
    }
}

// Register schema types
type("string")(Operator.prototype, "operatorType");

/**
 * Static entity schema - extends BaseEntity
 * Represents static objects in the game that don't move
 */
class StaticValueEntity extends BaseEntity {
    constructor() {
        super();
        this.type = "staticValueEntity";
        this.isStatic = true;     // Flag indicating this is a static entity
        this.isInteractable = true; // Whether this block can be interacted with
    }
}

// Register only the new properties that aren't already in BaseEntity
type("boolean")(StaticValueEntity.prototype, "isStatic");
type("boolean")(StaticValueEntity.prototype, "isInteractable");

module.exports = {
    ImplementationPlayer,
    Operator,
    StaticValueEntity
};  
 
