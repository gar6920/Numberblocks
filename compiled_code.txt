===================================================== 
NUMBERBLOCKS GAME - COMPLETE CODE COMPILATION 
===================================================== 
 
===================================================== 
FILE: debug-test.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numberblocks Debug Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #debug-canvas { width: 100%; height: 100%; display: block; }
        #debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            z-index: 1000;
            max-width: 400px;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <canvas id="debug-canvas"></canvas>
    <div id="debug-info">Loading...</div>
    
    <!-- Load Three.js library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    
    <script>
        // Debug log function
        function log(message) {
            console.log(message);
            const debugInfo = document.getElementById('debug-info');
            debugInfo.innerHTML += `<div>${message}</div>`;
        }
        
        // Error handler
        window.onerror = function(message, source, lineno, colno, error) {
            log(`ERROR: ${message} at ${source}:${lineno}`);
            return false;
        };
        
        // Initialize everything
        window.addEventListener('load', () => {
            log('Page loaded, initializing Three.js');
            
            // Check if Three.js is available
            if (typeof THREE === 'undefined') {
                log('ERROR: THREE is not defined! Check network connection or CDN link.');
                return;
            }
            
            log(`THREE.js version ${THREE.REVISION} loaded successfully`);
            
            try {
                // Create scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue
                log('Scene created with blue background');
                
                // Create camera
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 0, 0);
                log(`Camera created at position (${camera.position.x}, ${camera.position.y}, ${camera.position.z})`);
                
                // Create renderer
                const canvas = document.getElementById('debug-canvas');
                if (!canvas) {
                    log('ERROR: Canvas element not found!');
                    return;
                }
                
                const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                log('Renderer created and attached to canvas');
                
                // Check if renderer is working properly
                if (!renderer.domElement) {
                    log('ERROR: Renderer domElement is not available!');
                    return;
                }
                
                // Create a simple ground plane
                const groundGeometry = new THREE.BoxGeometry(50, 0.1, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x7CFC00, // Green
                    roughness: 0.8, 
                    metalness: 0.2 
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.position.y = -0.05;
                scene.add(ground);
                log('Ground plane added to scene');
                
                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                // Add directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                scene.add(directionalLight);
                log('Lights added to scene');
                
                // Add a visible object to confirm rendering
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.set(0, 1, 0);
                scene.add(cube);
                log('Red cube added to center of scene for visibility test');
                
                // Testing WebGL capabilities
                log('WebGL Capabilities:');
                const gl = renderer.getContext();
                log(`Max texture size: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}`);
                log(`WebGL version: ${gl.getParameter(gl.VERSION)}`);
                log(`Renderer: ${gl.getParameter(gl.RENDERER)}`);
                log(`Vendor: ${gl.getParameter(gl.VENDOR)}`);
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    // Rotate the cube to make it obvious if rendering is working
                    cube.rotation.x += 0.01;
                    cube.rotation.y += 0.01;
                    
                    // Render the scene
                    renderer.render(scene, camera);
                }
                
                // Start animation
                animate();
                log('Animation loop started');
                
                // Add window resize handler
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    log('Window resized, canvas adjusted');
                });
                
                log('Debug test initialization complete, you should see a rotating red cube');
            } catch (e) {
                log(`CRITICAL ERROR: ${e.message}`);
                log(`Stack trace: ${e.stack}`);
            }
        });
    </script>
</body>
</html>
 
 
===================================================== 
FILE: index.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numberblocks Game</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <canvas id="game-canvas"></canvas>
    
    <div id="controls-info" class="overlay">
        <h2>Numberblocks Game</h2>
        <p>Click anywhere to enable controls</p>
        <ul>
            <li>Move: WASD or Arrow Keys</li>
            <li>Jump: Space</li>
            <li>Look: Mouse</li>
        </ul>
    </div>
    
    <!-- Three.js library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    
    <!-- Game JavaScript files -->
    <script src="js/controls.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
 
 
===================================================== 
FILE: css\styles.css 
===================================================== 
 
/* Reset default margins and padding */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body, html {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: Arial, sans-serif;
}

/* Make the canvas fill the entire screen */
#game-canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* Controls info overlay */
.overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    z-index: 100;
}

.overlay h2 {
    margin-bottom: 10px;
}

.overlay p {
    margin-bottom: 15px;
}

.overlay ul {
    list-style-type: none;
    text-align: left;
    margin: 0 auto;
    display: inline-block;
}

.overlay ul li {
    margin-bottom: 5px;
}
 
 
===================================================== 
FILE: js\controls.js 
===================================================== 
 
// Numberblocks game - First-person controls implementation

// Global variables
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let canJump = false;

let prevTime = performance.now();
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();

// Player settings
const playerHeight = 2.0;             // Height of camera from ground
const moveSpeed = 5.0;                // Units per second
const jumpHeight = 5.0;               // Jump impulse force
const gravity = 9.8;                  // Gravity force 

// Flag to force fallback controls (for environments like browser previews)
const forceFallbackControls = true;

// Initialize controls for the camera
function initControls(camera, domElement) {
    // Always use fallback controls in browser preview environments
    if (forceFallbackControls) {
        console.log('Using fallback controls for preview environment');
        return createFallbackControls(camera, domElement);
    }
    
    // For non-preview environments, try to use PointerLockControls
    try {
        // Test if Pointer Lock API is supported
        if (!document.pointerLockElement && 
            !document.mozPointerLockElement && 
            !document.webkitPointerLockElement) {
            console.log('Pointer Lock API not available, using fallback controls');
            return createFallbackControls(camera, domElement);
        }
        
        // Create PointerLockControls
        const controls = new THREE.PointerLockControls(camera, domElement);
        
        // Set up click event
        domElement.addEventListener('click', () => {
            controls.lock();
        });
        
        // Event listeners for controls state
        controls.addEventListener('lock', () => {
            console.log('Controls locked');
            document.getElementById('controls-info').style.display = 'none';
        });
        
        controls.addEventListener('unlock', () => {
            console.log('Controls unlocked');
            document.getElementById('controls-info').style.display = 'block';
        });
        
        // Add keyboard controls
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        return controls;
    } catch (e) {
        console.log('Error initializing controls, using fallback:', e);
        return createFallbackControls(camera, domElement);
    }
}

// Create improved fallback controls
function createFallbackControls(camera, domElement) {
    console.log('Creating fallback controls');

    const pitchObject = new THREE.Object3D();
    pitchObject.add(camera);

    const controlsObject = new THREE.Object3D();
    controlsObject.add(pitchObject);

    const mockControls = {
        isLocked: false,
        getObject: function() {
            return controlsObject;
        },
        moveForward: function(distance) {
            const dir = new THREE.Vector3(0, 0, -1);
            dir.applyQuaternion(controlsObject.quaternion);
            controlsObject.position.add(dir.multiplyScalar(distance));
        },
        moveRight: function(distance) {
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(controlsObject.quaternion);
            controlsObject.position.add(right.multiplyScalar(distance));
        },
        lock: function() {
            this.isLocked = true;
            document.getElementById('controls-info').style.display = 'none';
            document.body.style.cursor = 'none';
            this.dispatchEvent({ type: 'lock' });
        },
        unlock: function() {
            this.isLocked = false;
            document.getElementById('controls-info').style.display = 'block';
            document.body.style.cursor = 'auto';
            this.dispatchEvent({ type: 'unlock' });
        },
        _listeners: {},
        addEventListener: function(type, listener) {
            this._listeners[type] = this._listeners[type] || [];
            this._listeners[type].push(listener);
        },
        dispatchEvent: function(event) {
            const listeners = this._listeners[event.type];
            if (listeners) {
                listeners.forEach(callback => callback.call(this, event));
            }
        }
    };

    // Mouse movement handling
    document.addEventListener('mousemove', function(event) {
        if (!mockControls.isLocked) return;

        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;

        controlsObject.rotation.y -= movementX * 0.002; // Horizontal rotation (yaw)
        pitchObject.rotation.x -= movementY * 0.002; // Vertical rotation (pitch)

        // Limit vertical rotation (pitch) to avoid flipping
        pitchObject.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchObject.rotation.x));
    });

    domElement.addEventListener('click', () => {
        mockControls.lock();
    });

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    document.addEventListener('keydown', function(event) {
        if (event.code === 'Escape' && mockControls.isLocked) {
            mockControls.unlock();
        }
    });

    return mockControls;
}

// Key down event handler
function onKeyDown(event) {
    // Skip if we're in an input field or textarea
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        return;
    }
    
    switch (event.code) {
        case 'KeyW':
        case 'ArrowUp':
            moveForward = true;
            break;
            
        case 'KeyA':
        case 'ArrowLeft':
            moveLeft = true;
            break;
            
        case 'KeyS':
        case 'ArrowDown':
            moveBackward = true;
            break;
            
        case 'KeyD':
        case 'ArrowRight':
            moveRight = true;
            break;
            
        case 'Space':
            if (canJump) {
                velocity.y = jumpHeight;
            }
            canJump = false;
            break;
    }
}

// Key up event handler
function onKeyUp(event) {
    switch (event.code) {
        case 'KeyW':
        case 'ArrowUp':
            moveForward = false;
            break;
            
        case 'KeyA':
        case 'ArrowLeft':
            moveLeft = false;
            break;
            
        case 'KeyS':
        case 'ArrowDown':
            moveBackward = false;
            break;
            
        case 'KeyD':
        case 'ArrowRight':
            moveRight = false;
            break;
    }
}

// Update controls - call this in the animation loop
function updateControls(controls, delta) {
    // Only update if controls are locked
    if (controls.isLocked === false) return;
    
    // Apply gravity and handle jumping
    velocity.y -= gravity * delta;
    
    // Calculate movement direction
    direction.z = Number(moveForward) - Number(moveBackward);
    direction.x = Number(moveRight) - Number(moveLeft);
    direction.normalize(); // Normalize for consistent movement speed
    
    // Apply movement
    if (moveForward || moveBackward) {
        controls.moveForward(direction.z * moveSpeed * delta);
    }
    
    if (moveLeft || moveRight) {
        controls.moveRight(direction.x * moveSpeed * delta);
    }
    
    // Apply gravity
    controls.getObject().position.y += velocity.y * delta;
    
    // Check if we're on ground
    if (controls.getObject().position.y < playerHeight) {
        velocity.y = 0;
        controls.getObject().position.y = playerHeight;
        canJump = true;
    }
}
 
 
===================================================== 
FILE: js\main.js 
===================================================== 
 
// Numberblocks game - Three.js implementation
console.log('Numberblocks game initializing...');

// Global variables
let scene, camera, renderer;
let ground;
let controls;
let clock;

// Initialize the Three.js scene
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky blue background
    
    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    
    renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('game-canvas'),
        antialias: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    createGround();
    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);
    
    // Add landscape elements for perspective
    createLandscapeElements();
    
    controls = initControls(camera, renderer.domElement);

    // CRITICAL FIX: Explicitly set position on controls object (not camera directly)
    controls.getObject().position.set(0, 2, 5);
    scene.add(controls.getObject());
    
    clock = new THREE.Clock();
    window.addEventListener('resize', onWindowResize);
    animate();
}

// Create the ground plane
function createGround() {
    // Create a large flat plane for the ground
    const groundGeometry = new THREE.BoxGeometry(50, 0.1, 50);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x7CFC00, // Lawn green color
        roughness: 0.8,
        metalness: 0.2
    });
    
    ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.05; // Move it slightly down to center it
    scene.add(ground);
}

// Create random landscape elements for perspective
function createLandscapeElements() {
    // Define bright colors that match Numberblocks aesthetic
    const colors = [
        0xFF0000, // Red (One)
        0xFFA500, // Orange (Two)
        0xFFFF00, // Yellow (Three)
        0x00FF00, // Green (Four)
        0x0000FF, // Blue (Five)
        0x800080, // Purple (Six)
        0xFFC0CB, // Pink (Seven)
        0xA52A2A, // Brown (Eight)
        0x808080  // Grey (Nine)
    ];
    
    // Create 30 random objects
    for (let i = 0; i < 30; i++) {
        let geometry, material, mesh;
        const shapeType = Math.floor(Math.random() * 4); // 0-3 for different shapes
        const colorIndex = Math.floor(Math.random() * colors.length);
        const color = colors[colorIndex];
        
        // Create different shapes
        switch (shapeType) {
            case 0: // Cube (like Numberblock parts)
                const size = 0.5 + Math.random() * 1.5;
                geometry = new THREE.BoxGeometry(size, size, size);
                break;
            case 1: // Cylinder
                const radius = 0.3 + Math.random() * 1;
                const height = 1 + Math.random() * 3;
                geometry = new THREE.CylinderGeometry(radius, radius, height, 16);
                break;
            case 2: // Sphere
                const sphereRadius = 0.5 + Math.random() * 1;
                geometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
                break;
            case 3: // Cone
                const coneRadius = 0.5 + Math.random() * 1;
                const coneHeight = 1 + Math.random() * 2;
                geometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
                break;
        }
        
        // Create material with random color
        material = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        // Create and position the mesh
        mesh = new THREE.Mesh(geometry, material);
        
        // Position randomly on the ground plane (within a 40x40 area)
        const posX = (Math.random() * 40) - 20;
        const posZ = (Math.random() * 40) - 20;
        
        // Calculate Y position based on the shape's height
        let posY;
        if (shapeType === 0) { // Cube
            posY = mesh.geometry.parameters.height / 2;
        } else if (shapeType === 1) { // Cylinder
            posY = mesh.geometry.parameters.height / 2;
        } else if (shapeType === 2) { // Sphere
            posY = mesh.geometry.parameters.radius;
        } else { // Cone
            posY = mesh.geometry.parameters.height / 2;
        }
        
        mesh.position.set(posX, posY, posZ);
        
        // Add random rotation for more variety
        mesh.rotation.y = Math.random() * Math.PI * 2;
        
        // Add to scene
        scene.add(mesh);
    }
    
    // Add some trees as landmarks
    createTrees();
}

// Create simple trees as landmarks
function createTrees() {
    for (let i = 0; i < 10; i++) {
        // Create trunk
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 2, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513, // Brown
            roughness: 0.9
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        
        // Create foliage (as a cone)
        const foliageGeometry = new THREE.ConeGeometry(1.5, 3, 8);
        const foliageMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22, // Forest green
            roughness: 0.8
        });
        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
        foliage.position.y = 2.5; // Position on top of trunk
        
        // Create tree group
        const tree = new THREE.Group();
        tree.add(trunk);
        tree.add(foliage);
        
        // Position randomly on the ground plane but away from center
        let posX, posZ, distance;
        do {
            posX = (Math.random() * 40) - 20;
            posZ = (Math.random() * 40) - 20;
            distance = Math.sqrt(posX * posX + posZ * posZ);
        } while (distance < 8); // Keep trees away from spawn point
        
        tree.position.set(posX, 1, posZ); // Position with trunk base on ground
        
        // Add to scene
        scene.add(tree);
    }
}

// Handle window resize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Animation loop
function animate() {
    requestAnimationFrame(animate);
    
    // Calculate time delta for smooth movement
    const delta = clock.getDelta();
    
    // Update controls if they exist
    if (controls) {
        updateControls(controls, delta);
    }
    
    renderer.render(scene, camera);
}

// Initialize the scene when the page loads
document.addEventListener('DOMContentLoaded', init);
 
 
===================================================== 
FILE: js\numberblock.js 
===================================================== 
 
 
 
