===================================================== 
NUMBERBLOCKS GAME - COMPLETE CODE COMPILATION 
===================================================== 
 
===================================================== 
FILE: debug-test.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numberblocks Debug Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #debug-canvas { width: 100%; height: 100%; display: block; }
        #debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            z-index: 1000;
            max-width: 400px;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <canvas id="debug-canvas"></canvas>
    <div id="debug-info">Loading...</div>
    
    <!-- Load Three.js library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    
    <script>
        // Debug log function
        function log(message) {
            console.log(message);
            const debugInfo = document.getElementById('debug-info');
            debugInfo.innerHTML += `<div>${message}</div>`;
        }
        
        // Error handler
        window.onerror = function(message, source, lineno, colno, error) {
            log(`ERROR: ${message} at ${source}:${lineno}`);
            return false;
        };
        
        // Initialize everything
        window.addEventListener('load', () => {
            log('Page loaded, initializing Three.js');
            
            // Check if Three.js is available
            if (typeof THREE === 'undefined') {
                log('ERROR: THREE is not defined! Check network connection or CDN link.');
                return;
            }
            
            log(`THREE.js version ${THREE.REVISION} loaded successfully`);
            
            try {
                // Create scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue
                log('Scene created with blue background');
                
                // Create camera
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 0, 0);
                log(`Camera created at position (${camera.position.x}, ${camera.position.y}, ${camera.position.z})`);
                
                // Create renderer
                const canvas = document.getElementById('debug-canvas');
                if (!canvas) {
                    log('ERROR: Canvas element not found!');
                    return;
                }
                
                const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                log('Renderer created and attached to canvas');
                
                // Check if renderer is working properly
                if (!renderer.domElement) {
                    log('ERROR: Renderer domElement is not available!');
                    return;
                }
                
                // Create a simple ground plane
                const groundGeometry = new THREE.BoxGeometry(50, 0.1, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x7CFC00, // Green
                    roughness: 0.8, 
                    metalness: 0.2 
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.position.y = -0.05;
                scene.add(ground);
                log('Ground plane added to scene');
                
                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                // Add directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                scene.add(directionalLight);
                log('Lights added to scene');
                
                // Add a visible object to confirm rendering
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.set(0, 1, 0);
                scene.add(cube);
                log('Red cube added to center of scene for visibility test');
                
                // Testing WebGL capabilities
                log('WebGL Capabilities:');
                const gl = renderer.getContext();
                log(`Max texture size: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}`);
                log(`WebGL version: ${gl.getParameter(gl.VERSION)}`);
                log(`Renderer: ${gl.getParameter(gl.RENDERER)}`);
                log(`Vendor: ${gl.getParameter(gl.VENDOR)}`);
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    // Rotate the cube to make it obvious if rendering is working
                    cube.rotation.x += 0.01;
                    cube.rotation.y += 0.01;
                    
                    // Render the scene
                    renderer.render(scene, camera);
                }
                
                // Start animation
                animate();
                log('Animation loop started');
                
                // Add window resize handler
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    log('Window resized, canvas adjusted');
                });
                
                log('Debug test initialization complete, you should see a rotating red cube');
            } catch (e) {
                log(`CRITICAL ERROR: ${e.message}`);
                log(`Stack trace: ${e.stack}`);
            }
        });
    </script>
</body>
</html>
 
 
===================================================== 
FILE: index.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numberblocks Game</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <canvas id="game-canvas"></canvas>
    
    <div id="controls-info" class="overlay">
        <h2>Numberblocks Game</h2>
        <p>Click anywhere to enable controls</p>
        <ul>
            <li>Move: WASD or Arrow Keys</li>
            <li>Jump: Space</li>
            <li>Look: Mouse</li>
        </ul>
    </div>
    
    <!-- Three.js library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    
    <!-- Game JavaScript files -->
    <script src="js/controls.js"></script>
    <script src="js/numberblock.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
 
 
===================================================== 
FILE: css\styles.css 
===================================================== 
 
/* Reset default margins and padding */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body, html {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: Arial, sans-serif;
}

/* Make the canvas fill the entire screen */
#game-canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* Controls info overlay */
.overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    z-index: 100;
}

.overlay h2 {
    margin-bottom: 10px;
}

.overlay p {
    margin-bottom: 15px;
}

.overlay ul {
    list-style-type: none;
    text-align: left;
    margin: 0 auto;
    display: inline-block;
}

.overlay ul li {
    margin-bottom: 5px;
}
 
 
===================================================== 
FILE: js\controls.js 
===================================================== 
 
// Numberblocks game - First-person controls implementation

// Global variables
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let canJump = false;
let pitch = 0;  // Track vertical rotation separately

let prevTime = performance.now();
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();

// Player settings
const playerHeight = 2.0;             // Height of camera from ground
const moveSpeed = 5.0;                // Units per second
const jumpHeight = 5.0;               // Jump impulse force
const gravity = 9.8;                  // Gravity force 

// Flag to force fallback controls (for environments like browser previews)
const forceFallbackControls = false;

// Initialize controls for the camera
function initControls(camera, domElement) {
    // Always use fallback controls in browser preview environments
    if (forceFallbackControls) {
        return createFallbackControls(camera, domElement);
    }
    
    // For non-preview environments, try to use PointerLockControls
    try {
        // Test if Pointer Lock API is supported
        if (!document.pointerLockElement && 
            !document.mozPointerLockElement && 
            !document.webkitPointerLockElement) {
            return createFallbackControls(camera, domElement);
        }
        
        // Create PointerLockControls
        const controls = new THREE.PointerLockControls(camera, domElement);
        
        // Set up click event
        domElement.addEventListener('click', () => {
            controls.lock();
        });
        
        // Event listeners for controls state
        controls.addEventListener('lock', () => {
            document.getElementById('controls-info').style.display = 'none';
        });
        
        controls.addEventListener('unlock', () => {
            document.getElementById('controls-info').style.display = 'block';
        });
        
        // Add keyboard controls
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        return controls;
    } catch (e) {
        console.error('Error initializing controls, using fallback:', e);
        return createFallbackControls(camera, domElement);
    }
}

// Create improved fallback controls
function createFallbackControls(camera, domElement) {
    const pitchObject = new THREE.Object3D();
    pitchObject.add(camera);

    const controlsObject = new THREE.Object3D();
    controlsObject.add(pitchObject);

    // Track active event handlers for removal when needed
    const activeEventListeners = {
        mousemove: null,
        mouseleave: null,
        keydown: null
    };

    const mockControls = {
        isLocked: false,
        getObject: () => controlsObject,

        moveForward: (distance) => {
            if (!mockControls.isLocked) return;
            const dir = new THREE.Vector3(0, 0, -1);
            dir.applyQuaternion(controlsObject.quaternion);
            controlsObject.position.addScaledVector(dir, distance);
        },
        moveRight: (distance) => {
            if (!mockControls.isLocked) return;
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(controlsObject.quaternion);
            controlsObject.position.add(right.multiplyScalar(distance));
        },

        lock: function() {
            if (this.isLocked) return;

            this.isLocked = true;
            document.getElementById('controls-info').style.display = 'none';
            document.body.style.cursor = 'none';
            
            // Attempt to use standard pointer lock if available
            try {
                if (domElement.requestPointerLock) {
                    domElement.requestPointerLock();
                } else if (domElement.mozRequestPointerLock) {
                    domElement.mozRequestPointerLock();
                } else if (domElement.webkitRequestPointerLock) {
                    domElement.webkitRequestPointerLock();
                }
            } catch (e) {
                console.error('Pointer lock not supported, using fallback cursor hiding');
            }
            
            // Apply cursor containment styles
            document.body.classList.add('cursor-locked');

            // Add event listeners only when locked
            this.setupEventListeners();
            
            this.dispatchEvent({ type: 'lock' });
        },

        unlock: function() {
            if (!this.isLocked) return;

            this.isLocked = false;
            document.getElementById('controls-info').style.display = 'block';
            document.body.style.cursor = 'auto';
            
            // Exit pointer lock if active
            try {
                if (document.exitPointerLock) {
                    document.exitPointerLock();
                } else if (document.mozExitPointerLock) {
                    document.mozExitPointerLock();
                } else if (document.webkitExitPointerLock) {
                    document.webkitExitPointerLock();
                }
            } catch (e) {
                console.error('Error exiting pointer lock');
            }
            
            // Remove cursor containment styles
            document.body.classList.remove('cursor-locked');
            
            // Remove event listeners when unlocked to fully disengage
            this.removeEventListeners();
            
            this.dispatchEvent({ type: 'unlock' });
        },
        
        setupEventListeners: function() {
            // Mouse look event handling
            const mouseMoveHandler = (event) => {
                if (!mockControls.isLocked) return;

                // For browsers that don't support pointer lock, we can use this approach
                // to at least keep processing mouse events even at screen edges
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                
                // Only apply reasonable movements to avoid jumps
                if (Math.abs(movementX) < 100 && Math.abs(movementY) < 100) {
                    controlsObject.rotation.y -= movementX * 0.002; // Unlimited horizontal rotation (yaw)
                    
                    pitch -= movementY * 0.002; // track pitch separately
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch)); // limit pitch
                    pitchObject.rotation.x = pitch; // apply limited pitch
                }
            };

            // Handle mouseleave to prevent cursor from exiting the window
            const mouseLeaveHandler = (event) => {
                if (mockControls.isLocked) {
                    // If mouse leaves the window, simulate it returning to center
                    // This keeps the cursor within the window bounds
                    const rect = domElement.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    // Create a new mouse event to simulate mouse movement
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: centerX,
                        clientY: centerY,
                        screenX: centerX,
                        screenY: centerY,
                        movementX: 0,
                        movementY: 0
                    });
                    
                    // Dispatch the event
                    document.dispatchEvent(mouseEvent);
                }
            };

            // Escape to unlock controls
            const escKeyHandler = (event) => {
                if (event.code === 'Escape' && mockControls.isLocked) {
                    mockControls.unlock();
                }
            };

            // Store references to handlers so we can remove them later
            activeEventListeners.mousemove = mouseMoveHandler;
            activeEventListeners.mouseleave = mouseLeaveHandler;
            activeEventListeners.keydown = escKeyHandler;

            // Add the event listeners
            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseleave', mouseLeaveHandler);
            document.addEventListener('keydown', escKeyHandler);
        },
        
        removeEventListeners: function() {
            // Remove all active event listeners to fully disengage
            if (activeEventListeners.mousemove) {
                document.removeEventListener('mousemove', activeEventListeners.mousemove);
            }
            
            if (activeEventListeners.mouseleave) {
                document.removeEventListener('mouseleave', activeEventListeners.mouseleave);
            }
            
            if (activeEventListeners.keydown) {
                document.removeEventListener('keydown', activeEventListeners.keydown);
            }
        },
        
        _listeners: {},
        addEventListener: function(type, listener) {
            this._listeners[type] = this._listeners[type] || [];
            this._listeners[type].push(listener);
        },
        dispatchEvent: function(event) {
            if (this._listeners[event.type]) {
                this._listeners[event.type].forEach(listener => listener.call(this, event));
            }
        }
    };

    // Add CSS to trap cursor within game area
    const style = document.createElement('style');
    style.textContent = `
        .cursor-locked {
            cursor: none !important;
            user-select: none;
            -webkit-user-select: none;
        }
        .cursor-locked * {
            cursor: none !important;
        }
    `;
    document.head.appendChild(style);

    // Click event handling - this one remains always active
    domElement.addEventListener('click', () => {
        if (!mockControls.isLocked) mockControls.lock();
    });

    // Add keyboard event listeners for movement - these remain always active
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    return mockControls;
}

// Key down event handler
function onKeyDown(event) {
    // Skip if we're in an input field or textarea
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
        return;
    }
    
    // Map key code to action
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = true;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = true;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = true;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            moveRight = true;
            break;
            
        case 'Space':
            if (canJump) {
                // Apply a physically accurate jump velocity
                velocity.y = Math.sqrt(jumpHeight * 2 * gravity);
                canJump = false;
            }
            break;
    }
}

// Key up event handler
function onKeyUp(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = false;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = false;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = false;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            moveRight = false;
            break;
    }
}

// Update controls - call this in the animation loop
function updateControls(controls, delta) {
    // Only update if controls are locked
    if (controls.isLocked === false) return;
    
    // Apply gravity and handle jumping
    velocity.y -= gravity * delta;
    
    // Calculate movement direction
    direction.z = Number(moveForward) - Number(moveBackward);
    direction.x = Number(moveRight) - Number(moveLeft);
    direction.normalize(); // Normalize for consistent movement speed
    
    // Apply movement
    if (moveForward || moveBackward) {
        controls.moveForward(direction.z * moveSpeed * delta);
    }
    
    if (moveLeft || moveRight) {
        controls.moveRight(direction.x * moveSpeed * delta);
    }
    
    // Apply gravity
    controls.getObject().position.y += velocity.y * delta;
    
    // Check if we're on ground
    if (controls.getObject().position.y < playerHeight) {
        velocity.y = 0;
        controls.getObject().position.y = playerHeight;
        canJump = true;
    }
}
 
 
===================================================== 
FILE: js\main.js 
===================================================== 
 
// Numberblocks game - Three.js implementation
console.log('Numberblocks game initializing...');

// Global variables
let scene, camera, renderer;
let ground;
let controls;
let clock;
let playerNumberblock; // Player's Numberblock

// Initialize the Three.js scene
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky blue background
    
    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    
    renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('game-canvas'),
        antialias: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    createGround();
    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);
    
    // Add landscape elements for perspective
    createLandscapeElements();
    
    // Create player's Numberblock
    playerNumberblock = createPlayerNumberblock(scene, 1);

    controls = initControls(camera, renderer.domElement);

    // CRITICAL FIX: Explicitly set position on controls object (not camera directly)
    controls.getObject().position.set(0, 2, 5);
    scene.add(controls.getObject());
    
    clock = new THREE.Clock();
    window.addEventListener('resize', onWindowResize);
    
    // CRITICAL FIX: Explicitly call onWindowResize to ensure camera's projection matrix is correct initially
    onWindowResize();
    
    animate();
}

// Create the ground plane
function createGround() {
    // Create a large flat plane for the ground
    const groundGeometry = new THREE.BoxGeometry(50, 0.1, 50);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x7CFC00, // Lawn green color
        roughness: 0.8,
        metalness: 0.2
    });
    
    ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.05; // Move it slightly down to center it
    scene.add(ground);
}

// Create random landscape elements for perspective
function createLandscapeElements() {
    // Define bright colors that match Numberblocks aesthetic
    const colors = [
        0xFF0000, // Red (One)
        0xFFA500, // Orange (Two)
        0xFFFF00, // Yellow (Three)
        0x00FF00, // Green (Four)
        0x0000FF, // Blue (Five)
        0x800080, // Purple (Six)
        0xFFC0CB, // Pink (Seven)
        0xA52A2A, // Brown (Eight)
        0x808080  // Grey (Nine)
    ];
    
    // Create 30 random objects
    for (let i = 0; i < 30; i++) {
        let geometry, material, mesh;
        const shapeType = Math.floor(Math.random() * 4); // 0-3 for different shapes
        const colorIndex = Math.floor(Math.random() * colors.length);
        const color = colors[colorIndex];
        
        // Create different shapes
        switch (shapeType) {
            case 0: // Cube (like Numberblock parts)
                const size = 0.5 + Math.random() * 1.5;
                geometry = new THREE.BoxGeometry(size, size, size);
                break;
            case 1: // Cylinder
                const radius = 0.3 + Math.random() * 1;
                const height = 1 + Math.random() * 3;
                geometry = new THREE.CylinderGeometry(radius, radius, height, 16);
                break;
            case 2: // Sphere
                const sphereRadius = 0.5 + Math.random() * 1;
                geometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
                break;
            case 3: // Cone
                const coneRadius = 0.5 + Math.random() * 1;
                const coneHeight = 1 + Math.random() * 2;
                geometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
                break;
        }
        
        // Create material with random color
        material = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        // Create and position the mesh
        mesh = new THREE.Mesh(geometry, material);
        
        // Position randomly on the ground plane (within a 40x40 area)
        const posX = (Math.random() * 40) - 20;
        const posZ = (Math.random() * 40) - 20;
        
        // Calculate Y position based on the shape's height
        let posY;
        if (shapeType === 0) { // Cube
            posY = mesh.geometry.parameters.height / 2;
        } else if (shapeType === 1) { // Cylinder
            posY = mesh.geometry.parameters.height / 2;
        } else if (shapeType === 2) { // Sphere
            posY = mesh.geometry.parameters.radius;
        } else { // Cone
            posY = mesh.geometry.parameters.height / 2;
        }
        
        mesh.position.set(posX, posY, posZ);
        
        // Add random rotation for more variety
        mesh.rotation.y = Math.random() * Math.PI * 2;
        
        // Add to scene
        scene.add(mesh);
    }
    
    // Add some trees as landmarks
    createTrees();
}

// Create simple trees as landmarks
function createTrees() {
    for (let i = 0; i < 10; i++) {
        // Create trunk
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 2, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513, // Brown
            roughness: 0.9
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        
        // Create foliage (as a cone)
        const foliageGeometry = new THREE.ConeGeometry(1.5, 3, 8);
        const foliageMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22, // Forest green
            roughness: 0.8
        });
        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
        foliage.position.y = 2.5; // Position on top of trunk
        
        // Create tree group
        const tree = new THREE.Group();
        tree.add(trunk);
        tree.add(foliage);
        
        // Position randomly on the ground plane but away from center
        let posX, posZ, distance;
        do {
            posX = (Math.random() * 40) - 20;
            posZ = (Math.random() * 40) - 20;
            distance = Math.sqrt(posX * posX + posZ * posZ);
        } while (distance < 8); // Keep trees away from spawn point
        
        tree.position.set(posX, 1, posZ); // Position with trunk base on ground
        
        // Add to scene
        scene.add(tree);
    }
}

// Handle window resize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Animation loop
function animate() {
    requestAnimationFrame(animate);
    
    // Calculate time delta for smooth movement
    const delta = clock.getDelta();
    
    // Update controls
    if (controls && typeof updateControls === 'function') {
        updateControls(controls, delta);
    }
    
    // Update the playerNumberblock position to follow the camera
    updatePlayerPosition();
    
    // Update the HTML number tag position in 2D space
    if (playerNumberblock && typeof playerNumberblock.updateNumberTagPosition === 'function') {
        playerNumberblock.updateNumberTagPosition(camera, renderer);
    }
    
    // Render the scene
    renderer.render(scene, camera);
}

// Update the player's Numberblock position to follow the camera
function updatePlayerPosition() {
    if (playerNumberblock && controls) {
        // Get the controls object's position
        const controlsObject = controls.getObject();
        
        // Calculate the forward direction vector
        const camDirection = new THREE.Vector3(0, 0, -1);
        camDirection.applyQuaternion(camera.quaternion);
        
        // Position the Numberblock at the exact same position as the camera, but slightly lower
        const targetPosition = new THREE.Vector3();
        targetPosition.copy(controlsObject.position);
        
        // Fixed vertical offset to maintain strict relationship between camera and Numberblock
        const verticalOffset = 1.5;
        targetPosition.y -= verticalOffset;
        
        // Get the height of the Numberblock for ground collision
        const numberblockHeight = playerNumberblock.getHeight();
        const groundLevel = numberblockHeight / 2; // Bottom of Numberblock should be at y=0
        
        // Prevent the Numberblock from falling through the ground
        // This will also adjust the camera accordingly to maintain the relationship
        if (targetPosition.y < groundLevel) {
            targetPosition.y = groundLevel;
            // Adjust camera position to maintain the fixed relationship
            controlsObject.position.y = groundLevel + verticalOffset;
        }
        
        // Update the Numberblock's position immediately (no lerp) to stay perfectly aligned with camera
        playerNumberblock.mesh.position.copy(targetPosition);
        
        // Make the Numberblock rotate to match camera's horizontal rotation
        playerNumberblock.mesh.rotation.y = controlsObject.rotation.y;
    }
}

// Initialize the scene when the page loads
document.addEventListener('DOMContentLoaded', init);
 
 
===================================================== 
FILE: js\numberblock.js 
===================================================== 
 
// Numberblocks game - Numberblock model implementation

class Numberblock {
    constructor(value = 1, color = null) {
        this.value = value;
        this.mesh = new THREE.Group();
        this.blockSize = 1; // Size of each cube
        this.blockSpacing = 0.01; // Small gap between blocks
        this.totalHeight = 0;
        
        // Set color based on the Numberblock value, following show colors if no color specified
        if (!color) {
            this.color = this.getColorForNumber(value);
        } else {
            this.color = color;
        }
        
        this.createNumberblock();
    }
    
    // Get the standard Numberblocks color based on value
    getColorForNumber(number) {
        const colors = {
            1: 0xFF0000,   // Red (One)
            2: 0xFFA500,   // Orange (Two)
            3: 0xFFFF00,   // Yellow (Three)
            4: 0x00FF00,   // Green (Four)
            5: 0x0000FF,   // Blue (Five)
            6: 0x800080,   // Purple (Six)
            7: 0xFFC0CB,   // Pink (Seven)
            8: 0xA52A2A,   // Brown (Eight)
            9: 0x808080    // Grey (Nine)
        };
        
        // For numbers greater than 9, cycle through the colors or use white
        return colors[number % 9] || 0xFFFFFF;
    }
    
    // Create the complete Numberblock with all features
    createNumberblock() {
        this.mesh.clear(); // Clear any existing meshes
        this.totalHeight = 0;
        
        // Create the stack of blocks
        for (let i = 0; i < this.value; i++) {
            const block = this.createBlock();
            
            // Position each block on top of the previous one
            block.position.y = this.totalHeight;
            this.totalHeight += this.blockSize + this.blockSpacing;
            
            this.mesh.add(block);
            
            // Add face only to the top block
            if (i === this.value - 1) {
                const face = this.createFace();
                block.add(face);
                
                // Add number tag on top of the top block
                const numberTag = this.createNumberTag();
                numberTag.position.y = this.blockSize / 2 + 0.1; // Position just above the top block
                block.add(numberTag);
            }
        }
        
        // Add arms to the middle block or the second block from the bottom if more than 3 blocks
        const armBlockIndex = this.value <= 3 ? Math.floor(this.value / 2) : 1;
        if (this.value > 0 && armBlockIndex < this.value) {
            const leftArm = this.createArm('left');
            const rightArm = this.createArm('right');
            
            this.mesh.children[armBlockIndex].add(leftArm);
            this.mesh.children[armBlockIndex].add(rightArm);
        }
        
        // Add feet to the bottom block
        if (this.value > 0) {
            const leftFoot = this.createFoot('left');
            const rightFoot = this.createFoot('right');
            
            this.mesh.children[0].add(leftFoot);
            this.mesh.children[0].add(rightFoot);
        }
        
        // Adjust the entire Numberblock position so the bottom is at y=0
        this.mesh.position.y = 0;
    }
    
    // Get the height of the Numberblock (for physics calculations)
    getHeight() {
        // Return the total height calculated during creation
        // If value is 0, return a minimum height
        return this.value > 0 ? this.totalHeight - this.blockSpacing : this.blockSize;
    }
    
    // Create a single block with the Numberblock's color
    createBlock() {
        const geometry = new THREE.BoxGeometry(this.blockSize, this.blockSize, this.blockSize);
        const material = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        return new THREE.Mesh(geometry, material);
    }
    
    // Create a face with eyes and mouth
    createFace() {
        const face = new THREE.Group();
        
        // Eyes (white spheres with black pupils)
        const eyeSize = this.blockSize * 0.15;
        const eyeSpacing = this.blockSize * 0.3;
        const eyeHeight = this.blockSize * 0.1;
        const eyeDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        
        // Create and position left eye
        const leftEye = this.createEye(eyeSize);
        leftEye.position.set(-eyeSpacing, eyeHeight, eyeDepth);
        face.add(leftEye);
        
        // Create and position right eye
        const rightEye = this.createEye(eyeSize);
        rightEye.position.set(eyeSpacing, eyeHeight, eyeDepth);
        face.add(rightEye);
        
        // Mouth (curved line or small cylinder)
        const mouthWidth = this.blockSize * 0.4;
        const mouthHeight = this.blockSize * 0.1;
        const mouthDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        const mouthY = -eyeHeight * 2; // Position below the eyes
        
        const mouthGeometry = new THREE.CylinderGeometry(
            mouthHeight/2, mouthHeight/2, mouthWidth, 16, 1, false, 0, Math.PI
        );
        mouthGeometry.rotateZ(Math.PI / 2); // Rotate to correct orientation
        
        const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, mouthY, mouthDepth);
        face.add(mouth);
        
        return face;
    }
    
    // Create an eye (white sphere with black pupil)
    createEye(size) {
        const eye = new THREE.Group();
        
        // White part of the eye
        const eyeWhiteGeometry = new THREE.SphereGeometry(size, 16, 16);
        const eyeWhiteMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const eyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
        eye.add(eyeWhite);
        
        // Black pupil
        const pupilSize = size * 0.5;
        const pupilGeometry = new THREE.SphereGeometry(pupilSize, 16, 16);
        const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        pupil.position.z = size * 0.6; // Position the pupil slightly in front of the eye
        eye.add(pupil);
        
        return eye;
    }
    
    // Create a number tag to display on top of the Numberblock
    createNumberTag() {
        const tag = new THREE.Group();
        
        // Create a circular background for the number
        const tagRadius = this.blockSize * 0.3;
        const tagGeometry = new THREE.CylinderGeometry(tagRadius, tagRadius, 0.05, 32);
        const tagMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const tagMesh = new THREE.Mesh(tagGeometry, tagMaterial);
        tagMesh.rotation.x = Math.PI / 2; // Make it horizontal
        tag.add(tagMesh);
        
        // Create text geometry for the number
        // Note: Using a simple approach since Three.js TextGeometry requires font loading
        // In production, use Three.js TextGeometry with a loaded font
        
        // For now, we'll create a simple representation
        const numberSize = this.blockSize * 0.2;
        const numberThickness = 0.05;
        let numberMesh;
        
        // Create a simple cube for the number (in a real implementation, use TextGeometry)
        const numberGeometry = new THREE.BoxGeometry(numberSize, numberSize * 1.5, numberThickness);
        const numberMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
        
        // Position the number just above the tag background
        numberMesh.position.z = 0.03;
        tag.add(numberMesh);
        
        // Add a text object using HTML and CSS (will be updated in the render loop)
        const valueDiv = document.createElement('div');
        valueDiv.className = 'numberblock-value';
        valueDiv.innerHTML = this.value.toString();
        valueDiv.style.position = 'absolute';
        valueDiv.style.display = 'none'; // Will be positioned in render loop
        valueDiv.style.color = 'black';
        valueDiv.style.fontWeight = 'bold';
        valueDiv.style.fontSize = '24px';
        valueDiv.style.fontFamily = 'Arial, sans-serif';
        valueDiv.style.textAlign = 'center';
        valueDiv.style.userSelect = 'none';
        document.body.appendChild(valueDiv);
        
        // Store the div element for later positioning
        this.valueDiv = valueDiv;
        
        return tag;
    }
    
    // Create an arm (left or right)
    createArm(side) {
        const arm = new THREE.Group();
        
        // Arm dimensions
        const armLength = this.blockSize * 0.6;
        const armWidth = this.blockSize * 0.2;
        const armHeight = this.blockSize * 0.2;
        
        // Create the arm geometry
        const armGeometry = new THREE.BoxGeometry(armLength, armHeight, armWidth);
        const armMaterial = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        const armMesh = new THREE.Mesh(armGeometry, armMaterial);
        
        // Position the arm on the side of the block
        const xOffset = (this.blockSize / 2 + armLength / 2) * (side === 'left' ? -1 : 1);
        armMesh.position.set(xOffset, 0, 0);
        
        arm.add(armMesh);
        
        // Add a hand at the end of the arm
        const handRadius = armWidth * 0.8;
        const handGeometry = new THREE.SphereGeometry(handRadius, 16, 16);
        const handMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF, // White hands
            roughness: 0.7,
            metalness: 0.2
        });
        
        const hand = new THREE.Mesh(handGeometry, handMaterial);
        
        // Position the hand at the end of the arm
        const handX = armLength / 2 * (side === 'left' ? -1 : 1);
        hand.position.set(handX, 0, 0);
        
        armMesh.add(hand);
        
        return arm;
    }
    
    // Create a foot (left or right)
    createFoot(side) {
        const foot = new THREE.Group();
        
        // Foot dimensions
        const footLength = this.blockSize * 0.4;
        const footWidth = this.blockSize * 0.3;
        const footHeight = this.blockSize * 0.15;
        
        // Create the foot geometry
        const footGeometry = new THREE.BoxGeometry(footLength, footHeight, footWidth);
        const footMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000, // Black feet
            roughness: 0.7,
            metalness: 0.2
        });
        
        const footMesh = new THREE.Mesh(footGeometry, footMaterial);
        
        // Position the foot on the bottom of the block
        const xOffset = (this.blockSize / 4) * (side === 'left' ? -1 : 1);
        const yOffset = -this.blockSize / 2 - footHeight / 2;
        const zOffset = this.blockSize / 4; // Push feet slightly forward
        footMesh.position.set(xOffset, yOffset, zOffset);
        
        foot.add(footMesh);
        
        return foot;
    }
    
    // Update the Numberblock value and regenerate the model
    setValue(newValue) {
        if (newValue < 1) newValue = 1; // Ensure minimum value of 1
        if (newValue !== this.value) {
            this.value = newValue;
            this.color = this.getColorForNumber(newValue);
            this.createNumberblock();
        }
    }
    
    // Update the position of the HTML number tag in render loop
    updateNumberTagPosition(camera, renderer) {
        if (this.valueDiv && this.mesh.children.length > 0) {
            // Get the top block
            const topBlock = this.mesh.children[this.value - 1];
            
            // Calculate position in screen space
            const position = new THREE.Vector3();
            position.copy(topBlock.position);
            position.y += this.blockSize / 2 + 0.2; // Position above the top block
            
            // Convert 3D position to 2D screen coordinates
            const worldPos = new THREE.Vector3();
            topBlock.getWorldPosition(worldPos);
            worldPos.y += this.blockSize / 2 + 0.2;
            
            const screenPos = worldPos.clone();
            screenPos.project(camera);
            
            // Convert to CSS coordinates
            const x = (screenPos.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
            
            // Update the position of the div
            this.valueDiv.style.display = 'block';
            this.valueDiv.style.left = `${x}px`;
            this.valueDiv.style.top = `${y}px`;
            this.valueDiv.innerHTML = this.value.toString();
        }
    }
    
    // Clean up resources when no longer needed
    dispose() {
        if (this.valueDiv && this.valueDiv.parentNode) {
            this.valueDiv.parentNode.removeChild(this.valueDiv);
        }
    }
}

// Function to create a player Numberblock and add it to the scene
function createPlayerNumberblock(scene, value = 1) {
    // Create the Numberblock
    const playerBlock = new Numberblock(value);
    
    // Position it slightly above the ground
    const totalHeight = playerBlock.totalHeight;
    playerBlock.mesh.position.y = totalHeight / 2;
    
    // Add to scene
    scene.add(playerBlock.mesh);
    
    return playerBlock;
}

// Export for use in other modules
if (typeof module !== 'undefined') {
    module.exports = {
        Numberblock,
        createPlayerNumberblock
    };
} 
 
