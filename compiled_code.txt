===================================================== 
NUMBERBLOCKS GAME - COMPLETE CODE COMPILATION 
===================================================== 
 
===================================================== 
SECTION: MEMORY BANK 
===================================================== 
 
----------------------------------------------------- 
FILE: memory bank\architecture.md 
----------------------------------------------------- 
 
# Numberblocks Game - Architecture

## Overview
The Numberblocks game is a 3D web-based educational game built with Three.js and Colyseus, utilizing a client-server architecture for multiplayer functionality. Players control customizable Numberblock characters that can interact with mathematical operators and other Numberblocks in a colorful 3D environment.

## Core Components

### 1. Server (server.js)
**Technology:** Built with Node.js and Colyseus.

**Responsibilities:**
- Manages game rooms and player connections/disconnections
- Maintains the authoritative game state, including player positions, Numberblock values, and static Numberblocks
- Processes player inputs (e.g., movement, operator collection, Numberblock collisions)
- Broadcasts state updates to all connected clients
- Handles operator spawning and lifecycle management

**Key Features:**
- Room-based multiplayer with session persistence
- State synchronization using Colyseus schema
- Server-authoritative position tracking
- Dynamic operator spawning system

### 2. Client (/client)
The client is responsible for rendering the game, handling user inputs, and communicating with the server.

**Key files:**
- **main-fixed.js:**
  - Initializes the Three.js scene, renderer, and camera
  - Sets up player controls and world objects
  - Manages view modes (first-person and third-person)
  - Updates visual components based on server state

- **network.js:**
  - Establishes and maintains WebSocket connection to the server via Colyseus
  - Sends player actions to the server (movement, operator collection, collisions)
  - Processes state updates from the server
  - Handles player joining/leaving events

- **numberblock.js:**
  - Defines the Numberblock class for rendering player characters
  - Creates dynamic block stacks based on numeric value
  - Manages visual elements (face, arms, feet, colors)
  - Handles value-based visual updates

- **operator.js:**
  - Manages mathematical operators (addition, subtraction)
  - Handles visual representation and animation
  - Provides collision detection support

- **collision.js:**
  - Implements collision detection between game entities
  - Supports player-operator and player-numberblock interactions

### 3. Networking Architecture
**Technology:** Colyseus for WebSocket-based real-time multiplayer.

**Implementation:**
- Server maintains authoritative game state using Colyseus Schema
- Client sends player actions to the server at regular intervals
- Server validates actions, updates game state, and broadcasts to all clients
- Efficient state synchronization with delta updates

**Key Features:**
- Session persistence with reconnection support
- Room-based multiplayer with shared state
- Message-based communication for game events
- Schema-based state synchronization with type annotations
- Player list UI showing all connected players

**Schema Implementation:**
- Proper MapSchema collections for players, operators, and static objects
- Type annotations for all schema properties
- Structured synchronization patterns for consistent state updates
- Multiple client-side approaches to handle schema data access

## File Structure
```
/
├── client/                  # Client-side code and assets
│   ├── index.html           # Main HTML entry point
│   ├── css/
│   │   └── styles.css       # Game styling
│   └── js/
│       ├── main-fixed.js    # Core game logic and rendering
│       ├── network.js       # Networking and state synchronization
│       ├── numberblock.js   # Numberblock entity implementation
│       ├── operator.js      # Mathematical operator implementation
│       └── collision.js     # Collision detection system
├── server.js                # Server implementation with Colyseus
├── package.json             # Project dependencies
└── memory bank/             # Project documentation
    ├── architecture.md      # This file
    └── progress.md          # Development progress
```

## Communication Flow
1. **Initialization:**
   - Server starts and creates a game room
   - Client connects to server and joins the room
   - Server assigns a session ID and initializes player state

2. **Gameplay Loop:**
   - Client captures user inputs (movement, view changes)
   - Client sends inputs to server at regular intervals
   - Server validates and processes inputs
   - Server updates game state (player positions, operator spawning, etc.)
   - Server broadcasts updated state to all clients
   - Each client renders the updated game state

3. **Interactions:**
   - Client detects local collisions (player-operator, player-numberblock)
   - Client sends interaction events to server
   - Server validates interaction and updates game state accordingly
   - Server broadcasts the updated state to all clients

## Key Features
- **Dual View Modes:** First-person and third-person camera options
- **Dynamic Numberblocks:** Visual representation changes based on numeric value
- **Mathematical Interactions:** Addition and subtraction operators affect Numberblock values
- **Multiplayer Support:** Multiple players can join the same game world
- **Persistence:** Session reconnection support

## Future Enhancements
- Advanced operator types (multiplication, division)
- Cooperative puzzle challenges
- Enhanced visual effects and animations
- Mobile device support
- User accounts and progression tracking
 
 
----------------------------------------------------- 
FILE: memory bank\game design document.md 
----------------------------------------------------- 
 
Numberblocks FPS Game Design Document
Introduction
This document outlines the design for a multiplayer, browser-based, first-person perspective game inspired by the Numberblocks TV show. Players take on the role of Numberblocks, collect mathematical operators, and interact with other players to change their numerical values, aiming to achieve specific objectives in a fun and engaging way.
Overview
In this game, players navigate a colorful 3D world as Numberblocks, each representing a number. By collecting floating plus (+) and minus (-) operators and bumping into other players, they can add or subtract the other player's number from their own, altering their value. The game offers various modes, such as reaching a target number or eliminating opponents by reducing them to zero.
Core Mechanics
Player Movement
Players move in a first-person perspective with standard FPS controls:
WASD or arrow keys: Move forward, backward, left, and right.

Mouse: Look around.

Spacebar: Jump 

Operator Collection
Plus (+) and minus (-) operators spawn randomly across the game world.

Players collect an operator by running into it and can hold only one at a time.

Operators are visually distinct (e.g., a glowing "+" or "−") and float slightly above the ground.

Bumping Interaction
When a player with an operator bumps into another player, the operator is applied:
Plus Operator (+): The initiating player's number becomes their current number plus the other player's number (e.g., 3 + 2 = 5).

Minus Operator (-): The initiating player's number becomes their current number minus the other player's number (e.g., 3 - 2 = 1).

The other player's number remains unchanged.

The operator is consumed after use, requiring the player to collect a new one.

Number Changes
As a player's number changes, their character model updates:
Larger numbers grow in size (e.g., a Numberblock of 10 is bigger than one of 1).  The player's avatar is blocks that amount to their number.

Optional balancing: Larger numbers move slower but resist displacement, while smaller numbers are faster but more vulnerable.

Game World
Visual Style
The environment is bright, blocky, and inspired by the Numberblocks aesthetic.

Features include platforms, ramps, hiding spots, and open areas for player interaction.

Maps
Multiple themed maps:
Number Forest: Trees and terrain shaped like numbers.

Block City: A city of colorful block buildings.

Mathematical Playground: A playful area with slides and obstacles.

Maps encourage exploration and strategic positioning.

Interactive Elements
Some areas may require a specific number to access (e.g., a gate that opens only for players ≥ 10).

Player Characters
Appearance
Players are Numberblocks, with a block count matching their current number.  Their shape may be straight up, or rows of several blocks, or even arms and legs as the numbers get bigger.  But they are always made of blocks and their number is always visible.

The model dynamically adjusts as the number changes (e.g., growing from 1 block to 10 blocks).

Size and Speed (Optional)
Larger Numbers: Slower movement speed, harder to push.

Smaller Numbers: Faster movement, easier to displace.

This adds a layer of strategy to growing or shrinking.

Operators
Spawning
Operators appear at random intervals and locations on the map.

Spawn rates are balanced to ensure availability without overwhelming players.

Collection
Players collect an operator by touching it.

Collecting a new operator replaces the current one if the player is already holding one.

Usage
Operators activate automatically upon bumping into another player.

After use, the operator is consumed.

Game Objectives
The game supports multiple modes:
1. Target Number Mode
Objective: Reach a specific number (e.g., 100) by adding to your value.

The first player to hit the target wins.

2. Elimination Mode
Objective: Reduce other players to zero or below using the minus operator.

Players at zero or negative are eliminated; the last one standing wins.

3. Score-Based Mode
Objective: Earn points for each operation performed (e.g., +1 point per addition/subtraction).

The player with the most points at the end wins, tracked via a leaderboard.

Multiplayer Features

The Numberblocks game features a comprehensive multiplayer system with support for both local split-screen and online networked play, allowing for flexible and varied play experiences.

### Core Multiplayer Architecture

- **Client-Server Model**: Uses Colyseus for WebSocket communication, providing a server-authoritative game state
- **Room-Based Gameplay**: Players join game rooms with unique session IDs and synchronized state
- **Cross-Platform Support**: Play on various devices and browsers with consistent experience

### Local Split-Screen Multiplayer

- **Player Count**: Supports 2-4 players on a single device
- **Screen Division**:
  - 2 players: Horizontal split (top/bottom) or vertical split (left/right)
  - 3-4 players: Quadrant-based division with each player assigned a section of the screen
- **Input Management**:
  - Primary player: WASD movement, mouse look, spacebar jump
  - Secondary player(s): Arrow key movement, numpad look, enter jump
  - Gamepad support for all players with standard mapping
- **Visual Distinction**:
  - Unique colors/patterns for each player's Numberblock
  - Player names or icons displayed in their viewport
  - HUD customization per viewport showing player-specific info

### Online Multiplayer

- **Player Connection**: Connect to game servers via unique room codes or matchmaking
- **Persistence**: Session reconnection support if temporarily disconnected
- **Latency Management**:
  - Client-side prediction for responsive gameplay
  - Server reconciliation to maintain game state integrity
  - Position interpolation for smooth movement of other players
- **Player Limit**: Up to 10 players per online game room
- **Social Features**:
  - Player names and optional customization
  - Simple chat system or emoji-based communication
  - Friend invites and private rooms

### Hybrid Multiplayer

- **Local + Online**: Combine local split-screen with online play
  - Example: Two players on one device can join an online room with other remote players
- **Scaling**:
  - Game difficulty and operator spawning adjusts based on player count
  - Maps expand or contract to maintain optimal player density
- **Fairness**:
  - Equal operator distribution across the map
  - Spawn protection to prevent immediate targeting of new players
  - Optional balancing mechanics for teams with uneven player counts

### Gameplay Modes

- **Free-for-All**: Every player competes individually
- **Team Play**:
  - Form teams of 2-3 players
  - Combined team score or cooperative objectives
  - Team-based visual identity (color schemes)
- **Specialized Modes**:
  - Capture the Flag: Teams attempt to capture numbered flags
  - King of the Hill: Control zones to accumulate points
  - Math Race: Race through checkpoints solving math problems

### Player Interaction

- **Core Bumping Mechanics**: Apply operators to other players through collision
- **Cooperative Actions**:
  - Stand close to allies to combine numbers temporarily
  - Form "number trains" for enhanced movement or special abilities
  - Share operators with teammates
- **Competitive Actions**:
  - Block opponents from reaching operators
  - Strategic positioning to access high-value areas
  - Tactical operator usage to manipulate opponent numbers

### Networking Considerations

- **Bandwidth Optimization**:
  - Efficient state synchronization with delta updates
  - Interest management to prioritize nearby players
- **Cross-Device Performance**:
  - Adaptive rendering quality based on device capabilities
  - Optional graphic settings to maintain performance
- **Connection Quality**:
  - Visual indicators for network status
  - Graceful handling of high-latency situations

### Split-Screen Technical Implementation

- **Renderer Management**: Multiple Three.js renderers for each viewport
- **Camera Control**: Independent camera instances for each local player
- **Resource Sharing**: Optimized asset sharing for memory efficiency
- **Performance Considerations**:
  - Simplified lighting in multi-viewport mode
  - Reduced draw distance for split-screen to maintain frame rate
  - Level of detail adjustments based on viewport size

This comprehensive multiplayer system ensures the Numberblocks game is enjoyable whether playing with friends on the same device or connecting with players around the world.

Handling Edge Cases
Zero or Negative Numbers
If a player's number reaches zero or below:
Respawn Option: They are out for 10 seconds, then return as 1.

Elimination Option: They are removed from the round (used in Elimination Mode).

Maximum Number Limit
A cap (e.g., 100) prevents excessive growth.

Optional: Larger numbers face rarer plus operators to slow their progress.

User Interface (UI)
Heads-Up Display (HUD)
Shows:
Player's current number.

Held operator (if any).

Optional: Score or mini-map.

Menus
Main Menu: Choose game mode, map, and settings.

Lobby: Join or create multiplayer matches.

Controls
Movement: WASD or arrow keys.

Look: Mouse.

Jump: Spacebar (if implemented).

Interact: Automatic via bumping.

Audio
Background Music: Upbeat, Numberblocks-inspired tunes.

Sound Effects:
Operator collection (e.g., a cheerful "ding").

Bumping (e.g., a soft "thud").

Number change (e.g., a growing/shrinking sound).

Technical Considerations
Platform
Browser-based, using WebGL for 3D rendering (e.g., Three.js).

Networking
Real-time multiplayer requires server-side syncing of:
Player positions. 

Numbers.

Operator states and spawns.

Optimization
Must run smoothly on various devices/browsers.

Efficient collision detection is key for bumping mechanics.

Future Features
Power-Ups: Shields (block operators) or speed boosts.

Advanced Operators: Multiplication/division for complexity (optional).

Customization: Unlockable colors or accessories for Numberblocks.

Educational Mode: Single-player math puzzles for kids.

Conclusion
This game combines the playful, educational charm of Numberblocks with dynamic FPS gameplay. Its simple mechanics make it accessible to children, while strategic depth and multiplayer fun appeal to all ages. With proper balancing and optimization, it can become an entertaining and educational browser-based experience.
 
 
----------------------------------------------------- 
FILE: memory bank\implementation plan.md 
----------------------------------------------------- 
 
Step 1: Set up the basic project structure
Task: Create a new project and set up the files needed for a Three.js-based game.

Details: 
Create an index.html file with a canvas element.

Add a styles.css file for basic styling (e.g., full-screen canvas).

Create a main.js file for JavaScript code.

Include the Three.js library via a CDN (e.g., <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>).

Test: 
Open the project in a browser.

Check that there are no console errors and a blank canvas appears.

Step 2: Create a basic 3D scene
Task: Set up a simple 3D scene with a ground plane and a camera.

Details: 
In main.js, create a Three.js scene, camera, and renderer.

Add a flat plane (e.g., a large box) as the ground.

Position the camera above the ground and render the scene.

Test: 
Open the project in a browser.

See the ground plane rendered from the camera’s perspective.

Step 3: Implement first-person camera controls
Task: Add first-person movement controls to the camera.

Details: 
Use Three.js’s FirstPersonControls or a custom controller.

Enable WASD keys for movement and mouse for looking around.

Test: 
Use WASD keys to move and the mouse to look around.

Confirm the controls are smooth and responsive.

Step 4: Create a basic Numberblock model
Task: Add a simple Numberblock model to the scene.

Details: 
Create a single cube to represent a Numberblock with the number 1.

Position it slightly above the ground in the scene.

Test: 
Open the project and see the cube in the scene.

Ensure it’s correctly positioned relative to the ground.

Step 5: Implement player movement
Task: Attach the Numberblock model to the camera and add basic movement.

Details: 
Link the cube’s position to the camera so it moves with it.

Add jumping (spacebar) and gravity to prevent falling through the ground.

Test: 
Move with WASD keys and see the cube move.

Press spacebar to jump and watch the cube rise and fall back to the ground.

Step 6: Add operator spawning
Task: Create and spawn plus (+) and minus (-) operators in the scene.

Details: 
Make simple 3D models (e.g., spheres) for operators, colored differently (e.g., green for +, red for -).

Write a function to spawn them randomly on the ground every few seconds.

Test: 
See operators appear over time at different spots.

Verify they sit on the ground, not floating or underground.

Step 7: Implement operator collection
Task: Allow the player to collect operators by touching them.

Details: 
Detect when the player’s Numberblock collides with an operator.

Remove the operator from the scene and store it as the player’s held operator (limit to one).

Test: 
Walk into an operator and see it disappear.

Confirm the player holds it (e.g., log it to the console or show it on-screen).

Step 8: Implement bumping interaction
Task: Enable bumping into another Numberblock to apply the operator.

Details: 
Add a second, static Numberblock with a fixed number (e.g., 2).

Detect collision with it; if the player has an operator, apply it (e.g., 1 + 2 = 3).

Remove the operator after use.

Test: 
Bump into the static Numberblock with an operator.

Check that the player’s number updates (e.g., from 1 to 3) and the operator is consumed.

Step 9: Update Numberblock model based on number
Task: Change the Numberblock model when its number changes.

Details: 
Write a function to stack cubes vertically based on the player’s number (e.g., 3 cubes for 3).

Update the model after a number change.

Test: 
After bumping and changing the number, see the model update (e.g., from 1 cube to 3).

Ensure it doesn’t clip through the ground.

Step 10 / 11: MULTIPLAYER AND CONTROLLER SUPPORT

SEE MULTIPLAYER AND CONTROLLER FEATURE.MD

Step 12: Implement game objectives
Task: Add the Target Number Mode.

Details: 
Set a target number (e.g., 10).

Display a win message when a player reaches it.

Test: 
Play and reach the target number.

See a win message appear when achieved.

Step 13: Add more game modes
Task: Implement Elimination Mode and Score-Based Mode.

Details: 
Elimination Mode: Remove players whose number reaches zero or below.

Score-Based Mode: Award points for each operation, shown on a leaderboard.

Test: 
Test Elimination Mode: Reach zero and get removed or respawn.

Test Score-Based Mode: Perform operations and see points increase.

Step 14: Polish and optimize
Task: Enhance visuals, add audio, and improve performance.

Details: 
Add basic textures or colors to models.

Include sound effects (e.g., “ding” for collecting operators).

Optimize rendering for smooth gameplay.

Test: 
Play and ensure no lag or glitches.

Hear sound effects and see improved visuals.

Step 15: Add advanced features (optional)
Task: Introduce power-ups or advanced operators.

Details: 
Add a power-up (e.g., speed boost) that spawns like operators.

Optionally, include multiplication operators (e.g., ×2).

Test: 
Collect a power-up and see its effect (e.g., faster movement).

Use an advanced operator and verify the number change.

Conclusion
This implementation plan provides a clear, step-by-step roadmap to develop the Numberblocks FPS game. Each step is simple enough to be handled with a single prompt in the Windsurf IDE, and the accompanying tests ensure that each feature works before moving forward. By following this plan, you can progressively build a fully functional browser-based multiplayer game that aligns with the game design document’s vision.

 
 
----------------------------------------------------- 
FILE: memory bank\Multiplayer and controller implementation plan.md 
----------------------------------------------------- 
 
# Numberblocks Game - Multiplayer Implementation Plan

**Note: This is an updated implementation plan that focuses on the remaining tasks. The client-server setup with Colyseus has already been successfully implemented as documented in the architecture.md and progress.md files.**

## Completed Tasks:
- ✅ Separate client and server logic
- ✅ Set up local development server with Node.js
- ✅ Implement Colyseus for WebSocket communication
- ✅ Create room-based multiplayer structure
- ✅ Establish server authority for game state
- ✅ Implement player position synchronization
- ✅ Set up basic player session management
- ✅ Create client-side network module (network.js)
- ✅ Integrate network state with Three.js rendering
- ✅ Fix camera view synchronization issues

## Remaining Implementation Tasks:

# 1. Player Customization and Identification

## Goal:
Allow players to customize their Numberblocks with names and potential visual indicators.

## Implementation:

1. **Add Player Name Input**:
   ```html
   <div id="player-setup">
     <input type="text" id="player-name" placeholder="Enter your name" maxlength="15">
     <button id="start-game">Join Game</button>
   </div>
   ```

2. **Send Player Info to Server**:
   ```javascript
   document.getElementById('start-game').addEventListener('click', () => {
     const playerName = document.getElementById('player-name').value || 'Player';
     client.joinOrCreate("numberblocks", { name: playerName })
       .then(room => {
         // Store room reference and continue with game setup
         window.room = room;
         document.getElementById('player-setup').style.display = 'none';
         initGame();
       });
   });
   ```

3. **Visual Player Identifiers**:
   - Add name tags above each Numberblock
   - Assign each player a distinct color accent
   - Display player list in a corner of the screen

## Benefits:
- Players can easily identify each other in the game world
- Enhanced social experience with personalized characters
- Improved communication in multiplayer

# 2. Enhanced Multiplayer Interactions

## Goal:
Create more engaging player-to-player interactions beyond basic collision.

## Implementation:

1. **Cooperative Mechanics**:
   - Allow players to form "teams" by standing close to each other
   - Implement cooperative puzzles requiring multiple player values
   - Create shared objectives that scale with player count

2. **Competitive Challenges**:
   - Add timed challenges to reach specific number values
   - Implement race courses with mathematical checkpoints
   - Create areas where players compete to solve math puzzles

3. **Trading System**:
   ```javascript
   function requestTrade(targetPlayerId) {
     room.send("tradeRequest", { targetId: targetPlayerId });
   }
   
   room.onMessage("tradeResponse", (message) => {
     if (message.accepted) {
       // Show trade interface
       showTradeInterface(message.playerId);
     }
   });
   ```

## Benefits:
- More engaging multiplayer experience beyond just "seeing" other players
- Educational value through cooperation and friendly competition
- Extended gameplay depth and replayability

# 3. Set Up Gamepad Controls

## Goal:
Add gamepad support for enhanced accessibility.

## Implementation:

1. **Gamepad Detection**:
   ```javascript
   let gamepads = [];

   function updateGamepads() {
     gamepads = navigator.getGamepads().filter(gp => gp && gp.connected);
   }

   window.addEventListener('gamepadconnected', (e) => {
     console.log(`Gamepad ${e.gamepad.index} connected`);
     updateGamepads();
   });

   window.addEventListener('gamepaddisconnected', (e) => {
     console.log(`Gamepad ${e.gamepad.index} disconnected`);
     updateGamepads();
   });
   ```

2. **Gamepad Controls Mapping**:
   ```javascript
   function processGamepadInput() {
     updateGamepads();
     if (gamepads.length > 0) {
       const gp = gamepads[0];
       const axes = gp.axes;
       const buttons = gp.buttons;

       // Movement (left stick)
       const moveForward = -axes[1] > 0.2;
       const moveBackward = -axes[1] < -0.2;
       const moveLeft = -axes[0] < -0.2;
       const moveRight = -axes[0] > 0.2;

       // Apply movement
       if (moveForward || moveBackward || moveLeft || moveRight) {
         // Process movement similar to keyboard controls
         // Update player position accordingly
       }

       // Look (right stick)
       if (Math.abs(axes[2]) > 0.1 || Math.abs(axes[3]) > 0.1) {
         // Rotate camera based on right stick input
       }

       // Jump (A button)
       if (buttons[0].pressed && canJump) {
         // Jump logic
       }
       
       // View toggle (Y button)
       if (buttons[3].pressed && !buttons[3].wasPressed) {
         toggleCameraView();
       }
       buttons[3].wasPressed = buttons[3].pressed;
     }
   }
   ```

3. **Integration with Animation Loop**:
   ```javascript
   function animate() {
     requestAnimationFrame(animate);
     
     // Process keyboard input
     processKeyboardInput();
     
     // Process gamepad input
     processGamepadInput();
     
     // Rest of animation loop
   }
   ```

## Benefits:
- Improved accessibility for players who prefer or require controllers
- More precise movement control in 3D space
- Support for multiple input methods without compromising experience

# 4. Additional Network Optimizations

## Goal:
Enhance network performance for smoother multiplayer experience.

## Implementation:

1. **State Interpolation**:
   ```javascript
   // Store previous and current state
   let prevState = null;
   let currentState = null;
   let interpolationTime = 0;
   
   room.onStateChange((state) => {
     prevState = currentState;
     currentState = JSON.parse(JSON.stringify(state));
     interpolationTime = 0;
   });
   
   function animateWithInterpolation(deltaTime) {
     if (prevState && currentState) {
       // Increment interpolation time (0 to 1)
       interpolationTime = Math.min(interpolationTime + deltaTime * 15, 1);
       
       // Interpolate player positions
       Object.keys(currentState.players).forEach(id => {
         if (id !== room.sessionId && prevState.players[id]) {
           const current = currentState.players[id];
           const prev = prevState.players[id];
           
           // Get or create player representation
           const playerRep = getPlayerRepresentation(id);
           
           // Apply interpolated position
           playerRep.position.x = lerp(prev.x, current.x, interpolationTime);
           playerRep.position.y = lerp(prev.y, current.y, interpolationTime);
           playerRep.position.z = lerp(prev.z, current.z, interpolationTime);
           playerRep.rotation.y = lerp(prev.rotation, current.rotation, interpolationTime);
         }
       });
     }
   }
   
   // Linear interpolation helper
   function lerp(a, b, t) {
     return a + (b - a) * t;
   }
   ```

2. **Prediction-Correction System**:
   ```javascript
   // When player inputs are processed:
   function applyPlayerMovement() {
     // Apply movement locally first (prediction)
     playerNumberblock.mesh.position.x += moveVector.x;
     playerNumberblock.mesh.position.z += moveVector.z;
     
     // Send to server
     room.send("updatePosition", {
       x: playerNumberblock.mesh.position.x,
       y: playerNumberblock.mesh.position.y,
       z: playerNumberblock.mesh.position.z,
       rotation: playerNumberblock.mesh.rotation.y
     });
   }
   
   // If server corrects us:
   room.onMessage("positionCorrection", (data) => {
     // Smoothly correct to server position
     const correctionTween = new TWEEN.Tween(playerNumberblock.mesh.position)
       .to({ x: data.x, y: data.y, z: data.z }, 100)
       .easing(TWEEN.Easing.Quadratic.Out)
       .start();
   });
   ```

3. **Interest Management**:
   ```javascript
   // Server-side optimization to send only nearby players
   class NumberblocksRoom extends Room {
     update() {
       // For each player, only send updates about nearby players
       Object.keys(this.state.players).forEach(id => {
         const player = this.state.players[id];
         const nearbyPlayers = {};
         
         Object.keys(this.state.players).forEach(otherId => {
           if (id === otherId) {
             nearbyPlayers[otherId] = this.state.players[otherId];
             return;
           }
           
           const otherPlayer = this.state.players[otherId];
           const distance = calculateDistance(player, otherPlayer);
           
           if (distance < 50) { // Visibility range
             nearbyPlayers[otherId] = otherPlayer;
           }
         });
         
         // Send customized state to this player
         this.clients.get(id).send("visiblePlayers", nearbyPlayers);
       });
     }
   }
   ```

## Benefits:
- Smoother player movement with reduced jitter
- More responsive gameplay despite network latency
- Scalability to support more simultaneous players

# 5. Mobile Compatibility (Optional)

## Goal:
Make the game playable on mobile devices with touch controls.

## Implementation:

1. **Responsive Design**:
   ```css
   @media (max-width: 768px) {
     /* Mobile-specific styles */
     #game-container {
       width: 100%;
       height: 100%;
       touch-action: none;
     }
     
     .mobile-controls {
       display: flex;
     }
     
     .desktop-controls {
       display: none;
     }
   }
   ```

2. **Touch Controls**:
   ```javascript
   const touchJoystick = new VirtualJoystick({
     container: document.getElementById('joystick-area'),
     strokeStyle: 'white',
     limitStickTravel: true,
     stickRadius: 50
   });
   
   function processTouchInput() {
     if (touchJoystick.up()) moveForward = true;
     if (touchJoystick.down()) moveBackward = true;
     if (touchJoystick.left()) moveLeft = true;
     if (touchJoystick.right()) moveRight = true;
     
     // Process touch controls similar to keyboard/gamepad
   }
   ```

3. **Device Orientation for Camera**:
   ```javascript
   window.addEventListener('deviceorientation', (event) => {
     if (!isMobile) return;
     
     const rotationY = event.alpha * (Math.PI/180);
     const rotationX = event.beta * (Math.PI/180);
     
     // Apply rotation to camera
     camera.rotation.y = -rotationY;
     camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX - Math.PI/2));
   });
   ```

## Benefits:
- Expanded player base to include mobile users
- Flexibility for playing on different devices
- New control options that might be preferred by some players

# Implementation Timeline and Priorities

1. **High Priority (1-2 weeks)**:
   - Player Customization and Identification
   - Basic Gamepad Controls
   - Network Optimizations (interpolation)

2. **Medium Priority (2-4 weeks)**:
   - Enhanced Multiplayer Interactions
   - Advanced Gamepad Integration
   - Improved Network Prediction-Correction

3. **Lower Priority (4+ weeks)**:
   - Mobile Compatibility
   - Interest Management Optimizations
   - Additional Customization Options

This implementation plan builds upon the successful client-server architecture already in place, focusing on enhancing the multiplayer experience with more interactive features, improved controls, and optimized networking.
 
 
----------------------------------------------------- 
FILE: memory bank\progress.md 
----------------------------------------------------- 
 
# Numberblocks Game - Progress Log

## March 15, 2025
- Completed Step 1 of implementation plan: Set up basic project structure
  - Created index.html with canvas element
  - Added styles.css for basic styling (full-screen canvas)
  - Created main.js for JavaScript code
  - Included Three.js library via CDN
  - Created directory structure following the architecture document
  - Verified that the project loads in browser with no console errors
- Created comprehensive README.md file
- Set up Git repository and GitHub remote
- Added .gitignore file for the project
- Completed Step 2 of implementation plan: Created a basic 3D scene
  - Implemented Three.js scene, camera, and renderer in main.js
  - Added a flat green plane as the ground
  - Positioned the camera above the ground
  - Added proper lighting (ambient and directional)
  - Implemented window resize handling
  - Set up the animation loop
- Completed Step 3 of implementation plan: Implemented first-person camera controls
  - Created controls.js for camera movement functionality
  - Implemented Three.js PointerLockControls for first-person view
  - Added WASD and arrow key movement
  - Implemented jumping with spacebar
  - Added controls info overlay for user guidance
  - Added appropriate styles for the overlay UI
  - Implemented robust fallback mechanism for environments where Pointer Lock API is unavailable
  - Added error handling with try-catch blocks for browser API compatibility
  - Created mockControls object that mimics the PointerLockControls interface for seamless operation
  - Enhanced FPS camera controls:
    - Added parent-child object hierarchy for proper camera rotation
    - Separated yaw (horizontal) and pitch (vertical) rotations for natural camera movement
    - Implemented pitch clamping to prevent camera flipping
    - Added mouse locking within the game window using CSS and event handling
    - Ensured proper cursor disengagement when ESC key is pressed
    - Implemented proper event listener cleanup for complete mouse control disengagement
  - Updated RULES.md with browser API considerations based on implementation experience
- Completed Step 4 of implementation plan: Created a basic Numberblock model
  - Implemented Numberblock class in numberblock.js with all required features:
    - Created a stack of blocks representing the Numberblock's value
    - Added face with eyes and mouth to the top block
    - Added arms on the sides (positioned based on number of blocks)
    - Added feet to the bottom block
    - Added a number tag on top showing the Numberblock's value
  - Used appropriate colors matching the Numberblocks TV show aesthetic
  - Integrated the Numberblock model with the main game:
    - Added the Numberblock to follow the player's movement
    - Positioned it in front of the camera for a first-person view
    - Implemented smooth interpolation for natural movement
    - Added HTML/CSS-based number display that follows the 3D model
  - Added helper functions for creating and updating Numberblocks
  - Added proper resource cleanup methods to prevent memory leaks
- Completed Step 5 of implementation plan: Implemented player movement (partial collision)
  - Added getHeight method to Numberblock class for accurate height calculation
  - Improved jumping mechanics with physically accurate jump formula
  - Implemented basic ground collision detection to prevent falling through the ground
  - Created true first-person view where camera positioned from Numberblock's perspective
  - Ensured perfect synchronization between camera and Numberblock during all movements
  - Implemented two-way position binding to maintain consistent camera-Numberblock relationship
  - Note: Full collision system with other objects not implemented yet
- Completed Step 6 of implementation plan: Added operator spawning
  - Created Operator and OperatorManager classes
  - Implemented operator spawning system
  - Added proper positioning and rotation
  - Integrated with player controls
  - Fixed movement controls after operator integration
  - Ensured proper initialization order
- Completed Step 7 of implementation plan: Implemented operator collection
  - Added collision detection between player's Numberblock and operators
  - Created visual attachment system to make operators attach to Numberblock's hand
  - Modified Numberblock.createArm method to name hand objects for reference
  - Enhanced OperatorManager.setHeldOperator to attach operators to the Numberblock
  - Created smaller version (40% scale) of operator for holding
  - Added robust error handling in collision detection to prevent game freezes
  - Properly integrated collision.js with the rest of the codebase
  - Implemented fallback collision functions for improved stability
- Completed Step 8 of implementation plan: Implemented bumping interaction
  - Added a second static Numberblock to the scene with value 2
  - Implemented collision detection between player and static Numberblock
  - Created logic to apply held operators (plus/minus) when collision occurs
  - Added mathematical operations based on operator type:
    - Plus operator: player.value += staticNumberblock.value
    - Minus operator: player.value -= staticNumberblock.value (with minimum value check)
  - Added visual feedback with immediate Numberblock reconstruction
  - Implemented operator consumption after successful application
  - Added player pushback to prevent continuous collisions
  - Enhanced UI feedback with console logs and visual updates
  - Added error handling for collision detection to prevent game freezes

### Step 9: Update Numberblock Model & Add HUD (Completed March 15, 2025)
- **Updated Numberblock Model**
  - Verified that the Numberblock model correctly updates its visual representation after mathematical operations
  - Enhanced the camera positioning to dynamically adjust based on Numberblock size
  - Fixed visual artifacts and rendering issues with number tags
  - Implemented double-sided transparent materials for better visibility
  
- **Added Basic HUD**
  - Created a heads-up display showing the player's current number in the top-right corner
  - Styled the HUD with semi-transparent background and clear typography
  - Ensured the HUD updates in real-time when the player's number changes
  - Made the HUD non-intrusive with pointer-events set to none

## March 16, 2025
- Improved HUD display:
  - Added clear number display in top-left that changes color based on Numberblock value
  - Added operator display in top-right showing "+ Add" or "- Subtract"
  - Added semi-transparent backgrounds and text shadows for better visibility
  - Removed duplicate displays for cleaner UI
- Fixed Numberblock positioning:
  - All Numberblocks now properly stand on the ground
  - Fixed positioning for random shapes and objects
  - Improved Y-position calculations for consistent placement
- Removed redundant number tags from Numberblocks since value is shown in HUD
- Enhanced control system:
  - Added Q and E key functionality for turning left and right in first-person view
  - Set appropriate rotation speed for smooth turning experience
  - Maintained backward compatibility with mouse controls
- Expanded game world:
  - Increased ground size from 50x50 to 200x200 units (16x larger play area)
  - Added more decorative objects (from 30 to 120) to maintain visual density
  - Increased trees from 10 to 40 for better landmarks
  - Expanded spawn protection area for better player experience
- Implemented third-person camera and controls:
  - Added toggle between first-person and third-person views with the V key
  - Implemented camera positioning behind the player with proper height and distance
  - Created smooth camera transition when changing views
  - Developed camera-relative movement in third-person mode
  - Added Q/E rotation controls for the player character in third-person mode
  - Ensured player character rotation matches movement direction when WASD keys are used
  - Implemented proper cursor handling in both view modes
  - Fixed THREE.js error related to camera parenting during view transitions

## March 16, 2025 (continued)
- Implemented client-server architecture for multiplayer functionality:
  - Created server.js using Node.js and Colyseus for WebSocket communication
  - Migrated from single-player to a networked multiplayer architecture
  - Implemented room-based gameplay with Colyseus schema for state synchronization
  - Added player session management with reconnection support
  - Created network.js client module for server communication
  - Modified main.js to support server-synchronized gameplay
  - Implemented server-authoritative position tracking and collision detection
  - Added player joining/leaving events with real-time UI updates
  
- Major code reorganization:
  - Moved all client-side code to a dedicated /client directory
  - Updated file references and paths throughout the codebase
  - Removed outdated test and debug files
  - Consolidated CSS and other assets into appropriate directories
  - Created a streamlined development workflow with npm scripts

- Enhanced multiplayer features:
  - Added static numberblocks with server-managed state
  - Implemented operator spawning controlled by the server
  - Created player list UI showing all connected players
  - Added visual representations of other players in the game world
  - Fixed camera view switching to maintain proper position synchronization
  - Improved network code to handle view transitions seamlessly

- Fixed critical bugs:
  - Resolved issue with static numberblocks floating above ground
  - Fixed position synchronization issues when switching camera views
  - Corrected operator collection and interaction logic in multiplayer context
  - Improved error handling for network-related operations

## March 16, 2025 (evening)
- Fixed critical Colyseus schema synchronization issues:
  - Updated schema definitions to use proper MapSchema initialization instead of regular objects
  - Added proper type annotations for all schema properties
  - Fixed player list functionality to correctly display connected players
  - Implemented proper methods for player management (MapSchema .set() and .delete())
  - Added verification and fallback mechanisms for player data access
  - Enhanced logging for better debugging of multiplayer state
  - Improved error handling for schema operations

- Added robust player list UI improvements:
  - Implemented expandable/collapsible player list with Tab key
  - Added color indicators matching player Numberblock colors
  - Improved display with player names and values
  - Created multiple player data access methods to ensure compatibility
  - Added real-time updating based on schema changes
  - Fixed visual formatting and styling of player entries

## Next Steps
- Add customizable player names and colors
- Implement additional operator types (multiplication, division)
- Create cooperative math challenges
- Add game statistics and leaderboard
- Enhance visual effects for multiplayer interactions 
 
----------------------------------------------------- 
FILE: memory bank\RULES.md 
----------------------------------------------------- 
 
# Development Rules and Notes

## Server Management

### Restarting the Numberblocks Server
When testing changes, you'll need to properly stop and restart the Node.js server:

```powershell
# STEP 1: Kill all Node.js processes (safer and more reliable method)
taskkill /F /IM node.exe

# STEP 2: Start the server using npm
npm start
```

> NOTE: The previous method using `Get-Process -Name "node" -ErrorAction SilentlyContinue | Stop-Process -Force` 
> has been found to be unreliable and may cause issues.

### Directory Creation
- When creating multiple directories at once with PowerShell's `mkdir` command, you must use quotes when specifying paths with spaces or multiple directories:
  ```
  # INCORRECT (will fail):
  mkdir css js assets assets\images assets\models assets\sounds
  
  # CORRECT (individual commands):
  mkdir css
  mkdir js
  mkdir assets
  mkdir "assets\images"
  mkdir "assets\models"
  mkdir "assets\sounds"
  ```

- PowerShell's `mkdir` doesn't support multiple directory arguments like in Linux/macOS. Create directories one by one or use a loop.


## Three.js Implementation Notes

- Always include the Three.js library before your own JavaScript files in the HTML
- When testing, make sure to run a local HTTP server rather than opening the HTML file directly due to CORS restrictions with resource loading
- Use a thin BoxGeometry instead of PlaneGeometry for the ground to ensure proper lighting on both sides
- Always implement window resize handling for responsive design (update camera aspect ratio and renderer size)
- For better performance, set renderer.setPixelRatio to match the device's pixel ratio

## Browser API Considerations

- The Pointer Lock API (used by PointerLockControls) may not work in some environments, especially in embedded preview browsers or when served through certain proxies
- Always implement a fallback mechanism for critical browser APIs in case they fail
- Use try-catch blocks around browser API calls that might not be supported in all environments
- Check browser console for API-related errors when testing in different environments
- When implementing mouse controls:
  - Proper event listener management is essential (add/remove listeners appropriately)
  - Always provide visual feedback when controls are locked/unlocked
  - Ensure complete disengagement of controls when user presses ESC

## JavaScript Considerations

- When using event handlers, store references to them for proper removal later to prevent memory leaks
- For event-based systems (like controls), implement a proper event dispatcher mechanism
- Use class-based or module patterns for complex components to keep code organized
- When dealing with 3D rotations:
  - Separate axes of rotation (yaw, pitch, roll) to prevent gimbal lock issues
  - Always clamp vertical rotation (pitch) to prevent camera flipping

## Git Workflow

- Always update the progress.md file after completing each implementation step
- Keep commit messages descriptive and related to the implementation plan steps

## Project Structure

- Follow the architecture document precisely to ensure consistency
- New JavaScript files should be placed in the js/ directory and then linked in index.html as needed

## class structure
- keep classes modular - each class should have a single responsibility
- use classes to group related functionality
 
 
----------------------------------------------------- 
FILE: memory bank\tech stack.md 
----------------------------------------------------- 
 
# Numberblocks Game - Tech Stack

## Front-End
- **HTML5:** Provides the structure for the game, including the canvas element for 3D rendering and UI components like the heads-up display (HUD) and menus.

- **CSS3:** Styles the UI elements, such as the HUD, player stats, and overlays, ensuring they look polished and are positioned correctly over the game canvas.

- **JavaScript (ES6+):** Drives the client-side game logic, handling player input, visual rendering, and network communication.

- **Three.js:** A JavaScript library that simplifies WebGL for 3D rendering, used to create the game world, dynamic Numberblock models, and environmental elements.

- **Web Audio API:** Manages audio, including sound effects for actions like bumping into players or collecting operators, and background music.

## Back-End
- **Node.js:** Server-side JavaScript runtime that hosts the game server, manages player connections, and maintains the authoritative game state.

- **Colyseus:** Framework for multiplayer game server development that handles room-based multiplayer, state synchronization, and client message processing.

- **Colyseus Schema:** Provides efficient state synchronization between server and clients with binary encoding and delta updates.

## Networking
- **WebSockets:** Underlying protocol for real-time bidirectional communication between clients and server.

- **Client-Server Architecture:** Maintains authoritative game state on the server to prevent cheating and ensure consistent gameplay.

- **Room-Based Multiplayer:** Organizes players into game rooms with shared state and scoped communication.

## Development Tools
- **Git:** Version control system to track changes and manage the project's codebase.

- **npm:** Package manager for JavaScript, used to manage dependencies and run scripts.

- **Nodemon:** Development utility that monitors server.js changes and automatically restarts the server during development.

- **ESLint:** JavaScript linter that helps maintain code quality and consistency.

## Project Organization
- **Client-Server Separation:** Distinct code organization with `/client` directory for front-end and root-level server code.

- **Modular Design:** Separate JavaScript modules for different game systems (networking, rendering, game logic).

- **Build Process:** Custom scripts to compile and bundle client code for production deployment.

## Deployment
- **Node.js Hosting:** Server deployed on Node.js compatible hosting platforms (e.g., Heroku, AWS, DigitalOcean).

- **Static Asset Serving:** Client-side assets (HTML, CSS, JS) served by the Node.js server.

## Why This Stack?

- **Three.js:** Provides powerful 3D rendering capabilities with a manageable learning curve, ideal for creating the Numberblock characters and interactive 3D environment.

- **Colyseus:** Purpose-built for multiplayer games with efficient state synchronization and room management, simplifying networked gameplay implementation.

- **Client-Server Model:** Ensures fair gameplay by maintaining authoritative state on the server, preventing client-side cheating.

- **Node.js:** Enables JavaScript throughout the stack, reducing context switching and allowing code sharing between client and server when appropriate.

This tech stack supports all core gameplay mechanics of Numberblocks, including the dynamic character models, mathematical interactions, and multiplayer functionality, while providing a solid foundation for future enhancements.
 
 
===================================================== 
FILE: server.js 
===================================================== 
 
// Import required modules
const http = require('http');
const express = require('express');
const { Server } = require('colyseus');
const { Room } = require("colyseus");
const { Schema, MapSchema, type } = require("@colyseus/schema");
const path = require('path');

// Define the state schema for Colyseus
class Player extends Schema {
    constructor() {
        super();
        this.x = 0;
        this.y = 1;
        this.z = 5;
        this.value = 1;
        this.rotationY = 0;
        this.pitch = 0;
        this.operator = null;
        this.color = "#FFFFFF";
        this.name = "";
    }
}

class Operator extends Schema {
    constructor() {
        super();
        this.id = "";
        this.type = ""; // 'plus' or 'minus'
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }
}

class GameState extends Schema {
    constructor() {
        super();
        this.players = new MapSchema();
        this.operators = new MapSchema();
        this.staticNumberblocks = new MapSchema();
    }
}

// Register schema types
type("number")(Player.prototype, "x");
type("number")(Player.prototype, "y");
type("number")(Player.prototype, "z");
type("number")(Player.prototype, "value");
type("number")(Player.prototype, "rotationY");
type("number")(Player.prototype, "pitch");
type("string")(Player.prototype, "operator");
type("string")(Player.prototype, "color");
type("string")(Player.prototype, "name");

type("string")(Operator.prototype, "id");
type("string")(Operator.prototype, "type");
type("number")(Operator.prototype, "x");
type("number")(Operator.prototype, "y");
type("number")(Operator.prototype, "z");

type({ map: Player })(GameState.prototype, "players");
type({ map: Operator })(GameState.prototype, "operators");
type({ map: Player })(GameState.prototype, "staticNumberblocks");

// Define the game room
class NumberblocksRoom extends Room {
    onCreate(options) {
        console.log("NumberblocksRoom created!", options);
        
        // Initialize room state
        this.setState(new GameState());
        
        // Set maximum number of clients
        this.maxClients = 4;
        
        // Set frequency of patches to send
        this.setPatchRate(1000 / 30); // 30 fps
        
        // Set simulation interval for server-side logic
        this.setSimulationInterval(() => this.update());
        
        // Setup operator spawning system
        this.spawnTimer = 0;
        this.spawnInterval = this.getRandomSpawnInterval();
        this.maxOperators = 10;
        
        // Setup static numberblocks
        this.createStaticNumberblock("static1", 2, 0, 0, -5);
        this.createStaticNumberblock("static2", 3, 5, 0, -5);
        this.createStaticNumberblock("static3", 4, -5, 0, -5);
        this.createStaticNumberblock("static4", 5, 0, 0, -10);
        this.createStaticNumberblock("static5", 1, 5, 0, -10);
        
        console.log("Room initialized with GameState:", this.state);
        
        // Listen for messages from clients
        this.onMessage("move", (client, message) => {
            const player = this.state.players[client.sessionId];
            if (player) {
                // Validate movement with speed limit
                const speedLimit = 5.0 * (1/30); // moveSpeed * delta
                const dx = message.x - player.x;
                const dz = message.z - player.z;
                
                // Simple distance check for speed hacking prevention
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance <= speedLimit * 2) { // Allow some flexibility with speed
                    player.x = message.x;
                    player.y = message.y;
                    player.z = message.z;
                    player.rotationY = message.rotationY;
                    player.pitch = message.pitch;
                    
                    // Debug log occasional position updates (every 5 seconds)
                    if (Math.random() < 0.01) {
                        console.log(`Player ${client.sessionId} at position: (${player.x.toFixed(2)}, ${player.y.toFixed(2)}, ${player.z.toFixed(2)})`);
                    }
                } else {
                    console.log(`Rejected movement from ${client.sessionId}: too fast (${distance.toFixed(2)} > ${speedLimit.toFixed(2)})`);
                    // Send correction message
                    client.send("correction", {
                        x: player.x,
                        y: player.y,
                        z: player.z
                    });
                }
            }
        });
        
        this.onMessage("collectOperator", (client, message) => {
            const player = this.state.players[client.sessionId];
            const operator = this.state.operators[message.id];
            
            if (player && operator) {
                // Set the player's operator explicitly
                player.operator = operator.type;
                
                // Apply operator effect
                if (operator.type === "plus") {
                    player.value++;
                } else if (operator.type === "minus" && player.value > 1) {
                    player.value--;
                }
                
                // Remove operator from state
                delete this.state.operators[operator.id];
                console.log(`Player ${client.sessionId} collected ${operator.type} operator`);
            }
        });
        
        this.onMessage("numberblockCollision", (client, message) => {
            const player = this.state.players[client.sessionId];
            const targetId = message.targetId;
            let target;
            
            // Check if target is another player or a static numberblock
            if (this.state.players[targetId]) {
                target = this.state.players[targetId];
            } else if (this.state.staticNumberblocks[targetId]) {
                target = this.state.staticNumberblocks[targetId];
            }
            
            if (player && target) {
                // Handle the collision based on operator
                if (player.operator === "plus") {
                    player.value += target.value;
                    player.operator = null;
                } else if (player.operator === "minus" && player.value > target.value) {
                    player.value -= target.value;
                    player.operator = null;
                }
                
                // If target was a static numberblock, we don't change it
                // If target was another player, we'd need additional logic here
            }
        });
    }
    
    update() {
        // Spawn operators periodically
        this.spawnTimer += 1/30; // Assuming 30 fps
        if (this.spawnTimer >= this.spawnInterval && Object.keys(this.state.operators).length < this.maxOperators) {
            this.spawnOperator();
            this.spawnTimer = 0;
            this.spawnInterval = this.getRandomSpawnInterval();
        }
        
        // Check for collisions between players (could be added here)
    }
    
    // Get a random spawn interval between 5-10 seconds
    getRandomSpawnInterval() {
        return 5 + Math.random() * 5; // 5-10 seconds
    }
    
    // Spawn a new operator
    spawnOperator() {
        const id = `op_${Math.floor(Math.random() * 10000)}`;
        const type = Math.random() > 0.5 ? "plus" : "minus";
        
        // Create operator with random position
        const operator = new Operator();
        operator.id = id;
        operator.type = type;
        
        // Set random position (40x40 map)
        const mapSize = 40;
        operator.x = (Math.random() * mapSize) - (mapSize / 2);
        operator.y = 0.6; // Slightly above ground
        operator.z = (Math.random() * mapSize) - (mapSize / 2);
        
        // Add to state
        this.state.operators[id] = operator;
        console.log(`Spawned ${type} operator at (${operator.x.toFixed(2)}, ${operator.y}, ${operator.z.toFixed(2)})`);
    }
    
    // Create a static numberblock (for players to interact with)
    createStaticNumberblock(id, value, x, y, z) {
        const staticBlock = new Player();
        staticBlock.value = value;
        staticBlock.x = x;
        // Set Y position to 0 (ground level)
        staticBlock.y = 0;
        staticBlock.z = z;
        
        this.state.staticNumberblocks[id] = staticBlock;
        console.log(`Created static numberblock with ID ${id}, value ${value} at (${x}, ${staticBlock.y}, ${z})`);
    }
    
    onJoin(client, options) {
        console.log(`Client joined: ${client.sessionId}`);
        
        // Create a new player instance
        const player = new Player();
        
        // Set initial player position
        player.x = 0;
        player.y = 1;
        player.z = 5; // Start slightly behind origin
        
        // Set player value and other properties
        player.value = 1;
        // Use client ID as the player name for now
        player.name = client.sessionId;
        player.color = this.getColorForPlayer(Object.keys(this.state.players).length);
        
        // Add player to game state - using .set() method for MapSchema
        this.state.players.set(client.sessionId, player);
        
        console.log(`Player ${player.name} (${client.sessionId}) joined with color ${player.color}`);
        console.log(`Current players in room:`, JSON.stringify(this.state.players));
        console.log(`Total players:`, this.state.players.size);
    }
    
    onLeave(client, consented) {
        console.log(`${client.sessionId} left the game`);
        
        // Remove player from room state - use delete() method for MapSchema
        this.state.players.delete(client.sessionId);
        
        console.log(`Player ${client.sessionId} removed. Remaining players: ${this.state.players.size}`);
    }
    
    // Get a distinct color for each player
    getColorForPlayer(index) {
        const colors = [
            "#FF0000", // Red
            "#00FF00", // Green
            "#0000FF", // Blue
            "#FFFF00"  // Yellow
        ];
        return colors[index % colors.length];
    }
}

// Create Express app and HTTP server
const app = express();
const server = http.createServer(app);

// Set up static file serving
app.use(express.static(path.join(__dirname, 'client')));

// Serve the main index.html
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'client', 'index.html'));
});

// Create and attach Colyseus server
const gameServer = new Server({
    server,
    express: app
});

// Define room handlers
gameServer.define("numberblocks", NumberblocksRoom);

// Start server
const port = process.env.PORT || 3000;
server.listen(port, () => {
    console.log(`Numberblocks game server is running on http://localhost:${port}`);
});
 
 
===================================================== 
FILE: package.json 
===================================================== 
 
{
  "name": "numberblocks",
  "version": "1.0.0",
  "description": "A 3D multiplayer browser-based game inspired by the Numberblocks educational show. Players control Numberblock characters and interact with operators in a fun mathematical environment.",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "colyseus": "^0.16.3",
    "express": "^4.21.2"
  },
  "devDependencies": {
    "nodemon": "^3.1.9"
  }
}
 
 
===================================================== 
FILE: client\index.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numberblocks Game</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        #game-canvas { display: block; width: 100vw; height: 100vh; }
        #lock-instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 999;
        }
        #game-hud {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            z-index: 100;
        }
        .hud-value {
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
            text-align: right;
        }
        #multiplayer-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 5px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            width: 120px;
            z-index: 999;
            font-size: 12px;
            display: block;
            transition: all 0.3s ease;
        }
        #player-list-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #player-list-header h3 {
            margin: 0;
            padding: 0;
            font-size: 14px;
        }
        #player-list {
            margin-top: 5px;
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            transition: height 0.3s ease;
        }
        .player-entry {
            padding: 3px;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            font-size: 11px;
            background-color: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        .player-color {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
            flex-shrink: 0;
        }
        .player-info {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #collapse-icon {
            transition: transform 0.3s ease;
        }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    
    <div id="lock-instructions">
        <h2>Numberblocks Game</h2>
        <p>Click anywhere to enable controls</p>
        <ul>
            <li>Move: WASD or Arrow Keys</li>
            <li>Jump: Space</li>
            <li>Look: Mouse</li>
            <li>Turn: Q & E Keys</li>
        </ul>
    </div>
    
    <!-- Multiplayer panel - Players List -->
    <div id="multiplayer-panel">
        <div id="player-list-header">
            <h3>Players <span id="player-count">(0)</span></h3>
            <span id="collapse-icon">▼</span>
        </div>
        <div id="player-list"></div>
    </div>
    
    <!-- Game HUD -->
    <div id="game-hud"></div>
    
    <!-- Three.js library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    
    <!-- Colyseus client library -->
    <script src="https://unpkg.com/colyseus.js@^0.16.3/dist/colyseus.js"></script>
    
    <!-- Numberblocks game scripts -->
    <script src="js/numberblock.js"></script>
    <script src="js/main-fixed.js"></script>
    <script src="js/network.js"></script>
</body>
</html>
 
 
===================================================== 
FILE: client\css\styles.css 
===================================================== 
 
/* Reset default margins and padding */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
}

body, html {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background-color: #000;
}

/* Make the canvas fill the entire screen */
#game-canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* Fix for horizontal bar issue - ensuring no elements create unwanted artifacts */
canvas {
    position: fixed;
    top: 0;
    left: 0;
    outline: none;
}

/* Controls info overlay */
.overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    z-index: 100;
}

.overlay h2 {
    margin-bottom: 10px;
}

.overlay p {
    margin-bottom: 15px;
}

.overlay ul {
    list-style-type: none;
    text-align: left;
    margin: 0 auto;
    display: inline-block;
}

.overlay ul li {
    margin-bottom: 5px;
}

/* Game HUD */
.hud {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 10;
    color: white;
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.8);
    background-color: rgba(0, 0, 0, 0.5);
    padding: 10px 15px;
    border-radius: 8px;
    pointer-events: none; /* Allow clicking through the HUD */
}

#player-number-display {
    display: flex;
    align-items: center;
    justify-content: flex-end;
}

#player-value {
    margin-left: 5px;
    font-size: 32px;
}

/* Ensure no overflow elements */
body, html, canvas {
    overflow: hidden;
}
 
 
===================================================== 
FILE: client\js\collision.js 
===================================================== 
 
/**
 * Numberblocks AABB Collision System
 * Uses Axis-Aligned Bounding Boxes for efficient collision detection
 */

// Collection of collidable objects
let collidableObjects = [];
let debugMode = true; // Set to true to see debug logging

// Initialize collision system and collect collidable objects from the scene
function initCollisionSystem(scene) {
    console.log("Initializing collision system...");
    collidableObjects = [];
    
    // Traverse the scene to find all collidable objects
    scene.traverse((object) => {
        if (object.isMesh && object.userData && object.userData.collidable === true) {
            collidableObjects.push(object);
            if (debugMode) console.log(`Added collidable object: ${object.name || 'unnamed object'}`);
        }
    });
    
    console.log(`Collision system initialized with ${collidableObjects.length} collidable objects`);
    return collidableObjects.length;
}

// Add a single object to the collidable objects list
function addCollidableObject(object) {
    if (!object || !(object.isMesh || object.isGroup)) return;
    
    // Mark the object as collidable
    object.userData = object.userData || {};
    object.userData.collidable = true;
    
    // Add a name if it doesn't have one for easier debugging
    if (!object.name) {
        object.name = `collidable_${collidableObjects.length}`;
    }
    
    // Only add if not already in the list
    if (!collidableObjects.includes(object)) {
        collidableObjects.push(object);
        if (debugMode) console.log(`Added collidable object: ${object.name}`);
        
        // If it's a group, also make all children collidable
        if (object.isGroup && object.children) {
            object.children.forEach(child => {
                if (child.isMesh) {
                    child.userData = child.userData || {};
                    child.userData.collidable = true;
                    collidableObjects.push(child);
                    if (debugMode) console.log(`Added child collidable object: ${child.name || 'unnamed child'}`);
                }
            });
        }
    }
}

// Create or update a bounding box for a mesh
function updateAABB(mesh) {
    if (!mesh) return null;
    
    // Use Three.js Box3 to create a bounding box from the mesh
    const box = new THREE.Box3().setFromObject(mesh);
    return box;
}

// Check if two bounding boxes intersect
function checkCollision(boxA, boxB) {
    if (!boxA || !boxB) return false;
    return boxA.intersectsBox(boxB);
}

// Get the minimum translation vector to resolve a collision
function getCollisionResponse(boxA, boxB) {
    // Create a box that represents the intersection
    const intersection = new THREE.Box3();
    intersection.copy(boxA).intersect(boxB);
    
    // Get the size of the intersection
    const size = intersection.getSize(new THREE.Vector3());
    
    // Find the minimum penetration axis (x, y, or z)
    let axis, minSize;
    
    if (size.x <= size.y && size.x <= size.z) {
        axis = 'x';
        minSize = size.x;
    } else if (size.y <= size.x && size.y <= size.z) {
        axis = 'y';
        minSize = size.y;
    } else {
        axis = 'z';
        minSize = size.z;
    }
    
    // Return the direction and amount to move
    const response = {
        axis: axis,
        depth: minSize,
        direction: new THREE.Vector3()
    };
    
    // Calculate the direction to move (away from the obstacle)
    const centerA = boxA.getCenter(new THREE.Vector3());
    const centerB = boxB.getCenter(new THREE.Vector3());
    
    if (axis === 'x') {
        response.direction.x = centerA.x < centerB.x ? -1 : 1;
    } else if (axis === 'y') {
        response.direction.y = centerA.y < centerB.y ? -1 : 1;
    } else {
        response.direction.z = centerA.z < centerB.z ? -1 : 1;
    }
    
    return response;
}

// Check collisions for the player against all collidable objects
function checkPlayerCollisions(playerMesh, controlsObject) {
    if (!playerMesh || !controlsObject || collidableObjects.length === 0) {
        return { collision: false, grounded: false };
    }
    
    // Update player bounding box
    const playerBox = updateAABB(playerMesh);
    let hasCollision = false;
    let isGrounded = false;
    
    // Check against all collidable objects
    for (const obstacle of collidableObjects) {
        // Skip player's own mesh
        if (obstacle === playerMesh) continue;
        
        const obstacleBox = updateAABB(obstacle);
        if (checkCollision(playerBox, obstacleBox)) {
            hasCollision = true;
            if (debugMode) console.log(`Collision detected with ${obstacle.name || 'unnamed object'}`);
            
            // Handle the collision and check if we're standing on something
            const collisionResult = handleCollision(playerBox, obstacleBox, controlsObject);
            if (collisionResult.landedOnTop) {
                isGrounded = true;
            }
        }
    }
    
    return { collision: hasCollision, grounded: isGrounded };
}

// Apply collision response and return collision info
function handleCollision(playerBox, obstacleBox, controlsObject) {
    const response = getCollisionResponse(playerBox, obstacleBox);
    
    // Apply a small buffer to prevent getting stuck
    const buffer = 0.1;
    let landedOnTop = false;
    
    // Apply the collision response to the controls object
    if (response.axis === 'x') {
        controlsObject.position.x += (response.depth + buffer) * response.direction.x;
    } else if (response.axis === 'y') {
        // For Y-axis collisions, we need to determine if we landed on top
        if (response.direction.y > 0) {
            // We hit the bottom of something
            controlsObject.position.y += (response.depth + buffer) * response.direction.y;
        } else {
            // We landed on top of something
            controlsObject.position.y += (response.depth + buffer) * response.direction.y;
            landedOnTop = true;
            
            // Stop any downward velocity if we're using physics
            if (controlsObject.userData && controlsObject.userData.velocity) {
                controlsObject.userData.velocity.y = 0;
            }
        }
    } else {
        controlsObject.position.z += (response.depth + buffer) * response.direction.z;
    }
    
    return { landedOnTop };
}

// Mark objects in the scene as collidable
function markAllObjectsAsCollidable(scene) {
    scene.traverse(object => {
        // Skip the player, camera, lights, and ground
        if (object.name === 'ground' || 
            object.name === 'player' || 
            object.isLight || 
            object.isCamera) {
            return;
        }
        
        // Mark all meshes that aren't the player, lights, or ground as collidable
        if (object.isMesh) {
            object.userData = object.userData || {};
            object.userData.collidable = true;
            
            // Add it to our collidable objects array if not already there
            if (!collidableObjects.includes(object)) {
                collidableObjects.push(object);
                if (debugMode) console.log(`Auto-marked as collidable: ${object.name || 'unnamed mesh'}`);
            }
        }
    });
    
    console.log(`Total collidable objects after auto-marking: ${collidableObjects.length}`);
}

// No modules export - functions are accessible globally for traditional script inclusion
 
 
===================================================== 
FILE: client\js\controls.js 
===================================================== 
 
// Numberblocks game - First-person controls implementation

// Global variables
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let turnLeft = false;    // New variable for Q key turning
let turnRight = false;   // New variable for E key turning
let canJump = false;
let pitch = 0;  // Track vertical rotation separately
// isFirstPerson is a global variable attached to the window object in main.js

let prevTime = performance.now();
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();

// Player settings
const playerHeight = 2.0;             // Height of camera from ground
const moveSpeed = 5.0;                // Units per second
const turnSpeed = 2.0;                // Rotation speed for Q/E turning
const jumpHeight = 5.0;               // Jump impulse force
const gravity = 9.8;                  // Gravity force 

// Initialize controls for the camera
window.initControls = function(camera, domElement) {
    console.log("Initializing PointerLockControls properly...");

    const controls = new THREE.PointerLockControls(camera, domElement);

    domElement.addEventListener('click', () => {
        controls.lock();
    });

    controls.addEventListener('lock', () => {
        if (window.isFirstPerson) {
            document.getElementById('controls-info').style.display = 'none';
        }
        // Always hide cursor when locked, regardless of view mode
        document.body.style.cursor = 'none';
    });

    controls.addEventListener('unlock', () => {
        if (window.isFirstPerson) {
            document.getElementById('controls-info').style.display = 'block';
        }
        // Always show cursor when unlocked, regardless of view mode
        document.body.style.cursor = 'auto';
    });

    // Keyboard listeners for movement remain as-is
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    return controls;
}

// Key down event handler
function onKeyDown(event) {
    // Skip if we're in an input field or textarea
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
        return;
    }
    
    // Map key code to action
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = true;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = true;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = true;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            moveRight = true;
            break;
            
        case 'KeyQ':
            turnLeft = true;
            break;
            
        case 'KeyE':
            turnRight = true;
            break;
            
        case 'Space':
            if (canJump) {
                // Apply a physically accurate jump velocity
                velocity.y = Math.sqrt(jumpHeight * 2 * gravity);
                canJump = false;
            }
            break;
    }
}

// Key up event handler
function onKeyUp(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = false;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = false;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = false;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            moveRight = false;
            break;
            
        case 'KeyQ':
            turnLeft = false;
            break;
            
        case 'KeyE':
            turnRight = false;
            break;
    }
}

// Update controls - call this in the animation loop
window.updateControls = function(controls, delta) {
    if (!controls.isLocked) return;

    if (moveForward) controls.moveForward(moveSpeed * delta);
    if (moveBackward) controls.moveForward(-moveSpeed * delta);
    if (moveLeft) controls.moveRight(-moveSpeed * delta);
    if (moveRight) controls.moveRight(moveSpeed * delta);
    
    // Proper on-axis rotation using the PointerLockControls object's quaternion
    if (turnLeft || turnRight) {
        // Create rotation quaternion for Q/E rotation
        const rotationAngle = (turnLeft ? 1 : -1) * turnSpeed * delta;
        const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(0, 1, 0), // Rotate around y-axis only
            rotationAngle
        );
        
        // Apply rotation to controls object's quaternion
        controls.getObject().quaternion.premultiply(rotationQuaternion);
    }

    velocity.y -= gravity * delta;
    controls.getObject().position.y += velocity.y * delta;

    if (controls.getObject().position.y < playerHeight) {
        velocity.y = 0;
        controls.getObject().position.y = playerHeight;
        canJump = true;
    }
}
 
 
===================================================== 
FILE: client\js\main-fixed.js 
===================================================== 
 
// Numberblocks game - Main game logic

// Debug support
const DEBUG = false;

function debug(message, isError = false) {
    if (!DEBUG) return;
    
    // Log to console only when debug is enabled
    if (isError) {
        console.error(`[ERROR] ${message}`);
    } else {
        console.log(`[DEBUG] ${message}`);
    }
}

// Game variables
let scene, camera, renderer, controls;
let playerNumberblock;
let operatorManager;
let prevTime = performance.now();
let playerValue = 1;
const playerHeight = 2.0; // Player height in units (as specified in memory)

// Add operator tracking without redeclaring variables
let heldOperator = null;
let lastOperatorSpawn = 0;

// Movement keys state
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let turnLeft = false;
let turnRight = false;

// Physics variables
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let canJump = true;

// Rotation variables for Q/E keys
let rotationQuaternion = new THREE.Quaternion();
let worldUp = new THREE.Vector3(0, 1, 0);
let rotationAxis = new THREE.Vector3();

// Add global variable for tracking view mode
window.isFirstPerson = true;

// HUD elements
const gameHUD = document.getElementById('game-hud');

// Global variables and UI elements
let viewToggleBtn = null; // Global reference for the view toggle button

// Initialize networking variables
let lastSentPosition = new THREE.Vector3();
let lastSentRotation = 0;
let positionUpdateInterval = 100; // ms between position updates
let lastPositionUpdate = 0;

// Initialize the game
window.onload = function() {
    debug('Window loaded, initializing game...');
    
    // Add view toggle button
    addViewToggleButton();
    
    init();
};

// Add view toggle button to switch between first and third person
function addViewToggleButton() {
    try {
        // Create button if it doesn't exist
        viewToggleBtn = document.getElementById('view-toggle');
        
        if (!viewToggleBtn) {
            viewToggleBtn = document.createElement('button');
            viewToggleBtn.id = 'view-toggle';
            viewToggleBtn.textContent = 'Third Person View';
            viewToggleBtn.style.position = 'absolute';
            viewToggleBtn.style.bottom = '20px';
            viewToggleBtn.style.left = '20px';
            viewToggleBtn.style.zIndex = '100';
            viewToggleBtn.style.padding = '8px 12px';
            viewToggleBtn.style.backgroundColor = '#4CAF50';
            viewToggleBtn.style.color = 'white';
            viewToggleBtn.style.border = 'none';
            viewToggleBtn.style.borderRadius = '4px';
            viewToggleBtn.style.cursor = 'pointer';
            document.body.appendChild(viewToggleBtn);
        }
        
        // Add click event listener
        viewToggleBtn.addEventListener('click', toggleCameraView);
        
        debug('View toggle button added');
    } catch (error) {
        debug(`Error adding view toggle button: ${error.message}`, true);
    }
}

// Toggle between first and third person views
function toggleCameraView() {
    window.isFirstPerson = !window.isFirstPerson;
    
    const viewToggleBtn = document.getElementById('view-toggle');
    if (viewToggleBtn) {
        viewToggleBtn.innerText = window.isFirstPerson ? 'Switch to Third Person' : 'Switch to First Person';
    }
    
    // Store the current position before switching views to ensure consistency
    const currentPosition = playerNumberblock ? playerNumberblock.mesh.position.clone() : null;
    const currentRotation = playerNumberblock ? playerNumberblock.mesh.rotation.y : 0;
    
    if (window.isFirstPerson) {
        debug('Switched to first-person view');
        switchToFirstPersonView();
    } else {
        debug('Switched to third-person view');
        switchToThirdPersonView();
    }
    
    // After switching views, ensure position consistency
    if (currentPosition && playerNumberblock) {
        playerNumberblock.mesh.position.copy(currentPosition);
        playerNumberblock.mesh.rotation.y = currentRotation;
        
        // If in first-person mode, also update controls position
        if (window.isFirstPerson && controls) {
            controls.getObject().position.set(
                currentPosition.x,
                currentPosition.y + 1.0, // Adjust for eye height
                currentPosition.z
            );
        }
        
        // Force a position update to the server to ensure sync
        if (typeof window.room !== 'undefined' && window.room) {
            window.room.send("updatePosition", {
                x: playerNumberblock.mesh.position.x,
                y: playerNumberblock.mesh.position.y,
                z: playerNumberblock.mesh.position.z,
                rotation: playerNumberblock.mesh.rotation.y
            });
        }
    }
}

// Switch to first-person view
function switchToFirstPersonView() {
    try {
        debug('Switched to first-person view');
        
        // Set global flag
        window.isFirstPerson = true;
        
        // Check if camera is already a child of controls
        // First make sure we're not trying to add camera as a child of itself
        if (camera.parent !== controls.getObject() && camera !== controls.getObject()) {
            // Remove camera from any previous parent
            if (camera.parent) {
                camera.parent.remove(camera);
            }
            
            // Add camera to controls (only if not already there)
            controls.getObject().add(camera);
        }
        
        // Reset camera position relative to controls
        camera.position.set(0, 0, 0);
        
        // Update button text
        if (viewToggleBtn) {
            viewToggleBtn.textContent = 'Third Person View';
        }
    } catch (error) {
        debug(`Error switching to first-person view: ${error.message}`, true);
    }
}

// Switch to third-person view
function switchToThirdPersonView() {
    try {
        debug('Switched to third-person view');
        
        // Set global flag
        window.isFirstPerson = false;
        
        // Remove camera from controls
        if (camera.parent) {
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            camera.parent.remove(camera);
            
            // Add camera directly to scene
            scene.add(camera);
            
            // Maintain world position
            camera.position.copy(cameraWorldPosition);
        }
        
        // Set up third-person mouse handler if it doesn't exist
        if (!window.thirdPersonMouseHandler) {
            window.thirdPersonMouseHandler = function(event) {
                // Only process if we're in third-person mode and pointer is locked
                if (!window.isFirstPerson && controls.isLocked) {
                    // Skip processing extremely small movements to prevent drift
                    if (Math.abs(event.movementX) > 0.5) {
                        window.thirdPersonCameraAngle -= event.movementX * 0.002;
                    }
                }
            };
        }
        
        // Add mouse movement handler
        document.addEventListener('mousemove', window.thirdPersonMouseHandler);
        
        // Initialize camera angle if it's not set yet
        if (typeof window.thirdPersonCameraAngle === 'undefined') {
            window.thirdPersonCameraAngle = playerNumberblock.mesh.rotation.y + Math.PI;
        }
        
        // Update button text
        if (viewToggleBtn) {
            viewToggleBtn.textContent = 'First Person View';
        }
    } catch (error) {
        debug(`Error switching to third-person view: ${error.message}`, true);
    }
}

// Main initialization function
function init() {
    try {
        debug('Initializing game');
        
        // Initialize scene
        initScene();
        
        // Create the camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5); // Start a bit back to see the player
        
        // Setup renderer
        debug('Setting up renderer');
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding; // Better color representation
        renderer.gammaFactor = 2.2; // Standard gamma correction
        
        // Add renderer to document
        document.body.appendChild(renderer.domElement);
        
        // Make renderer globally available
        window.renderer = renderer;
        
        // Initialize the floor
        initFloor();
        
        // Add decorative objects back
        addDecorativeObjects();
        
        // Add static Numberblocks
        addStaticNumberblocks();
        
        // Create player's Numberblock
        initPlayerNumberblock();
        
        // Setup event listeners
        window.addEventListener('resize', onWindowResize, false);
        
        // Setup controls based on the view mode
        debug('Setting up controls for initial view mode');
        setupPointerLockControls();
        
        // Initialize networking for multiplayer
        initNetworkingSystem();
        
        // Add button to toggle between first and third person
        addViewToggleButton();
        
        // Start the animation loop
        requestAnimationFrame(animate);
        
        debug('Game successfully initialized');
    } catch (error) {
        debug(`Full initialization error: ${error.message}`, true);
        console.error('Full initialization error:', error);
        emergencyRender();
    }
}

// Initialize the scene
function initScene() {
    try {
        debug('Creating scene');
        
        // Create the scene
        scene = new THREE.Scene();
        
        // Make scene globally available
        window.scene = scene;
        
        // Set background color
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        
        // Add fog for depth perception
        scene.fog = new THREE.Fog(0x87CEEB, 10, 100);
        
        // Add proper lighting with reduced intensity
        // Ambient light - provides overall illumination to the scene
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Reduced from 0.8
        scene.add(ambientLight);
        
        // Directional light - mimics sunlight
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reduced from 1.0
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Hemisphere light - for natural outdoor lighting (sky/ground gradient)
        const hemisphereLight = new THREE.HemisphereLight(0xddeeff, 0x3e2200, 0.4); // Reduced from 0.7
        scene.add(hemisphereLight);
        
        debug('Scene created successfully with softer lighting');
    } catch (error) {
        debug(`Error creating scene: ${error.message}`, true);
    }
}

// Initialize the floor
function initFloor() {
    try {
        debug('Creating floor');
        
        // Create a larger green floor with even darker color
        const floorGeometry = new THREE.PlaneGeometry(100, 100); // Extended size
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x114411,  // Much darker green color (almost forest green)
            roughness: 0.8, 
            metalness: 0.2 
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        
        // Rotate and position the floor
        floor.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        floor.position.y = 0;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Add a grid helper for visual reference
        const gridHelper = new THREE.GridHelper(100, 100, 0x000000, 0x444444);
        scene.add(gridHelper);
        
        debug('Floor and grid created successfully');
    } catch (error) {
        debug(`Error creating floor: ${error.message}`, true);
    }
}

// Setup PointerLock controls
function setupPointerLockControls() {
    debug('Setting up PointerLock controls');
    
    try {
        // Create controls
        controls = new THREE.PointerLockControls(camera, document.body);
        debug('PointerLockControls initialized: ' + controls);
        
        // Make controls globally available
        window.controls = controls;
        
        // Use the existing instructions element from HTML
        let instructions = document.getElementById('lock-instructions');
        
        // Function to handle pointer lock change - simplified
        function onPointerLockChange() {
            if (document.pointerLockElement === document.body || 
                document.mozPointerLockElement === document.body ||
                document.webkitPointerLockElement === document.body) {
                
                // Pointer is locked, hide instructions
                if (instructions) {
                    instructions.style.display = 'none';
                }
                
                // Set first person active flag
                window.isFirstPerson = true;
                debug('Pointer is locked - first person active');
                
                // Ensure player starts on the ground when re-entering
                if (controls && controls.getObject()) {
                    // Only reset the Y position, not X and Z
                    const currentPos = controls.getObject().position;
                    if (currentPos.y > 5) { // If they're way up in the air
                        currentPos.y = 1.0; // Set to floor level + player height
                        velocity.y = 0;     // Reset vertical velocity
                    }
                }
            } else {
                // Only show instructions if we're not in preview mode
                if (!window.previewControlsMode && instructions) {
                    instructions.style.display = 'block';
                }
                debug('Pointer is unlocked');
            }
        }
        
        // Function to handle pointer lock error - simplified
        function onPointerLockError() {
            debug('Pointer lock error', true);
            
            // Enable preview controls without extra messages
            window.previewControlsMode = true;
            
            // Hide instructions after a delay
            setTimeout(() => {
                if (instructions) {
                    instructions.style.display = 'none';
                }
            }, 3000);
        }
        
        // Add event listeners for pointer lock
        document.addEventListener('click', function() {
            if (instructions && instructions.style.display !== 'none') {
                controls.lock();
            }
        });
        
        // Add pointer lock change and error event listeners
        document.addEventListener('pointerlockchange', onPointerLockChange);
        document.addEventListener('mozpointerlockchange', onPointerLockChange);
        document.addEventListener('webkitpointerlockchange', onPointerLockChange);
        
        document.addEventListener('pointerlockerror', onPointerLockError);
        document.addEventListener('mozpointerlockerror', onPointerLockError);
        document.addEventListener('webkitpointerlockerror', onPointerLockError);
        
        // Add controls to scene
        scene.add(controls.getObject());
        
        // Setup movement
        moveForward = false;
        moveBackward = false;
        moveLeft = false;
        moveRight = false;
        canJump = false;
        
        // Set up keyboard event listeners
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        
        debug('PointerLock controls setup complete');
    } catch (error) {
        debug(`Error setting up PointerLock controls: ${error.message}`, true);
    }
}

// Update player movement physics
function updatePlayerPhysics(delta) {
    try {
        // Skip if controls are disabled or not initialized
        if (!controls) {
            console.log("Controls disabled or not initialized");
            return;
        }
        
        // Allow movement in preview mode even without pointer lock
        const isPreviewMode = window.previewControlsMode === true;
        
        // Skip if not locked (unless in preview mode)
        if (!controls.isLocked && !isPreviewMode) {
            return;
        }

        // Apply movement damping
        velocity.x -= velocity.x * 10.0 * delta; 
        velocity.z -= velocity.z * 10.0 * delta;
        
        // Apply gravity (9.8 as specified in memory)
        velocity.y -= 9.8 * delta;
        
        // Calculate movement direction based on input
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        
        // Only normalize if we're actually moving
        if (direction.x !== 0 || direction.z !== 0) {
            direction.normalize(); // Ensure consistent movement regardless of direction
        }
        
        // Apply movement force (scaled to achieve 5.0 units/sec)
        // Using a higher value to compensate for damping
        const moveSpeed = 50.0;
        
        if (moveForward || moveBackward) {
            velocity.z -= direction.z * moveSpeed * delta;
        }
        if (moveLeft || moveRight) {
            velocity.x -= direction.x * moveSpeed * delta;
        }
        
        // Apply velocity to controls for movement
        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
        
        // Apply jump physics
        controls.getObject().position.y += velocity.y * delta;
        
        // Check for floor collision
        if (controls.getObject().position.y < 1.0) { // Player height is 2.0 units
            velocity.y = 0;
            controls.getObject().position.y = 1.0;
            canJump = true;
        }
        
        // Update player numberblock position AND ROTATION to match camera
        if (playerNumberblock) {
            // Update position
            playerNumberblock.mesh.position.copy(controls.getObject().position);
            
            // Get camera rotation (from controls quaternion)
            const cameraQuaternion = controls.getObject().quaternion;
            const euler = new THREE.Euler().setFromQuaternion(cameraQuaternion, 'YXZ');
            
            // Update numberblock rotation to match camera's Y rotation (yaw)
            playerNumberblock.mesh.rotation.y = euler.y;
            
            // Offset the numberblock to be at the player's feet
            const numberblockHeight = playerNumberblock.getHeight ? playerNumberblock.getHeight() : 1;
            playerNumberblock.mesh.position.y -= (playerHeight / 2) + (numberblockHeight / 2);
            
            // Force numberblock to be visible in first-person mode
            playerNumberblock.mesh.visible = true;
        }
        
        // Send movement to server
        sendRegularPositionUpdate();
    } catch (error) {
        console.error(`Error updating player movement: ${error.message}`);
    }
}

// Main animation loop
function animate() {
    try {
        // Request next animation frame 
        requestAnimationFrame(animate);
        
        // Calculate delta time
        const time = performance.now();
        const delta = Math.min((time - prevTime) / 1000, 0.1); // Cap delta to avoid large jumps
        
        // Update player movement based on view mode
        if (window.isFirstPerson) {
            updatePlayerPhysics(delta);
        } else {
            updatePlayerPositionThirdPerson(time, delta);
            updateThirdPersonCamera();
        }
        
        // Force position updates periodically for network
        if (time - lastPositionUpdate > positionUpdateInterval) {
            sendRegularPositionUpdate();
            lastPositionUpdate = time;
        }
        
        // Update operators
        updateOperators();
        
        // Check for collisions
        if (playerNumberblock) {
            checkCollisions();
        }
        
        // Render the scene
        renderer.render(scene, camera);
        
        // Update game loop vars
        prevTime = time;
    } catch (error) {
        debug(`Error in animate loop: ${error.message}`, true);
    }
}

// Send regular position updates to the server for multiplayer synchronization
function sendRegularPositionUpdate() {
    try {
        if (!window.room || typeof window.sendPlayerUpdate !== 'function') {
            return;
        }
        
        let currentPos, currentRot;
        
        // Get current position and rotation based on view mode
        if (window.isFirstPerson && controls) {
            currentPos = controls.getObject().position;
            currentRot = controls.getObject().rotation.y;
        } else if (playerNumberblock && playerNumberblock.mesh) {
            currentPos = playerNumberblock.mesh.position;
            currentRot = playerNumberblock.mesh.rotation.y;
        } else {
            return; // No valid position
        }
        
        // Always send updates (remove threshold check to ensure frequent updates)
        // This ensures other players always see your current position
        
        // Send update to server
        window.sendPlayerUpdate(
            currentPos,
            currentRot,
            window.isFirstPerson ? camera.rotation.x : 0,
            playerValue
        );
        
        // Update last sent values
        lastSentPosition.copy(currentPos);
        lastSentRotation = currentRot;
        
        // Debug log to confirm sending
        if (DEBUG) {
            console.log(`Position update sent: ${currentPos.x.toFixed(2)}, ${currentPos.y.toFixed(2)}, ${currentPos.z.toFixed(2)}`);
        }
    } catch (error) {
        console.error("Error sending regular position update:", error);
    }
}

// Update player position in third-person mode
function updatePlayerPositionThirdPerson(time, delta) {
    try {
        if (!playerNumberblock || !controls) return;
        
        const moveSpeed = 5.0; // Movement speed as specified in memory
        const rotationSpeed = 2.0; // Rotation speed for Q/E keys
        
        // Get camera's current direction vectors, using proper forward/right orientation
        const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        
        // Project to horizontal plane by zeroing Y and normalizing
        const forward = cameraDirection.clone().setY(0).normalize();
        const right = cameraRight.clone().setY(0).normalize();
        
        // Calculate desired movement direction from keyboard input
        const movement = new THREE.Vector3();
        if (moveForward) movement.add(forward);
        if (moveBackward) movement.sub(forward);
        if (moveLeft) movement.sub(right);
        if (moveRight) movement.add(right);
        
        // Apply gravity
        velocity.y -= 9.8 * delta;
        
        if (movement.length() > 0) {
            movement.normalize().multiplyScalar(moveSpeed * delta);
            
            // Update player position
            playerNumberblock.mesh.position.add(movement);
            
            // Rotate player to face movement direction if moving (and no manual rotation with Q/E)
            if (!turnLeft && !turnRight) {
                const targetAngle = Math.atan2(movement.x, movement.z);
                playerNumberblock.mesh.rotation.y = targetAngle;
            }
        }
        
        // Update vertical position with gravity
        playerNumberblock.mesh.position.y += velocity.y * delta;
        
        // Check for floor collision
        if (playerNumberblock.mesh.position.y < 0.5) {
            velocity.y = 0;
            playerNumberblock.mesh.position.y = 0.5;
            canJump = true;
        }
        
        // Rotate player using Q/E keys
        if (turnLeft) playerNumberblock.mesh.rotation.y += rotationSpeed * delta;
        if (turnRight) playerNumberblock.mesh.rotation.y -= rotationSpeed * delta;
        
        // Send position to server for multiplayer
        if (typeof window.room !== 'undefined' && window.room) {
            window.sendPlayerUpdate(
                playerNumberblock.mesh.position, 
                playerNumberblock.mesh.rotation.y,
                0, // pitch not used in third-person
                playerValue
            );
        }
    } catch (error) {
        debug(`Error in updatePlayerPositionThirdPerson: ${error.message}`, true);
    }
}

// Update third-person camera position
function updateThirdPersonCamera() {
    try {
        if (!playerNumberblock || !playerNumberblock.mesh) return;
        
        const distance = 12;      // Camera distance behind the player
        const heightOffset = 8;   // Height offset above the player
        const smoothing = 0.1;    // Smooth camera motion factor
        const rotationSpeed = 0.05;
        
        // Initialize the angle if not set
        if (typeof window.thirdPersonCameraAngle === 'undefined') {
            window.thirdPersonCameraAngle = playerNumberblock.mesh.rotation.y + Math.PI;
        }
        
        // Adjust camera angle with Q/E keys
        if (turnLeft) window.thirdPersonCameraAngle += rotationSpeed;
        if (turnRight) window.thirdPersonCameraAngle -= rotationSpeed;
        
        // Calculate desired camera position explicitly without cumulative interpolation errors
        const playerPos = playerNumberblock.mesh.position.clone();
        const targetX = playerPos.x - Math.sin(window.thirdPersonCameraAngle) * distance;
        const targetZ = playerPos.z - Math.cos(window.thirdPersonCameraAngle) * distance;
        
        // Ensure camera Y position is always exactly at height offset plus player's midpoint height
        const targetY = playerNumberblock.mesh.position.y + heightOffset;
        
        // Set camera position explicitly without smoothing vertically to prevent drift
        camera.position.set(
            THREE.MathUtils.lerp(camera.position.x, targetX, 0.1),
            targetY, // No vertical smoothing
            THREE.MathUtils.lerp(camera.position.z, targetZ, 0.1)
        );
        
        // Always look at the player's midpoint height directly
        const heightAdjustment = playerNumberblock.getHeight ? playerNumberblock.getHeight() / 2 : 1;
        camera.lookAt(
            playerNumberblock.mesh.position.x,
            targetY - (heightOffset / 2),
            playerNumberblock.mesh.position.z
        );
    } catch (error) {
        debug(`Error in updateThirdPersonCamera: ${error.message}`, true);
    }
}

// Update operators (animate them)
function updateOperators() {
    try {
        if (!window.visuals || !window.visuals.operators) {
            return;
        }
        
        // Get all operator visuals
        const operators = window.visuals.operators;
        
        // Calculate deltaTime (approximate)
        const deltaTime = 1/60;
        
        // Animate each operator
        for (const operatorId in operators) {
            const operator = operators[operatorId];
            if (operator && typeof operator.animate === 'function') {
                operator.animate(deltaTime);
            }
        }
    } catch (error) {
        debug(`Error updating operators: ${error.message}`, true);
    }
}

// Check for collisions with operators and other Numberblocks
function checkCollisions() {
    // Will be implemented with proper collision detection
}

// Update player's Numberblock value
function updatePlayerValue(newValue) {
    try {
        playerValue = newValue;
        
        // Update the Numberblock
        if (playerNumberblock) {
            scene.remove(playerNumberblock.mesh);
            playerNumberblock = new Numberblock(playerValue);
            scene.add(playerNumberblock.mesh);
            
            // Position it correctly based on camera/controls
            if (window.isFirstPerson) {
                playerNumberblock.mesh.position.copy(controls.getObject().position);
                playerNumberblock.mesh.position.y -= 1.0; // Position below camera
                playerNumberblock.mesh.rotation.y = controls.getObject().rotation.y;
            }
        }
        
        // Update HUD
        updateHUD();
        
        debug(`Player value updated to ${playerValue}`);
    } catch (error) {
        debug(`Error updating player value: ${error.message}`, true);
    }
}

// Update the HUD display
function updateHUD() {
    if (gameHUD) {
        gameHUD.innerHTML = `<div class="hud-value">Number: ${playerValue}</div>`;
    }
}

// For Numberblock prototype to enable getHeight() method
if (typeof window.Numberblock === 'undefined') {
    window.Numberblock = function() {};
    window.Numberblock.prototype.getHeight = function() {
        // Default height if not available
        return 2;
    };
}

// Handle window resize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Handle keyboard input
function onKeyDown(event) {
    try {
        if (document.activeElement !== document.body) return; // Skip if focused on input
        
        console.log(`Key pressed: ${event.code}`); // Debug logging
        
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW':
                moveForward = true;
                console.log("moveForward = true"); // Debug logging
                break;
            case 'ArrowLeft':
            case 'KeyA':
                moveLeft = true;
                console.log("moveLeft = true"); // Debug logging
                break;
            case 'ArrowDown':
            case 'KeyS':
                moveBackward = true;
                console.log("moveBackward = true"); // Debug logging
                break;
            case 'ArrowRight':
            case 'KeyD':
                moveRight = true;
                console.log("moveRight = true"); // Debug logging
                break;
            case 'Space':
                if (canJump) {
                    velocity.y = 5.0;
                    canJump = false;
                }
                break;
            case 'KeyV':
                // Toggle between first and third person view
                toggleCameraView();
                break;
            case 'KeyQ':
                // Turn left
                turnLeft = true;
                if (window.isFirstPerson) {
                    // Use quaternion rotation around world up axis (y-axis)
                    rotationAxis.copy(worldUp);
                    const rotationAngle = 0.05; // Same amount as before
                    rotationQuaternion.setFromAxisAngle(rotationAxis, rotationAngle);
                    
                    // Apply to the camera object - this matches how PointerLockControls works
                    controls.getObject().quaternion.premultiply(rotationQuaternion);
                }
                break;
            case 'KeyE':
                // Turn right
                turnRight = true;
                if (window.isFirstPerson) {
                    // Use quaternion rotation around world up axis (y-axis)
                    rotationAxis.copy(worldUp);
                    const rotationAngle = -0.05; // Negative for right turn
                    rotationQuaternion.setFromAxisAngle(rotationAxis, rotationAngle);
                    
                    // Apply to the camera object - this matches how PointerLockControls works
                    controls.getObject().quaternion.premultiply(rotationQuaternion);
                }
                break;
        }
    } catch (error) {
        debug(`KeyDown error: ${error.message}`, true);
    }
}

function onKeyUp(event) {
    try {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW':
                moveForward = false;
                break;
            case 'ArrowLeft':
            case 'KeyA':
                moveLeft = false;
                break;
            case 'ArrowDown':
            case 'KeyS':
                moveBackward = false;
                break;
            case 'ArrowRight':
            case 'KeyD':
                moveRight = false;
                break;
            case 'KeyQ':
                turnLeft = false;
                break;
            case 'KeyE':
                turnRight = false;
                break;
        }
    } catch (error) {
        debug(`KeyUp error: ${error.message}`, true);
    }
}

// Add static Numberblocks of various values
function addStaticNumberblocks() {
    debug('Adding static Numberblocks');
    
    try {
        // Define positions and values for static Numberblocks
        const numberblockData = [
            { value: 2, x: 8, z: 3 },
            { value: 3, x: -5, z: 8 },
            { value: 4, x: 15, z: -5 },
            { value: 5, x: -12, z: -8 },
            { value: 6, x: 5, z: -15 }
        ];
        
        // Create each Numberblock
        numberblockData.forEach(data => {
            try {
                const numberblock = new Numberblock(data.value);
                scene.add(numberblock.mesh);
                
                // Fix positioning: Set Y to half the value so bottom is at ground level (y=0)
                // For a block of value 5, the height is 5, so y=2.5 puts the bottom at ground level
                numberblock.mesh.position.set(data.x, data.value / 2, data.z);
                
                // Rotate randomly for variety
                numberblock.mesh.rotation.y = Math.random() * Math.PI * 2;
                
                // Add a small bounce animation
                const initialY = numberblock.mesh.position.y;
                const bounceSpeed = 0.5 + Math.random() * 0.5;
                const bounceHeight = 0.15;
                
                // Store animation data on the mesh for use in animate loop
                numberblock.mesh.userData = {
                    initialY: initialY,
                    bounceSpeed: bounceSpeed,
                    bounceHeight: bounceHeight,
                    bounceOffset: Math.random() * Math.PI * 2 // Random offset for varied motion
                };
            } catch (error) {
                debug(`Error creating static Numberblock: ${error.message}`, true);
            }
        });
        
        debug('Static Numberblocks added');
    } catch (error) {
        debug(`Error adding static Numberblocks: ${error.message}`, true);
    }
}

// Initialize the player's Numberblock
function initPlayerNumberblock() {
    debug('Creating player Numberblock');
    
    try {
        playerNumberblock = new Numberblock(playerValue);
        scene.add(playerNumberblock.mesh);
        playerNumberblock.mesh.position.set(0, 0, 0);
        debug('Player Numberblock created');
        
        // Make player Numberblock globally available for networking
        window.playerNumberblock = playerNumberblock;
        
        // Update HUD
        updateHUD();
        
        // Make Numberblock class available globally
        window.Numberblock = Numberblock;
    } catch (error) {
        debug(`Error creating player Numberblock: ${error.message}`, true);
    }
}

// Initialize networking for multiplayer
function initNetworkingSystem() {
    debug('Initializing networking system');
    
    try {
        // Check if initNetworking is defined in network.js
        if (typeof window.initNetworking === 'function') {
            debug('Found networking module, attempting to connect...');
            window.initNetworking()
                .then((roomInstance) => {
                    debug('Networking initialized successfully');
                    window.gameRoom = roomInstance; // Store room instance globally
                    
                    // Manually trigger player list update after successful connection
                    if (typeof window.updatePlayerListUI === 'function') {
                        setTimeout(window.updatePlayerListUI, 500);
                        setTimeout(window.updatePlayerListUI, 2000);
                    }
                })
                .catch(error => {
                    debug(`Networking error: ${error.message}`, true);
                });
        } else {
            debug('Networking module not detected, continuing in local mode');
        }
    } catch (error) {
        debug(`Error initializing networking: ${error.message}`, true);
    }
}

// Emergency render function - displays a simple scene if initialization fails
function emergencyRender() {
    debug('Attempting emergency render', true);
    
    try {
        // Create a very basic scene
        const emergencyScene = new THREE.Scene();
        emergencyScene.background = new THREE.Color(0x333333);
        
        const emergencyCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10);
        emergencyCamera.position.z = 2;
        
        const emergencyGeometry = new THREE.BoxGeometry(1, 1, 1);
        const emergencyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
        const emergencyCube = new THREE.Mesh(emergencyGeometry, emergencyMaterial);
        emergencyScene.add(emergencyCube);
        
        // Add text to indicate error
        const textDiv = document.createElement('div');
        textDiv.style.position = 'absolute';
        textDiv.style.top = '10px';
        textDiv.style.left = '10px';
        textDiv.style.color = 'white';
        textDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
        textDiv.style.padding = '10px';
        textDiv.style.fontFamily = 'monospace';
        textDiv.textContent = 'Initialization Error! Check console for details.';
        document.body.appendChild(textDiv);
        
        // Render the emergency scene
        renderer.render(emergencyScene, emergencyCamera);
        debug('Emergency render complete');
    } catch (error) {
        debug(`Emergency render failed: ${error.message}`, true);
        alert('Critical rendering error: ' + error.message);
    }
}

// Add decorative objects to the scene
function addDecorativeObjects() {
    try {
        debug('Adding decorative objects');
        
        // Add multiple trees scattered around
        for (let i = 0; i < 20; i++) {
            // Randomize positions but keep away from center
            const distance = 15 + Math.random() * 30;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            
            // Create tree
            createTree(x, 0, z);
        }
        
        // Add some rocks
        for (let i = 0; i < 15; i++) {
            // Randomize positions
            const distance = 10 + Math.random() * 40;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            
            // Create rock
            createRock(x, 0, z);
        }
        
        debug('Decorative objects added successfully');
    } catch (error) {
        debug(`Error adding decorative objects: ${error.message}`, true);
    }
}

// Helper function to create a tree
function createTree(x, y, z) {
    // Create tree trunk (cylinder)
    const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunk.position.set(x, y + 2.5, z);
    trunk.castShadow = true;
    trunk.receiveShadow = true;
    scene.add(trunk);
    
    // Create tree top (cone for evergreen tree)
    const topGeometry = new THREE.ConeGeometry(2, 6, 8);
    const topMaterial = new THREE.MeshStandardMaterial({ color: 0x228822 }); // Green
    const top = new THREE.Mesh(topGeometry, topMaterial);
    top.position.set(x, y + 6, z);
    top.castShadow = true;
    top.receiveShadow = true;
    scene.add(top);
}

// Helper function to create a rock
function createRock(x, y, z) {
    // Randomly scale the rock
    const scale = 0.5 + Math.random() * 1.5;
    
    // Create irregular rock shape using a scaled sphere
    const rockGeometry = new THREE.SphereGeometry(1, 6, 4);
    
    // Randomly deform vertices to make it look more like a rock
    const vertices = rockGeometry.attributes.position;
    for (let i = 0; i < vertices.count; i++) {
        const x = vertices.getX(i);
        const y = vertices.getY(i);
        const z = vertices.getZ(i);
        
        // Apply random offset to vertex
        vertices.setX(i, x + (Math.random() - 0.5) * 0.3);
        vertices.setY(i, y + (Math.random() - 0.5) * 0.3);
        vertices.setZ(i, z + (Math.random() - 0.5) * 0.3);
    }
    
    // Update normals after vertex modification
    rockGeometry.computeVertexNormals();
    
    // Create rock material with random gray shade
    const grayShade = 0.4 + Math.random() * 0.3;
    const rockMaterial = new THREE.MeshStandardMaterial({ 
        color: new THREE.Color(grayShade, grayShade, grayShade),
        roughness: 0.9,
        metalness: 0.1
    });
    
    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
    rock.scale.set(scale, scale * 0.7, scale);
    rock.position.set(x, y + (scale * 0.35), z);
    rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
    rock.castShadow = true;
    rock.receiveShadow = true;
    scene.add(rock);
}
 
 
===================================================== 
FILE: client\js\main.js 
===================================================== 
 
// Numberblocks game - Three.js implementation
console.log('Numberblocks game initializing...');

// Add debugging element to help track initialization
const debugElement = document.createElement('div');
debugElement.style.position = 'fixed';
debugElement.style.top = '10px';
debugElement.style.left = '10px';
debugElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
debugElement.style.color = 'white';
debugElement.style.padding = '10px';
debugElement.style.fontSize = '14px';
debugElement.style.fontFamily = 'monospace';
debugElement.style.zIndex = '1000';
debugElement.style.maxHeight = '80vh';
debugElement.style.overflowY = 'auto';
debugElement.innerHTML = 'Debug: Initializing...';
document.body.appendChild(debugElement);

function debug(message) {
    console.log(message);
    debugElement.innerHTML += '<br>' + message;
}

// Catch JS errors
window.onerror = function(message, source, lineno, colno, error) {
    debug(`ERROR: ${message} (${source}:${lineno})`);
    return false;
};

// Game variables
let scene, camera, renderer, controls;
let playerNumberblock, staticNumberblock;
let operatorManager;
let operatorDisplay;
let numberblocks = [];
let isNetworkInitialized = false;
let lastFrameTime = performance.now();
let clock = new THREE.Clock();
let prevTime = performance.now(); // Additional global variable for time tracking

// Movement keys state
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let turnLeft = false;
let turnRight = false;

// Player state
let canJump = true;
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();

// Network state
let room, client;
let remotePlayers = {};
let isNetworkMode = false; // Flag to track if we're in network mode

// Global variables
let ground;
let initializedCube = null; // Reference to our test cube
window.isFirstPerson = true; // Make isFirstPerson truly global by attaching to window

// Debug function with visual elements
function debug(message) {
    // Add to debug panel if available
    const debugPanel = document.getElementById('debug-panel');
    if (debugPanel) {
        const messageElement = document.createElement('div');
        messageElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        debugPanel.appendChild(messageElement);
        
        // Auto-scroll to bottom
        debugPanel.scrollTop = debugPanel.scrollHeight;
    }
    
    // Log to console
    console.log(`[DEBUG] ${message}`);
}

// Initialize the Three.js scene - with step-by-step rendering tests
async function init() {
    debug('Starting init()...');
    try {
        // Create a debug panel directly in the DOM if it doesn't exist
        if (!document.getElementById('debug-panel')) {
            const debugPanel = document.createElement('div');
            debugPanel.id = 'debug-panel';
            debugPanel.style.position = 'absolute';
            debugPanel.style.top = '10px';
            debugPanel.style.left = '10px';
            debugPanel.style.background = 'rgba(0,0,0,0.7)';
            debugPanel.style.color = 'white';
            debugPanel.style.padding = '10px';
            debugPanel.style.fontFamily = 'monospace';
            debugPanel.style.fontSize = '12px';
            debugPanel.style.maxHeight = '300px';
            debugPanel.style.maxWidth = '500px';
            debugPanel.style.overflow = 'auto';
            debugPanel.style.zIndex = '1000';
            document.body.appendChild(debugPanel);
        }
        
        // STEP 1: Create Scene
        debug('STEP 1: Creating scene...');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background
        
        // STEP 2: Create Camera
        debug('STEP 2: Creating camera...');
        camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 2, 5); // Set initial camera position
        
        // STEP 3: Get canvas and create renderer
        const canvas = document.getElementById('game-canvas');
        if (!canvas) {
            debug('ERROR: Canvas element not found! Creating a new one...');
            
            // Create canvas if not found
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'game-canvas';
            newCanvas.style.display = 'block';
            newCanvas.style.width = '100%';
            newCanvas.style.height = '100%';
            document.body.appendChild(newCanvas);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: newCanvas,
                antialias: true
            });
        } else {
            debug('Canvas found, creating renderer...');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true
            });
        }
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
        debug('Renderer created successfully');
        
        // TEST RENDER: Add a simple cube to ensure rendering works
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const testCube = new THREE.Mesh(geometry, material);
        testCube.position.set(0, 0, -5);
        scene.add(testCube);
        debug('Test cube added to scene');
        
        // Do a single test render
        renderer.render(scene, camera);
        debug('Test render completed');
        
        // STEP 4: Add lights
        debug('STEP 4: Creating lights...');
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);
        
        // Render after adding lights
        renderer.render(scene, camera);
        debug('Render after adding lights completed');
        
        // STEP 5: Create ground plane
        debug('STEP 5: Creating ground...');
        createGround();
        
        // Render after adding ground
        renderer.render(scene, camera);
        debug('Render after adding ground completed');
        
        // STEP 6: Create landscape elements
        debug('STEP 6: Creating landscape...');
        createLandscapeElements();
        
        // Render after adding landscape
        renderer.render(scene, camera);
        debug('Render after adding landscape completed');
        
        // STEP 7: Create player Numberblock
        debug('STEP 7: Creating player Numberblock...');
        playerNumberblock = createPlayerNumberblock(scene, 1);
        
        // Render after adding player Numberblock
        renderer.render(scene, camera);
        debug('Render after adding player Numberblock completed');
        
        // STEP 8: Initialize HUD
        debug('STEP 8: Initializing HUD...');
        updatePlayerDisplay(1);
        
        // STEP 9: Setup controls
        debug('STEP 9: Setting up controls...');
        window.addEventListener('resize', onWindowResize);
        onWindowResize(); // Ensure camera aspect ratio is correct
        
        // Standard FPS controls
        const initControlsResult = initControls(camera, renderer.domElement);
        
        // Verify controls were created correctly
        if (initControlsResult) {
            controls = initControlsResult;
            debug('Controls initialized successfully');
            
            // Set position on controls object (not camera directly)
            controls.getObject().position.set(0, 2, 5);
            scene.add(controls.getObject());
        } else {
            debug('WARNING: Controls initialization failed, using fallback');
            
            // Fallback controls
            controls = {
                getObject: () => camera,
                isLocked: false,
                lock: () => {},
                unlock: () => {}
            };
        }
        
        // Render after setting up controls
        renderer.render(scene, camera);
        debug('Render after setting up controls completed');
        
        // STEP 10: Initialize networking
        debug('STEP 10: Initializing networking...');
        try {
            isNetworkInitialized = await initNetworking();
            debug(`Networking initialized: ${isNetworkInitialized}`);
            
            if (!isNetworkInitialized) {
                debug("Falling back to local mode (no multiplayer)");
                staticNumberblock = createStaticNumberblock(2, { x: 0, z: -5 });
                debug("Static Numberblock created with value: 2");
                operatorManager = new OperatorManager(scene);
            } else {
                debug("Connected to server. Running in multiplayer mode.");
                document.getElementById('multiplayer-panel').style.display = 'block';
            }
        } catch (error) {
            debug(`Failed to initialize networking: ${error.message}`);
            isNetworkInitialized = false;
            
            // Fallback to local mode
            staticNumberblock = createStaticNumberblock(2, { x: 0, z: -5 });
            operatorManager = new OperatorManager(scene);
        }
        
        // Render after networking setup
        renderer.render(scene, camera);
        debug('Render after networking setup completed');
        
        // STEP 11: Create random Numberblocks (only in local mode)
        if (!isNetworkInitialized) {
            debug('STEP 11: Creating random Numberblocks...');
            createRandomNumberblocks();
            
            // Render after adding random Numberblocks
            renderer.render(scene, camera);
            debug('Render after adding random Numberblocks completed');
        }
        
        // STEP 12: Create HUD elements
        debug('STEP 12: Creating HUD elements...');
        createHUD();
        
        // Make camera global for operators
        window.camera = camera;
        
        // STEP 13: Start animation loop
        debug('STEP 13: Starting animation loop...');
        lastFrameTime = performance.now();
        animate();
        debug('Animation loop started');
    } catch (error) {
        debug(`CRITICAL INIT ERROR: ${error.message}`);
        console.error('Initialization error:', error);
        
        // Attempt emergency rendering of error state
        try {
            if (scene && camera && renderer) {
                // Create error cube to show something is working
                const errorGeometry = new THREE.BoxGeometry(2, 2, 2);
                const errorMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                const errorCube = new THREE.Mesh(errorGeometry, errorMaterial);
                errorCube.position.set(0, 0, -5);
                scene.add(errorCube);
                
                // Simple error animation loop
                function errorAnimate() {
                    requestAnimationFrame(errorAnimate);
                    errorCube.rotation.x += 0.01;
                    errorCube.rotation.y += 0.01;
                    renderer.render(scene, camera);
                }
                
                errorAnimate();
                debug('ERROR STATE: Running emergency rendering');
            }
        } catch (errorFallbackError) {
            debug(`Emergency rendering failed: ${errorFallbackError.message}`);
        }
    }
}

// Reset everything for a fresh start
window.addEventListener('load', () => {
    debug('Window loaded - starting initialization');
    init();
});

// Initialize ground and lights
function initGroundAndLights() {
    try {
        debug('Creating ground...');
        
        // Create a ground plane
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to be flat
        ground.position.y = -1;
        ground.receiveShadow = true;
        scene.add(ground);
        
        debug('Creating lights...');
        
        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        // Add directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        debug('Ground and lights created successfully');
        
        // After ground and lights, initialize landscape
        setTimeout(() => {
            initLandscape();
        }, 1000);
    } catch (error) {
        debug(`ERROR in initGroundAndLights: ${error.message}`);
        console.error('Ground and lights initialization error:', error);
    }
}

// Initialize landscape
function initLandscape() {
    try {
        debug('Creating landscape elements...');
        
        // Add some simple cubes as landscape elements
        for (let i = 0; i < 5; i++) {
            const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
            const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.set(
                Math.random() * 40 - 20,
                0,
                Math.random() * 40 - 20
            );
            scene.add(cube);
        }
        
        debug('Landscape created successfully');
        
        // Initialize the player Numberblock after landscape
        setTimeout(() => {
            initPlayerNumberblock();
        }, 1000);
    } catch (error) {
        debug(`ERROR in initLandscape: ${error.message}`);
        console.error('Landscape initialization error:', error);
    }
}

// Initialize player Numberblock
function initPlayerNumberblock() {
    try {
        debug('Creating player Numberblock...');
        
        // First, remove the test cube since we don't need it anymore
        if (initializedCube) {
            scene.remove(initializedCube);
            initializedCube = null;
        }
        
        // Initialize the player Numberblock
        playerNumberblock = new Numberblock(1);
        scene.add(playerNumberblock.mesh);
        
        debug('Player Numberblock created successfully');
        
        // After player Numberblock is created, initialize controls
        setTimeout(() => {
            initPlayerControls();
        }, 1000);
    } catch (error) {
        debug(`ERROR in initPlayerNumberblock: ${error.message}`);
        console.error('Player Numberblock initialization error:', error);
    }
}

// Initialize player controls
function initPlayerControls() {
    try {
        debug('Initializing controls...');
        
        // Try to use PointerLockControls
        try {
            controls = initControls(camera, document.body);
            debug('PointerLockControls initialized successfully');
        } catch (error) {
            debug(`ERROR initializing PointerLockControls: ${error.message}`);
            console.error('PointerLockControls initialization error:', error);
        }
        
        // Initialize HUD and game after controls are set up
        setTimeout(() => {
            initHUD();
        }, 1000);
    } catch (error) {
        debug(`ERROR in initPlayerControls: ${error.message}`);
        console.error('Player controls initialization error:', error);
    }
}

// Initialize HUD
function initHUD() {
    try {
        debug('Initializing HUD...');
        
        // Set up the HUD
        const hudElement = document.getElementById('game-hud');
        hudElement.innerHTML = `
            <div class="number-display">
                <span id="number-value">1</span>
            </div>
        `;
        
        debug('HUD initialized successfully');
        
        // Initialize game after HUD is set up
        setTimeout(() => {
            initGame();
        }, 1000);
    } catch (error) {
        debug(`ERROR in initHUD: ${error.message}`);
        console.error('HUD initialization error:', error);
    }
}

// Initialize the rest of the game
function initGame() {
    try {
        debug('Initializing game...');
        
        // Initialize operator manager
        operatorManager = new OperatorManager();
        
        // Set up event listeners
        window.addEventListener('resize', onWindowResize);
        
        // Call onWindowResize to ensure the aspect ratio is correct
        onWindowResize();
        
        debug('Game initialized successfully');
        
        // Finally, start networking
        setTimeout(() => {
            initializeNetworking();
        }, 1000);
    } catch (error) {
        debug(`ERROR in initGame: ${error.message}`);
        console.error('Game initialization error:', error);
    }
}

// Initialize networking
function initializeNetworking() {
    try {
        debug('Initializing networking...');
        
        // Check if network.js functions are available
        if (typeof initNetworking === 'function') {
            initNetworking()
                .then(() => {
                    debug('Networking initialized successfully');
                    isNetworkInitialized = true;
                })
                .catch(error => {
                    debug(`ERROR initializing networking: ${error.message}`);
                    console.error('Networking initialization error:', error);
                    debug('Continuing in local mode...');
                });
        } else {
            debug('Networking functions not available, continuing in local mode');
        }
        
        debug('Full initialization complete!');
        
        // Animation loop function (called by the test animation initially)
        function animate() {
            try {
                requestAnimationFrame(animate);
                
                const currentTime = performance.now();
                const deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
                lastFrameTime = currentTime;
                
                // Update controls if available
                if (controls) {
                    if (typeof controls.update === 'function') {
                        controls.update(deltaTime);
                    }
                }
                
                // Update player position based on controls
                if (playerNumberblock && playerNumberblock.mesh) {
                    // Update player position
                    updatePlayerPosition();
                    
                    // Check for collisions with operators
                    checkOperatorCollisions();
                    
                    // Check for collisions with other Numberblocks
                    checkNumberblockCollisions();
                }
                
                // Update operators (if they exist)
                if (operatorManager && typeof operatorManager.update === 'function') {
                    operatorManager.update(deltaTime);
                }
                
                // Rotate any rotating elements 
                if (numberblocks) {
                    for (let i = 0; i < numberblocks.length; i++) {
                        if (numberblocks[i] && numberblocks[i].mesh) {
                            // Small hover effect
                            numberblocks[i].mesh.position.y = Math.sin(currentTime * 0.001 + i) * 0.2 + 1;
                        }
                    }
                }
                
                // Render the scene
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            } catch (error) {
                debug(`Animation loop error: ${error.message}`);
                console.error('Animation error:', error);
            }
        }
        
        animate();
    } catch (error) {
        debug(`ERROR in initializeNetworking: ${error.message}`);
        console.error('Networking initialization error:', error);
    }
}

// Create the ground plane
function createGround() {
    // Create a large flat plane for the ground
    const groundGeometry = new THREE.BoxGeometry(200, 0.1, 200);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x7CFC00, // Lawn green color
        roughness: 0.8,
        metalness: 0.2
    });
    
    ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.05; // Move it slightly down to center it
    scene.add(ground);
}

// Create random landscape elements for perspective
function createLandscapeElements() {
    // Define bright colors that match Numberblocks aesthetic
    const colors = [
        0xFF0000, // Red (One)
        0xFFA500, // Orange (Two)
        0xFFFF00, // Yellow (Three)
        0x00FF00, // Green (Four)
        0x0000FF, // Blue (Five)
        0x800080, // Purple (Six)
        0xFFC0CB, // Pink (Seven)
        0xA52A2A, // Brown (Eight)
        0x808080  // Grey (Nine)
    ];
    
    // Create 120 random objects (increased from 30 for the larger world)
    for (let i = 0; i < 120; i++) {
        let geometry, material, mesh;
        const shapeType = Math.floor(Math.random() * 4); // 0-3 for different shapes
        const colorIndex = Math.floor(Math.random() * colors.length);
        const color = colors[colorIndex];
        
        // Create different shapes
        switch (shapeType) {
            case 0: // Cube (like Numberblock parts)
                const size = 0.5 + Math.random() * 1.5;
                geometry = new THREE.BoxGeometry(size, size, size);
                break;
            case 1: // Cylinder
                const radius = 0.3 + Math.random() * 1;
                const height = 1 + Math.random() * 3;
                geometry = new THREE.CylinderGeometry(radius, radius, height, 16);
                break;
            case 2: // Sphere
                const sphereRadius = 0.5 + Math.random() * 1;
                geometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
                break;
            case 3: // Cone
                const coneRadius = 0.5 + Math.random() * 1;
                const coneHeight = 1 + Math.random() * 2;
                geometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
                break;
        }
        
        // Create material with random color
        material = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        // Create and position the mesh
        mesh = new THREE.Mesh(geometry, material);
        
        // Position randomly on the ground plane (within a 180x180 area)
        // Keep away from center where player spawns
        let posX, posZ;
        do {
            posX = (Math.random() * 180) - 90;
            posZ = (Math.random() * 180) - 90;
        } while (Math.abs(posX) < 8 && Math.abs(posZ) < 8); // Increased spawn area protection
        
        mesh.position.set(posX, 0, posZ);
        
        // Add random rotation for more variety
        mesh.rotation.y = Math.random() * Math.PI * 2;
        
        // Add to scene
        scene.add(mesh);
    }
    
    // Add some trees as landmarks
    createTrees();
}

// Create simple trees as landmarks
function createTrees() {
    for (let i = 0; i < 40; i++) {
        // Create trunk
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 2, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513, // Brown
            roughness: 0.9
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        
        // Create foliage (as a cone)
        const foliageGeometry = new THREE.ConeGeometry(1.5, 3, 8);
        const foliageMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22, // Forest green
            roughness: 0.8
        });
        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
        foliage.position.y = 2.5; // Position on top of trunk
        
        // Create tree group
        const tree = new THREE.Group();
        tree.add(trunk);
        tree.add(foliage);
        
        // Position randomly on the ground plane but away from center
        let posX, posZ, distance;
        do {
            posX = (Math.random() * 180) - 90;
            posZ = (Math.random() * 180) - 90;
            distance = Math.sqrt(posX * posX + posZ * posZ);
        } while (distance < 10); // Keep trees away from spawn point
        
        tree.position.set(posX, 1, posZ); // Position with trunk base on ground
        
        // Add to scene
        scene.add(tree);
    }
}

// Create HUD elements
function createHUD() {
    // Player's number display
    const valueDisplay = document.createElement('div');
    valueDisplay.id = 'value-display';
    valueDisplay.style.position = 'absolute';
    valueDisplay.style.bottom = '20px';
    valueDisplay.style.left = '20px';
    valueDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    valueDisplay.style.color = 'white';
    valueDisplay.style.padding = '10px 20px';
    valueDisplay.style.borderRadius = '5px';
    valueDisplay.style.fontFamily = 'Arial, sans-serif';
    valueDisplay.style.fontSize = '24px';
    valueDisplay.style.fontWeight = 'bold';
    valueDisplay.innerHTML = 'Value: 1';
    document.body.appendChild(valueDisplay);

    // Operator display
    operatorDisplay = document.createElement('div');
    operatorDisplay.id = 'operator-display';
    operatorDisplay.style.position = 'absolute';
    operatorDisplay.style.bottom = '20px';
    operatorDisplay.style.right = '20px';
    operatorDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    operatorDisplay.style.color = 'white';
    operatorDisplay.style.padding = '10px 20px';
    operatorDisplay.style.borderRadius = '5px';
    operatorDisplay.style.fontFamily = 'Arial, sans-serif';
    operatorDisplay.style.fontSize = '24px';
    operatorDisplay.style.fontWeight = 'bold';
    operatorDisplay.innerHTML = 'Current Operator: None';
    document.body.appendChild(operatorDisplay);
    
    // View mode display
    const viewModeDisplay = document.createElement('div');
    viewModeDisplay.id = 'view-mode-display';
    viewModeDisplay.style.position = 'absolute';
    viewModeDisplay.style.top = '20px';
    viewModeDisplay.style.left = '50%';
    viewModeDisplay.style.transform = 'translateX(-50%)';
    viewModeDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    viewModeDisplay.style.color = 'white';
    viewModeDisplay.style.padding = '10px 20px';
    viewModeDisplay.style.borderRadius = '5px';
    viewModeDisplay.style.fontFamily = 'Arial, sans-serif';
    viewModeDisplay.style.fontSize = '20px';
    viewModeDisplay.style.fontWeight = 'bold';
    viewModeDisplay.style.transition = 'opacity 1s';
    viewModeDisplay.style.opacity = '0';
    viewModeDisplay.innerHTML = 'First Person View';
    document.body.appendChild(viewModeDisplay);
}

// Update the player's number display in the HUD
function updatePlayerDisplay(value) {
    const valueDisplay = document.getElementById('value-display');
    if (valueDisplay) {
        valueDisplay.innerHTML = `Value: ${value}`;
    }
}

// Update operator display
function updateOperatorDisplay(operatorType) {
    if (operatorDisplay) {
        if (operatorType) {
            operatorDisplay.innerHTML = operatorType === 'plus' ? '+ Add' : '- Subtract';
            operatorDisplay.style.color = operatorType === 'plus' ? '#00FF00' : '#FF0000';
        } else {
            operatorDisplay.innerHTML = 'Current Operator: None';
            operatorDisplay.style.color = 'white';
        }
    }
}

// Create random Numberblocks around the map
function createRandomNumberblocks() {
    const numBlocks = 15; // Create 15 random Numberblocks
    
    for (let i = 0; i < numBlocks; i++) {
        // Create a Numberblock with random value between 1 and 20
        const value = Math.floor(Math.random() * 20) + 1;
        const numberblock = new Numberblock(value);
        
        // Position randomly, away from player spawn
        let posX, posZ;
        do {
            posX = (Math.random() * 40) - 20;
            posZ = (Math.random() * 40) - 20;
        } while (
            Math.abs(posX) < 5 && 
            Math.abs(posZ) < 5
        );
        
        // Position the Numberblock with its base at ground level
        numberblock.mesh.position.set(posX, numberblock.blockSize / 2, posZ);
        scene.add(numberblock.mesh);
        numberblocks.push(numberblock);
        
        if (typeof addCollidableObject === 'function') {
            addCollidableObject(numberblock.mesh);
        }
    }
}

// Create a static Numberblock for testing
function createStaticNumberblock(value = 2, position = { x: 0, z: -5 }) {
    const numberblock = new Numberblock(value);
    numberblock.mesh.position.set(position.x, numberblock.blockSize / 2, position.z);
    scene.add(numberblock.mesh);
    return numberblock;
}

// Create random shapes for the landscape
function createRandomShapes() {
    const numShapes = 30;
    const shapes = [];
    
    for (let i = 0; i < numShapes; i++) {
        let geometry, mesh;
        const shapeType = Math.floor(Math.random() * 4); // 0: cube, 1: cylinder, 2: sphere, 3: cone
        
        // Create random shape
        switch (shapeType) {
            case 0: // Cube
                geometry = new THREE.BoxGeometry(1, 1, 1);
                break;
            case 1: // Cylinder
                geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
                break;
            case 2: // Sphere
                geometry = new THREE.SphereGeometry(0.5, 16, 16);
                break;
            case 3: // Cone
                geometry = new THREE.ConeGeometry(0.5, 1, 16);
                break;
        }
        
        // Create material with random color
        const material = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xFFFFFF,
            roughness: 0.7,
            metalness: 0.3
        });
        
        mesh = new THREE.Mesh(geometry, material);
        
        // Position randomly on the ground plane (within a 40x40 area)
        // Keep away from center where player spawns
        let posX, posZ;
        do {
            posX = (Math.random() * 40) - 20;
            posZ = (Math.random() * 40) - 20;
        } while (
            Math.abs(posX) < 5 && 
            Math.abs(posZ) < 5
        );
        
        // Calculate Y position based on the shape's height
        let posY;
        if (shapeType === 0) { // Cube
            posY = mesh.geometry.parameters.height / 2;
        } else if (shapeType === 1) { // Cylinder
            posY = mesh.geometry.parameters.height / 2;
        } else if (shapeType === 2) { // Sphere
            posY = mesh.geometry.parameters.radius;
        } else { // Cone
            posY = mesh.geometry.parameters.height / 2;
        }
        
        mesh.position.set(posX, posY, posZ);
        
        // Add random rotation for more variety
        mesh.rotation.y = Math.random() * Math.PI * 2;
        
        scene.add(mesh);
        shapes.push(mesh);
        
        // Make it collidable
        if (typeof addCollidableObject === 'function') {
            addCollidableObject(mesh);
        }
    }
    
    return shapes;
}

// Create player Numberblock and add it to the scene
function createPlayerNumberblock(scene, value = 1) {
    const playerBlock = new Numberblock(value);
    playerBlock.mesh.position.set(0, playerBlock.blockSize / 2, 0); // Start at origin, on ground
    scene.add(playerBlock.mesh);
    return playerBlock;
}

// Handle window resize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Animation loop
function animate() {
    try {
        requestAnimationFrame(animate);
        
        const currentTime = performance.now();
        const deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
        lastFrameTime = currentTime;
        
        // Update controls if available
        if (controls) {
            if (typeof controls.update === 'function') {
                controls.update(deltaTime);
            }
        }
        
        // Update player position based on controls
        if (playerNumberblock && playerNumberblock.mesh) {
            // Update player position
            updatePlayerPosition();
            
            // Check for collisions with operators
            checkOperatorCollisions();
            
            // Check for collisions with other Numberblocks
            checkNumberblockCollisions();
        }
        
        // Update operators (if they exist)
        if (operatorManager && typeof operatorManager.update === 'function') {
            operatorManager.update(deltaTime);
        }
        
        // Rotate any rotating elements 
        if (numberblocks) {
            for (let i = 0; i < numberblocks.length; i++) {
                if (numberblocks[i] && numberblocks[i].mesh) {
                    // Small hover effect
                    numberblocks[i].mesh.position.y = Math.sin(currentTime * 0.001 + i) * 0.2 + 1;
                }
            }
        }
        
        // Render the scene
        if (renderer && scene && camera) {
            renderer.render(scene, camera);
        }
    } catch (error) {
        debug(`Animation loop error: ${error.message}`);
        console.error('Animation error:', error);
    }
}

// Update player position and rotation based on controls - STANDARD FPS MECHANICS
function updatePlayerPosition() {
    try {
        if (!controls || !playerNumberblock) return;
        
        const time = performance.now();
        const delta = (time - prevTime) / 1000;
        
        // Handle movement with PointerLockControls
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize(); // Normalize for consistent speed
        
        // We need to consider the camera's facing direction for movement
        if (controls.isLocked) {
            // Move in the direction the camera is facing
            const moveSpeed = 5.0; // Units per second
            
            if (moveForward || moveBackward) {
                controls.moveForward(direction.z * moveSpeed * delta);
            }
            
            if (moveLeft || moveRight) {
                controls.moveRight(direction.x * moveSpeed * delta);
            }
        }
        
        // Update Numberblock position to match controls
        if (playerNumberblock && playerNumberblock.mesh) {
            playerNumberblock.mesh.position.copy(controls.getObject().position);
            playerNumberblock.mesh.rotation.y = controls.getObject().rotation.y;
        }
        
        prevTime = time;
        
        // Send position to server if networking is initialized
        if (isNetworkInitialized && typeof sendPlayerUpdate === 'function') {
            const position = controls.getObject().position;
            const rotation = controls.getObject().rotation.y;
            const pitch = camera.rotation.x;
            
            sendPlayerUpdate(position, rotation, pitch, playerNumberblock.value);
        }
    } catch (error) {
        debug(`Error in updatePlayerPosition: ${error.message}`);
    }
}

// Update player position in third-person mode
function updatePlayerPositionThirdPerson(delta) {
    try {
        if (!playerNumberblock || !controls) return;

        const moveSpeed = 5.0; // Movement speed
        const rotationSpeed = 2.0; // Rotation speed for Q/E keys

        // Get camera's current direction vectors
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).setY(0).normalize();
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion).setY(0).normalize();

        // Calculate desired movement direction from keyboard input
        const movement = new THREE.Vector3();
        if (moveForward) movement.add(forward);
        if (moveBackward) movement.sub(forward);
        if (moveLeft) movement.sub(right);
        if (moveRight) movement.add(right);

        movement.normalize().multiplyScalar(moveSpeed * delta);

        // Update player position
        playerNumberblock.mesh.position.add(movement);

        // Rotate player using Q/E keys
        if (turnLeft) playerNumberblock.mesh.rotation.y += rotationSpeed * delta;
        if (turnRight) playerNumberblock.mesh.rotation.y -= rotationSpeed * delta;

        // Rotate player to face movement direction if moving (and no manual rotation with Q/E)
        if (movement.lengthSq() > 0.0001 && !turnLeft && !turnRight) {
            const targetAngle = Math.atan2(movement.x, movement.z);
            playerNumberblock.mesh.rotation.y = targetAngle;
        }
    } catch (error) {
        debug(`Error in updatePlayerPositionThirdPerson: ${error.message}`);
    }
}

// Update camera position in third-person mode
function updateThirdPersonCamera() {
    try {
        if (!playerNumberblock || !playerNumberblock.mesh) return;

        const distance = 12;      // Camera distance behind the player
        const heightOffset = 8;   // Height offset above the player
        const smoothing = 0.1;    // Smooth camera motion factor
        const rotationSpeed = 0.05;

        // Initialize the angle if not set
        if (typeof window.thirdPersonCameraAngle === 'undefined') {
            window.thirdPersonCameraAngle = playerNumberblock.mesh.rotation.y + Math.PI;
        }

        // Adjust camera angle with Q/E keys
        if (turnLeft) window.thirdPersonCameraAngle += rotationSpeed;
        if (turnRight) window.thirdPersonCameraAngle -= rotationSpeed;

        // Calculate desired camera position explicitly without cumulative interpolation errors
        const playerPos = playerNumberblock.mesh.position.clone();
        const targetX = playerPos.x - Math.sin(window.thirdPersonCameraAngle) * distance;
        const targetZ = playerPos.z - Math.cos(window.thirdPersonCameraAngle) * distance;
        
        // Ensure camera Y position is always exactly at height offset plus player's midpoint height
        const targetY = playerNumberblock.mesh.position.y + heightOffset;

        // Set camera position explicitly without smoothing vertically to prevent drift
        camera.position.set(
            THREE.MathUtils.lerp(camera.position.x, targetX, 0.1),
            targetY, // No vertical smoothing
            THREE.MathUtils.lerp(camera.position.z, targetZ, 0.1)
        );

        // Always look at the player's midpoint height directly
        const lookAtY = playerNumberblock.mesh.position.y + playerNumberblock.getHeight() / 2;
        camera.lookAt(playerNumberblock.mesh.position.x, targetY - (heightOffset / 2), playerNumberblock.mesh.position.z);
    } catch (error) {
        debug(`Error in updateThirdPersonCamera: ${error.message}`);
    }
}

// Switch to third-person view
function switchToThirdPersonView() {
    // Make sure the camera is only in one place at a time
    if (camera.parent === controls.getObject()) {
        // If camera is attached to controls, remove it first
        controls.getObject().remove(camera);
    }
    
    // Only add to scene if it's not already there
    if (camera.parent !== scene) {
        scene.add(camera);
    }
    
    // Reset camera's up vector to ensure correct orientation
    camera.up.set(0, 1, 0);
    
    // Initialize third-person camera angle based on current player rotation
    // Use + Math.PI to position camera behind player
    window.thirdPersonCameraAngle = playerNumberblock.mesh.rotation.y + Math.PI;
    
    // Set initial camera position immediately to avoid gradual transition
    const playerPos = playerNumberblock.mesh.position.clone();
    const distance = 12;
    const height = 8;
    
    camera.position.set(
        playerPos.x - Math.sin(window.thirdPersonCameraAngle) * distance,
        playerPos.y + height,
        playerPos.z - Math.cos(window.thirdPersonCameraAngle) * distance
    );
    
    // Look at player immediately
    const targetY = playerPos.y + playerNumberblock.getHeight() / 2;
    camera.lookAt(playerPos.x, targetY, playerPos.z);
    
    // Setup mouse controls for third-person camera rotation
    if (!window.thirdPersonMouseHandler) {
        window.thirdPersonMouseHandler = function(event) {
            // Skip processing extremely small movements to prevent drift
            if (Math.abs(event.movementX) > 0.5) {
                window.thirdPersonCameraAngle -= event.movementX * 0.002;
            }
        };
    }
    
    // Activate third-person mouse controls using the pointer lock events
    document.addEventListener('mousemove', window.thirdPersonMouseHandler);
    window.thirdPersonMouseControlsActive = true;
    
    // Make sure pointer is locked
    if (!controls.isLocked) {
        controls.lock();
    }
}

// Check for collisions between player's Numberblock and operators
function checkOperatorCollisions() {
    try {
        if (!playerNumberblock || !operatorManager) return;
        
        const playerBox = updateAABB(playerNumberblock.mesh);
        
        for (let i = 0; i < operatorManager.operators.length; i++) {
            const operator = operatorManager.operators[i];
            const operatorBox = updateAABB(operator.mesh);
            
            if (checkCollision(playerBox, operatorBox)) {
                // Apply operator effect
                const newValue = playerNumberblock.value + (operator.type === '+' ? 1 : -1);
                if (newValue > 0) {
                    playerNumberblock.updateValue(newValue);
                    updatePlayerDisplay(newValue);
                }
                
                operatorManager.removeOperator(i);
                break;
            }
        }
    } catch (error) {
        debug(`Error in checkOperatorCollisions: ${error.message}`);
    }
}

// Check for collisions between player and other numberblocks
function checkNumberblockCollisions() {
    try {
        if (!playerNumberblock || numberblocks.length === 0) return;
        
        const playerBox = updateAABB(playerNumberblock.mesh);
        
        for (let i = 0; i < numberblocks.length; i++) {
            const numberblock = numberblocks[i];
            
            // Skip if already collected
            if (numberblock.collected) continue;
            
            const numberblockBox = updateAABB(numberblock.mesh);
            
            if (checkCollision(playerBox, numberblockBox)) {
                // Combine the numbers
                const newValue = playerNumberblock.value + numberblock.value;
                playerNumberblock.updateValue(newValue);
                updatePlayerDisplay(newValue);
                
                // Remove the numberblock that was collided with
                scene.remove(numberblock.mesh);
                numberblocks.splice(i, 1);
                break;
            }
        }
    } catch (error) {
        debug(`Error in checkNumberblockCollisions: ${error.message}`);
    }
}

// Handle collision with a Numberblock
function handleNumberblockCollision(hitNumberblock) {
    // Only apply operation if we have an operator
    const operatorType = operatorManager.getHeldOperator();
    if (operatorType) {
        const oldValue = playerNumberblock.value;
        let newValue;
        
        if (operatorType === 'plus') {
            newValue = oldValue + hitNumberblock.value;
        } else {
            newValue = oldValue - hitNumberblock.value;
        }
        
        // Ensure value stays positive
        newValue = Math.max(1, newValue);
        
        // Update player's Numberblock
        playerNumberblock.setValue(newValue);
        updatePlayerDisplay(newValue);
        
        // Clear the held operator
        operatorManager.clearHeldOperator();
        updateOperatorDisplay(null);
        
        // Update camera position for new height
        updateCameraForNumberblockChange();
        
        debug(`Applied ${operatorType} operation: ${oldValue} ${operatorType === 'plus' ? '+' : '-'} ${hitNumberblock.value} = ${newValue}`);
    }
}

// Update camera position after Numberblock changes size
function updateCameraForNumberblockChange() {
    if (controls && playerNumberblock) {
        const controlsObject = controls.getObject();
        const numberblockHeight = playerNumberblock.getHeight();
        
        // Calculate new appropriate camera height
        const verticalOffset = Math.max(1.5, numberblockHeight * 0.6);
        const desiredCameraHeight = playerNumberblock.mesh.position.y + verticalOffset;
        
        // Set camera to new height
        controlsObject.position.y = desiredCameraHeight;
        
        // Ensure camera doesn't go below minimum height
        const minCameraHeight = 1.0;
        if (controlsObject.position.y < minCameraHeight) {
            controlsObject.position.y = minCameraHeight;
        }
    }
}

// Add view toggle with V key
document.addEventListener('keydown', (event) => {
    if (event.code === 'KeyV') {
        window.isFirstPerson = !window.isFirstPerson;

        const controlsInfo = document.getElementById('controls-info');
        if (controlsInfo) controlsInfo.style.display = 'none'; // Always hide in both modes

        if (window.isFirstPerson) {
            // Switch to first-person view
            
            // Remove any third-person mouse control listeners if they exist
            if (window.thirdPersonMouseControlsActive) {
                document.removeEventListener('mousemove', window.thirdPersonMouseHandler);
                window.thirdPersonMouseControlsActive = false;
            }
            
            // Make sure the camera is only in one place at a time
            // Check if camera is already part of controls before adding it
            if (camera.parent === scene) {
                scene.remove(camera);
                
                // Reset camera and attach to controls
                // IMPORTANT: Only add the camera if it's not already a child
                if (!controls.getObject().children.includes(camera)) {
                    controls.getObject().add(camera);
                    camera.position.set(0, 0, 0);
                    camera.rotation.set(0, 0, 0);
                }
            }
            
            // Position controls at Numberblock's head position
            controls.getObject().position.copy(playerNumberblock.mesh.position);
            controls.getObject().position.y += playerNumberblock.getHeight() / 2;
            
            // Set rotation to match Numberblock exactly
            controls.getObject().rotation.y = playerNumberblock.mesh.rotation.y;
            
            // Make sure pointer is locked
            if (!controls.isLocked) {
                controls.lock();
            }
        } else {
            // Use dedicated function for switching to third-person
            switchToThirdPersonView();
        }

        camera.updateProjectionMatrix();

        // Update HUD view mode display
        const viewModeDisplay = document.getElementById('view-mode-display');
        if (viewModeDisplay) {
            viewModeDisplay.textContent = window.isFirstPerson ? 'First Person View' : 'Third Person View';
            viewModeDisplay.style.opacity = '1';
            setTimeout(() => viewModeDisplay.style.opacity = '0', 2000);
        }
    }
});

// Initialize the scene when the page loads
document.addEventListener('DOMContentLoaded', () => {
    debug('Page loaded - starting initialization');
});

// Create the ground plane for the game environment
function createGround() {
    try {
        debug('Creating ground plane...');
        
        // Create a ground plane
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to be flat
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);
        debug('Ground created successfully');
    } catch (error) {
        debug(`Error creating ground: ${error.message}`);
    }
}

// Create landscape elements for the game environment
function createLandscapeElements() {
    try {
        debug('Creating landscape elements...');
        
        // Add some random cubes as landscape elements
        for (let i = 0; i < 20; i++) {
            const size = Math.random() * 3 + 1;
            const cubeGeometry = new THREE.BoxGeometry(size, size, size);
            const cubeMaterial = new THREE.MeshStandardMaterial({ 
                color: Math.random() * 0xffffff 
            });
            
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.set(
                Math.random() * 80 - 40,
                size / 2 - 0.5,
                Math.random() * 80 - 40
            );
            
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);
        }
        
        debug('Landscape elements created successfully');
    } catch (error) {
        debug(`Error creating landscape elements: ${error.message}`);
    }
}

// Create the player's Numberblock character
function createPlayerNumberblock(scene, value) {
    try {
        debug(`Creating player Numberblock with value ${value}...`);
        
        const playerNumberblock = new Numberblock(value);
        scene.add(playerNumberblock.mesh);
        
        debug('Player Numberblock created successfully');
        return playerNumberblock;
    } catch (error) {
        debug(`Error creating player Numberblock: ${error.message}`);
        return null;
    }
}

// Create a static Numberblock for interaction
function createStaticNumberblock(value, position) {
    try {
        debug(`Creating static Numberblock with value ${value}...`);
        
        const staticNumberblock = new Numberblock(value);
        staticNumberblock.mesh.position.set(position.x, 0, position.z);
        scene.add(staticNumberblock.mesh);
        
        debug('Static Numberblock created successfully');
        return staticNumberblock;
    } catch (error) {
        debug(`Error creating static Numberblock: ${error.message}`);
        return null;
    }
}

// Create random Numberblocks in the game environment
function createRandomNumberblocks() {
    try {
        debug('Creating random Numberblocks...');
        
        // Add some random Numberblocks around the level
        for (let i = 0; i < 5; i++) {
            const value = Math.floor(Math.random() * 5) + 1;
            const xPos = Math.random() * 80 - 40;
            const zPos = Math.random() * 80 - 40;
            
            const randomNumberblock = new Numberblock(value);
            randomNumberblock.mesh.position.set(xPos, 0, zPos);
            
            scene.add(randomNumberblock.mesh);
            numberblocks.push(randomNumberblock);
        }
        
        debug('Random Numberblocks created successfully');
    } catch (error) {
        debug(`Error creating random Numberblocks: ${error.message}`);
    }
}

// Create HUD elements for player information
function createHUD() {
    try {
        debug('Creating HUD elements...');
        
        // Set up the operator display for showing collected operators
        operatorDisplay = document.getElementById('game-hud');
        operatorDisplay.innerHTML = `
            <div class="number-display">
                <span id="number-value">1</span>
            </div>
        `;
        
        debug('HUD elements created successfully');
    } catch (error) {
        debug(`Error creating HUD: ${error.message}`);
    }
}

// Handle Numberblock collision by combining numbers
function handleNumberblockCollision(otherNumberblock) {
    try {
        debug(`Handling collision with Numberblock value ${otherNumberblock.value}`);
        
        // Add the values
        const newValue = playerNumberblock.value + otherNumberblock.value;
        
        // Update player's Numberblock
        playerNumberblock.updateValue(newValue);
        
        // Update the HUD
        updatePlayerDisplay(newValue);
        
        debug(`Player Numberblock updated to value ${newValue}`);
    } catch (error) {
        debug(`Error handling Numberblock collision: ${error.message}`);
    }
}

// Update the HUD display with the player's current number value
function updatePlayerDisplay(value) {
    try {
        debug(`Updating player display to value ${value}`);
        
        const valueDisplay = document.getElementById('number-value');
        if (valueDisplay) {
            valueDisplay.textContent = value;
        }
        
        // Show the current operator if available
        const operatorDisplay = document.getElementById('operator-display');
        if (operatorDisplay) {
            operatorDisplay.style.display = 'block';
        }
    } catch (error) {
        debug(`Error updating player display: ${error.message}`);
    }
}

// Update the camera position for Numberblock height changes
function updateCameraForNumberblockChange() {
    try {
        if (!playerNumberblock || !controls) return;
        
        const height = playerNumberblock.getHeight();
        debug(`Updating camera for Numberblock height ${height}`);
        
        // In first-person mode, adjust the camera height
        if (window.isFirstPerson) {
            const playerHeight = Math.max(2, height);
            const controlsObject = controls.getObject();
            controlsObject.position.y = playerHeight;
        }
    } catch (error) {
        debug(`Error updating camera for Numberblock: ${error.message}`);
    }
}

// Initialize first-person controls
function initControls(camera, domElement) {
    try {
        debug('Initializing PointerLockControls...');
        
        // Create PointerLockControls
        const controls = new THREE.PointerLockControls(camera, domElement);
        
        // Add event listeners for pointer lock changes
        document.addEventListener('pointerlockchange', function() {
            if (document.pointerLockElement === domElement) {
                debug('Pointer Lock enabled');
                controls.enabled = true;
                if (lockInstructions) lockInstructions.style.display = 'none';
            } else {
                debug('Pointer Lock disabled');
                controls.enabled = false;
                if (lockInstructions) lockInstructions.style.display = 'block';
            }
        });
        
        controls.addEventListener('lock', function() {
            debug('Controls locked');
            document.getElementById('lock-instructions').style.display = 'none';
        });
        
        controls.addEventListener('unlock', function() {
            debug('Controls unlocked');
            document.getElementById('lock-instructions').style.display = 'block';
        });
        
        // Setup key controls for movement
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        
        debug('PointerLockControls initialized successfully');
        return controls;
    } catch (error) {
        debug(`ERROR initializing controls: ${error.message}`);
        console.error('Controls initialization error:', error);
        
        // Return dummy controls to prevent crashes
        return {
            getObject: () => camera,
            isLocked: false,
            lock: () => {},
            unlock: () => {}
        };
    }
}

// Handle keydown events for movement
function onKeyDown(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = true;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = true;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = true;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            moveRight = true;
            break;
            
        case 'KeyQ':
            turnLeft = true;
            break;
            
        case 'KeyE':
            turnRight = true;
            break;
            
        case 'Space':
            if (canJump) {
                velocity.y += 350;
                canJump = false;
            }
            break;
            
        case 'KeyV':
            toggleViewMode();
            break;
    }
}

// Handle keyup events for movement
function onKeyUp(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = false;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = false;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = false;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            moveRight = false;
            break;
            
        case 'KeyQ':
            turnLeft = false;
            break;
            
        case 'KeyE':
            turnRight = false;
            break;
    }
}

```
```javascript
// Numberblocks game - Main game logic

// Debug support
const DEBUG = true;
const debugPanel = document.getElementById('debug-panel');

function debug(message, isError = false) {
    if (!DEBUG) return;
    
    console.log(`[DEBUG] ${message}`);
    
    if (debugPanel) {
        const messageElement = document.createElement('div');
        messageElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        if (isError) {
            messageElement.style.color = '#ff5555';
            console.error(`[ERROR] ${message}`);
        }
        debugPanel.appendChild(messageElement);
        debugPanel.scrollTop = debugPanel.scrollHeight;
    }
}

// Game variables
let camera, scene, renderer;
let controls;
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let canJump = false;
let prevTime = performance.now();
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let playerNumberblock;
let operators = [];
let playerValue = 1;
let lockInstructions = document.getElementById('lock-instructions');

// HUD elements
const gameHUD = document.getElementById('game-hud');

// Initialize the game
window.onload = function() {
    debug('Window loaded, initializing game...');
    init();
};

// Main initialization function
function init() {
    try {
        debug('Starting initialization...');
        
        // Create the scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        debug('Scene created');
        
        // Create the camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);
        debug('Camera created');
        
        // Create the renderer
        renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('game-canvas'),
            antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        debug('Renderer created');
        
        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);
        debug('Lights added');
        
        // Create a test cube to verify rendering
        const testCube = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshStandardMaterial({ color: 0xff0000 })
        );
        testCube.position.set(0, 0, -5);
        scene.add(testCube);
        debug('Test cube created');
        
        // Render the test cube to verify rendering
        renderer.render(scene, camera);
        debug('Initial render completed');
        
        // Setup Pointer Lock Controls
        setupPointerLockControls();
        
        // Initialize floor
        initFloor();
        
        // Initialize player Numberblock
        initPlayerNumberblock();
        
        // Initialize networking
        initNetworking();
        
        // Start the animation loop
        debug('Starting animation loop');
        animate();
        
        window.addEventListener('resize', onWindowResize);
    } catch (error) {
        debug(`Initialization error: ${error.message}`, true);
        console.error(error);
        emergencyRender();
    }
}

// Setup Pointer Lock Controls
function setupPointerLockControls() {
    debug('Setting up PointerLock controls');
    
    try {
        controls = new THREE.PointerLockControls(camera, document.body);
        
        const onPointerLockChange = function() {
            if (document.pointerLockElement === document.body) {
                debug('Pointer Lock enabled');
                controls.enabled = true;
                if (lockInstructions) lockInstructions.style.display = 'none';
            } else {
                debug('Pointer Lock disabled');
                controls.enabled = false;
                if (lockInstructions) lockInstructions.style.display = 'block';
            }
        };
        
        document.addEventListener('pointerlockchange', onPointerLockChange);
        
        // Click to enable controls
        document.body.addEventListener('click', function() {
            if (!controls.enabled) {
                debug('Requesting pointer lock');
                document.body.requestPointerLock();
            }
        });
        
        // Setup keyboard controls
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        debug('PointerLock controls setup complete');
    } catch (error) {
        debug(`Error setting up controls: ${error.message}`, true);
    }
}

// Function to create the floor
function initFloor() {
    debug('Creating floor');
    
    try {
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        floor.position.y = -0.5; // Position below the player
        scene.add(floor);
        debug('Floor created');
    } catch (error) {
        debug(`Error creating floor: ${error.message}`, true);
    }
}

// Initialize the player's Numberblock
function initPlayerNumberblock() {
    debug('Creating player Numberblock');
    
    try {
        playerNumberblock = new Numberblock(1);
        scene.add(playerNumberblock.mesh);
        debug('Player Numberblock created');
    } catch (error) {
        debug(`Error creating player Numberblock: ${error.message}`, true);
    }
}

// Initialize networking
function initNetworking() {
    debug('Initializing networking');
    
    try {
        // Check if network.js functions are available
        if (typeof initNetworking === 'function') {
            initNetworking()
                .then(() => {
                    debug('Networking initialized successfully');
                })
                .catch(error => {
                    debug(`ERROR initializing networking: ${error.message}`, true);
                    console.error('Networking initialization error:', error);
                    debug('Continuing in local mode...');
                });
        } else {
            debug('Networking functions not available, continuing in local mode');
        }
    } catch (error) {
        debug(`Error initializing networking: ${error.message}`, true);
    }
}

// Emergency render function - displays a simple scene if initialization fails
function emergencyRender() {
    debug('Attempting emergency render', true);
    
    try {
        // Create a very basic scene
        const emergencyScene = new THREE.Scene();
        emergencyScene.background = new THREE.Color(0x333333);
        
        const emergencyCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10);
        emergencyCamera.position.z = 2;
        
        const emergencyGeometry = new THREE.BoxGeometry(1, 1, 1);
        const emergencyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
        const emergencyCube = new THREE.Mesh(emergencyGeometry, emergencyMaterial);
        emergencyScene.add(emergencyCube);
        
        // Add text to indicate error
        const textDiv = document.createElement('div');
        textDiv.style.position = 'absolute';
        textDiv.style.top = '10px';
        textDiv.style.left = '10px';
        textDiv.style.color = 'white';
        textDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
        textDiv.style.padding = '10px';
        textDiv.style.fontFamily = 'monospace';
        textDiv.textContent = 'Initialization Error! Check console for details.';
        document.body.appendChild(textDiv);
        
        // Render the emergency scene
        renderer.render(emergencyScene, emergencyCamera);
        debug('Emergency render complete');
    } catch (error) {
        debug(`Emergency render failed: ${error.message}`, true);
    }
}

// Handle window resize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Handle keyboard input
function onKeyDown(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = true;
            break;
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = true;
            break;
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = true;
            break;
        case 'ArrowRight':
        case 'KeyD':
            moveRight = true;
            break;
        case 'Space':
            if (canJump) {
                velocity.y = 10;
                canJump = false;
            }
            break;
        case 'KeyQ':
            // Turn left
            camera.rotation.y += 0.05;
            break;
        case 'KeyE':
            // Turn right
            camera.rotation.y -= 0.05;
            break;
    }
}

function onKeyUp(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = false;
            break;
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = false;
            break;
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = false;
            break;
        case 'ArrowRight':
        case 'KeyD':
            moveRight = false;
            break;
    }
}

// Animation loop
function animate() {
    try {
        requestAnimationFrame(animate);
        
        // Update player position and handle controls
        if (controls && controls.enabled) {
            updatePlayerPosition();
        }
        
        // Rotate all operators to face the player
        updateOperators();
        
        // Render the scene
        renderer.render(scene, camera);
    } catch (error) {
        debug(`Animation error: ${error.message}`, true);
    }
}

// Update player position based on controls
function updatePlayerPosition() {
    const time = performance.now();
    
    if (prevTime === undefined) {
        prevTime = time;
    }
    
    const delta = (time - prevTime) / 1000;
    
    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;
    
    velocity.y -= 9.8 * 100.0 * delta; // Apply gravity
    
    direction.z = Number(moveForward) - Number(moveBackward);
    direction.x = Number(moveRight) - Number(moveLeft);
    direction.normalize(); // Ensure consistent movement regardless of direction
    
    if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
    if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;
    
    controls.moveRight(-velocity.x * delta);
    controls.moveForward(-velocity.z * delta);
    
    // Update position of player's Numberblock to follow the camera
    if (playerNumberblock) {
        playerNumberblock.mesh.position.copy(camera.position);
        playerNumberblock.mesh.position.y -= 1.5; // Position below the camera view
        
        // Look in same direction as camera
        playerNumberblock.mesh.rotation.y = controls.getObject().rotation.y;
    }
    
    // Send position to server for multiplayer
    if (room) {
        room.send("updatePosition", {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z,
            rotation: camera.rotation.y
        });
    }
    
    prevTime = time;
}

// Initialize networking for multiplayer
function initNetworking() {
    debug('Initializing networking');
    
    try {
        // Check if network.js functions are available
        if (typeof initNetworking === 'function') {
            initNetworking()
                .then(() => {
                    debug('Networking initialized successfully');
                })
                .catch(error => {
                    debug(`ERROR initializing networking: ${error.message}`, true);
                    console.error('Networking initialization error:', error);
                    debug('Continuing in local mode...');
                });
        } else {
            debug('Networking functions not available, continuing in local mode');
        }
    } catch (error) {
        debug(`Error initializing networking: ${error.message}`, true);
    }
}

// Update and rotate all operators to face the player
function updateOperators() {
    // TO DO: Implement operator rotation
}

// Update player's Numberblock value
function updatePlayerValue() {
    // TO DO: Implement player value update
}
 
 
===================================================== 
FILE: client\js\network.js 
===================================================== 
 
// Network configuration
const endpoint = 'ws://localhost:3000';
let client = null;
let room = null;

// Helper function to generate random colors
function getRandomColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

// Import CSS2D renderer for player names if not already defined
let CSS2DObject;
try {
    // Check for THREE.CSS2DObject
    if (typeof THREE !== 'undefined') {
        if (THREE.CSS2DObject) {
            console.log("Using THREE.CSS2DObject directly");
            CSS2DObject = THREE.CSS2DObject;
        } 
        // Check if it's in CSS2DRenderer
        else if (THREE.CSS2DRenderer) {
            console.log("Using THREE.CSS2DRenderer.CSS2DObject");
            CSS2DObject = THREE.CSS2DRenderer.CSS2DObject;
        }
        // Try loading from CSS2D namespace if available
        else if (THREE.CSS2D && THREE.CSS2D.CSS2DObject) {
            console.log("Using THREE.CSS2D.CSS2DObject");
            CSS2DObject = THREE.CSS2D.CSS2DObject;
        }
        // Last resort - look for it in the window object
        else if (window.CSS2DObject) {
            console.log("Using window.CSS2DObject");
            CSS2DObject = window.CSS2DObject;
        }
        else {
            throw new Error("CSS2DObject not found in THREE");
        }
    } else {
        throw new Error("THREE is not defined");
    }
} catch (error) {
    console.warn("CSS2DObject not available, player name labels will not be shown:", error.message);
    // Simple fallback that does nothing
    CSS2DObject = class DummyCSS2DObject {
        constructor(element) {
            this.element = element;
            this.position = { set: () => {} };
        }
    };
}

// Global tracking of all visuals
const visuals = {
    players: {},
    operators: {},
    staticNumberblocks: {}
};

// Store references to UI elements for players
let playerListElement = null;
let playerListToggleButton = null;
const playerListUiElements = {};
let playerListVisible = true;

// Global reference to other players' Numberblock visuals
window.otherPlayers = {};

// Make sure UI references are available after DOM loads
document.addEventListener('DOMContentLoaded', () => {
    playerListElement = document.getElementById('player-list');
    playerListToggleButton = document.getElementById('player-list-header');
    
    // Set up player list toggle via click
    if (playerListToggleButton) {
        playerListToggleButton.addEventListener('click', togglePlayerList);
    }
});

// Function to get color based on Numberblock value
function getColorForValue(value) {
    const colors = [
        "#FF0000", // Red (1)
        "#FFA500", // Orange (2)
        "#FFFF00", // Yellow (3)
        "#008000", // Green (4)
        "#0000FF", // Blue (5)
        "#800080", // Purple (6)
        "#FFC0CB", // Pink (7)
        "#A52A2A", // Brown (8)
        "#808080", // Grey (9)
        "#FFFFFF"  // White (10+)
    ];
    
    if (value <= 0) return "#CCCCCC"; // Default for invalid values
    if (value > colors.length) return colors[colors.length - 1]; // Use the last color for large values
    return colors[value - 1]; // Arrays are 0-indexed, but our values start at 1
}

// Function to initialize networking for multiplayer
async function initNetworking() {
    try {
        console.log(`Initializing networking with endpoint: ${endpoint}`);
        client = new Colyseus.Client(endpoint);
        
        // Generate random player name and color
        const playerId = Math.random().toString(36).substring(2, 8).toUpperCase();
        console.log("Attempting to join room with ID:", playerId);
        
        // Join the room
        room = await client.joinOrCreate("numberblocks", { 
            name: playerId,
            color: getRandomColor()
        });
        console.log(`Connected to server with session ID: ${room.sessionId}`);
        
        // Set player name in UI
        const playerName = document.getElementById('player-name');
        if (playerName) {
            playerName.textContent = playerId;
        }
        
        // Wait a brief moment to ensure schemas are initialized
        setTimeout(() => {
            // Setup room listeners for all object types
            setupRoomListeners();
            
            // Process existing players
            processExistingPlayers();
        }, 500);
        
        return room;
    } catch (error) {
        console.error(`Error connecting to Colyseus server: ${error}`);
        // Don't throw, just log the error and continue - allows game to work in offline mode
        console.log("Continuing in offline mode");
        return null;
    }
}

// Process players that already exist in the room when joining
function processExistingPlayers() {
    if (!room || !room.state || !room.state.players) {
        console.warn("Cannot process existing players: room or players schema not available");
        return;
    }
    
    console.log("Processing existing players in room");
    
    // Loop through all existing players
    room.state.players.forEach((player, sessionId) => {
        // Skip local player
        if (sessionId === room.sessionId) {
            console.log("Skipping local player in existing players processing");
            return;
        }
        
        console.log(`Processing existing player: ${sessionId}`, player);
        
        try {
            // Check if we already have this player
            if (window.otherPlayers[sessionId]) {
                console.log(`Player ${sessionId} already has a visual, skipping`);
                return;
            }
            
            // Verify Numberblock class is available
            if (typeof window.Numberblock !== 'function') {
                console.error("Numberblock class not available in window object!");
                return;
            }
            
            // Verify scene is available
            if (!window.scene) {
                console.error("Scene not available in window object!");
                return;
            }
            
            // Create a new Numberblock for this existing player
            const numberblock = new window.Numberblock(player.value, player.color, player.name);
            console.log(`Created Numberblock for existing player ${sessionId}:`, numberblock);
            
            // Position and rotate the Numberblock according to server data
            numberblock.mesh.position.set(player.x, player.y, player.z);
            numberblock.mesh.rotation.y = player.rotationY;
            
            // Add the Numberblock explicitly to the scene
            window.scene.add(numberblock.mesh);
            console.log(`Added existing remote player ${sessionId} Numberblock to scene`);
            
            // Store reference
            window.otherPlayers[sessionId] = numberblock;
            
            // Setup onChange handler for updates
            player.onChange = () => {
                console.log(`Existing player ${sessionId} changed:`, player);
                
                // Skip if Numberblock was removed
                if (!window.otherPlayers[sessionId]) {
                    console.warn(`Numberblock for player ${sessionId} not found during onChange!`);
                    return;
                }
                
                // Update position and rotation
                const nb = window.otherPlayers[sessionId];
                nb.mesh.position.set(player.x, player.y, player.z);
                nb.mesh.rotation.y = player.rotationY;
                
                // Update value if changed
                if (nb.value !== player.value) {
                    console.log(`Updating value for player ${sessionId} from ${nb.value} to ${player.value}`);
                    nb.updateValue(player.value);
                }
            };
        } catch (error) {
            console.error(`Error creating visual for existing player ${sessionId}:`, error);
        }
    });
    
    console.log("Finished processing existing players");
}

// Setup message handlers
function setupMessageHandlers() {
    if (!room) return;
    
    // Handle errors
    room.onError((code, message) => {
        console.error(`Room error: ${code} - ${message}`);
    });
    
    // Handle leaving
    room.onLeave((code) => {
        console.log(`Left room with code ${code}`);
    });
    
    // Handle messages
    room.onMessage("*", (type, message) => {
        console.log(`Received message of type ${type}:`, message);
    });
}

// Setup room listeners
function setupRoomListeners() {
    console.log("Setting up room listeners");
    
    if (!room) {
        console.error("Room not available!");
        return;
    }
    
    // Set up message handlers
    setupMessageHandlers();
    
    // Debug room state
    console.log("Room state:", room.state);
    console.log("Room schemas:", Object.keys(room.state || {}));
    
    // Global reference to other players - explicitly initialize
    window.otherPlayers = window.otherPlayers || {};
    
    // Safely access players schema
    if (room.state && room.state.players) {
        console.log("Setting up player schema listeners");
        
        // Global tracking of other players' visuals explicitly
        window.otherPlayers = window.otherPlayers || {};

        // Explicitly handle players joining AFTER local client is connected
        room.state.players.onAdd = (player, sessionId) => {
            if (sessionId === room.sessionId) {
                // Explicitly assign local player's color from server data
                window.playerNumberblock.color = player.color;
                window.playerNumberblock.updateColor(player.color);
                console.log(`Local player color explicitly set to ${player.color}`);
                return; // skip local player
            }

            console.log(`Player ${sessionId} joined later; creating visual explicitly.`);
            const numberblock = new window.Numberblock(player.value, player.color, player.name);
            numberblock.mesh.position.set(player.x, player.y, player.z);
            numberblock.mesh.rotation.y = player.rotationY;

            window.scene.add(numberblock.mesh);
            window.otherPlayers[sessionId] = numberblock;

            player.onChange = (changes) => {
                changes.forEach(change => {
                    if (['x', 'y', 'z'].includes(change.field)) {
                        numberblock.mesh.position.set(player.x, player.y, player.z);
                    }
                    if (change.field === "rotationY") {
                        numberblock.mesh.rotation.y = player.rotationY;
                    }
                    if (change.field === "value") {
                        numberblock.updateValue(player.value);
                    }
                    if (change.field === "color") {
                        numberblock.updateColor(player.color);
                    }
                });
            };
        };

        room.state.players.onRemove = (player, sessionId) => {
            const numberblock = window.otherPlayers[sessionId];
            if (numberblock) {
                window.scene.remove(numberblock.mesh);
                delete window.otherPlayers[sessionId];
            }
        };
    }
    
    // Handle operators if available
    if (room.state && room.state.operators) {
        console.log("Setting up operator schema listeners");
        setupSpecificSchemaListeners('operators', room.state.operators);
    }
    
    // Handle static numberblocks if available
    if (room.state && room.state.staticNumberblocks) {
        console.log("Setting up static numberblocks schema listeners");
        setupSpecificSchemaListeners('staticNumberblocks', room.state.staticNumberblocks);
    }
}

// Setup schema listeners for a specific object type
function setupSpecificSchemaListeners(schemaName, schema) {
    console.log(`Setting up schema listeners for ${schemaName}`);
    
    // Skip if no schema
    if (!schema) {
        console.warn(`No schema available for ${schemaName}`);
        return;
    }
    
    // Get the visual class based on schema name
    let VisualClass;
    
    // Handle special naming cases
    if (schemaName === 'operators') {
        VisualClass = window.OperatorsVisual;
    } else if (schemaName === 'staticNumberblocks') {
        VisualClass = window.StaticNumberblocksVisual;
    } else {
        // Default naming convention
        const VisualClassName = `${schemaName.charAt(0).toUpperCase() + schemaName.slice(1, -1)}Visual`;
        VisualClass = window[VisualClassName];
    }
    
    if (!VisualClass) {
        console.error(`No visual class found for ${schemaName}. Available classes:`, 
            Object.keys(window).filter(key => key.includes('Visual')));
        return;
    }
    
    console.log(`Found visual class for ${schemaName}:`, VisualClass.name);
    
    // Set up onAdd listener
    schema.onAdd = function(obj, id) {
        console.log(`${schemaName} added: ${id}`, obj);
        
        // Skip local player
        if (schemaName === "players" && id === room.sessionId) {
            console.log("Skipping visual creation for local player");
            return;
        }
        
        try {
            // Create visual
            const visual = new VisualClass(obj);
            
            // Add to scene
            if (window.scene && visual.mesh) {
                window.scene.add(visual.mesh);
                console.log(`Added ${schemaName} visual for ${id} to scene`);
            } else {
                console.error(`Scene or mesh not available for ${schemaName} ${id}`);
            }
            
            // Store in visuals tracking
            visuals[schemaName][id] = visual;
            
            // Set up onChange listener
            obj.onChange = function() {
                console.log(`${schemaName} ${id} changed:`, obj);
                
                if (visuals[schemaName][id]) {
                    visuals[schemaName][id].update(obj);
                }
                
                // Update player list UI if this is a player
                if (schemaName === "players") {
                    updatePlayerListUI();
                }
            };
        } catch (error) {
            console.error(`Error creating visual for ${schemaName} ${id}:`, error);
        }
    };
    
    // Set up onRemove listener
    schema.onRemove = function(obj, id) {
        console.log(`${schemaName} removed: ${id}`);
        
        // Skip local player
        if (schemaName === "players" && id === room.sessionId) {
            console.log("Skipping visual removal for local player");
            return;
        }
        
        // Remove visual
        if (visuals[schemaName][id]) {
            const visual = visuals[schemaName][id];
            
            try {
                // Remove from scene
                if (window.scene && visual.mesh) {
                    window.scene.remove(visual.mesh);
                }
                
                // Dispose resources
                if (visual.mesh) {
                    if (visual.mesh.geometry) {
                        visual.mesh.geometry.dispose();
                    }
                    
                    if (visual.mesh.material) {
                        if (Array.isArray(visual.mesh.material)) {
                            visual.mesh.material.forEach(m => m.dispose());
                        } else {
                            visual.mesh.material.dispose();
                        }
                    }
                }
                
                // Remove from tracking
                delete visuals[schemaName][id];
                console.log(`Removed ${schemaName} ${id} visual`);
            } catch (error) {
                console.error(`Error removing ${schemaName} ${id} visual:`, error);
            }
        }
        
        // Update player list UI if this is a player
        if (schemaName === "players") {
            updatePlayerListUI();
        }
    };
}

// Update player list in UI
function updatePlayerListUI() {
    // Get references if not yet set
    if (!playerListElement) playerListElement = document.getElementById('player-list');
    if (!playerListToggleButton) playerListToggleButton = document.getElementById('player-list-header');
    
    if (!playerListElement || !playerListToggleButton) {
        console.log("Player list elements not yet available in DOM");
        return;
    }
    
    // Clear current list
    playerListElement.innerHTML = '';
    
    // Default to 0 players
    let playerCount = 0;
    
    // Detailed debug for state structure
    if (room && room.state) {
        console.log("Current room state:", JSON.stringify(room.state));
    }
    
    // Log the current state of players
    console.log("Player state:", room?.state?.players);
    
    // Try different approaches to get players
    if (room && room.state && room.state.players) {
        try {
            // APPROACH 1: Use schema forEach if available (most reliable for Colyseus schemas)
            if (typeof room.state.players.forEach === 'function') {
                console.log("Using forEach method");
                room.state.players.forEach((player, key) => {
                    console.log(`Player [${key}]:`, player);
                    addPlayerToList(player, key);
                    playerCount++;
                });
            }
            // APPROACH 2: Use manual iteration over entries
            else if (typeof room.state.players.entries === 'function') {
                console.log("Using entries method");
                for (const [key, player] of room.state.players.entries()) {
                    console.log(`Player [${key}]:`, player);
                    addPlayerToList(player, key);
                    playerCount++;
                }
            } 
            // APPROACH 3: Use standard object iteration
            else {
                console.log("Using object iteration");
                // Get all players
                try {
                    // Try to use toJSON first (some versions of Colyseus)
                    const playersObj = room.state.players.toJSON ? room.state.players.toJSON() : room.state.players;
                    
                    // Iterate through players
                    for (const key in playersObj) {
                        if (playersObj.hasOwnProperty(key)) {
                            const player = playersObj[key];
                            console.log(`Player [${key}}:`, player);
                            addPlayerToList(player, key);
                            playerCount++;
                        }
                    }
                } catch (e) {
                    console.error("Error iterating players:", e);
                }
            }
        } catch (error) {
            console.error("Error updating player list:", error);
        }
    }
    
    console.log(`Total player count: ${playerCount}`);
    
    // Update player count in header
    playerListToggleButton.textContent = `Players (${playerCount})`;
}

// Helper function to add a player to the list UI
function addPlayerToList(player, sessionId) {
    if (!player) {
        console.warn(`Skipping undefined player with ID ${sessionId}`);
        return;
    }
    
    console.log(`Creating UI entry for player ${sessionId}`);
    
    // Create player entry
    const playerEntry = document.createElement('div');
    playerEntry.className = 'player-entry';
    
    // Create color indicator
    const colorIndicator = document.createElement('div');
    colorIndicator.className = 'player-color';
    colorIndicator.style.backgroundColor = player.color || getColorForValue(player.value || 1);
    
    // Player info - show "You" for local player
    const playerInfo = document.createElement('div');
    playerInfo.className = 'player-info';
    
    // Determine display name
    let displayName;
    let valueText = player.value || 1;
    
    if (room && sessionId === room.sessionId) {
        displayName = "You";
    } else {
        // Use name property if available, fallback to session ID
        displayName = player.name || `Player-${sessionId.substring(0, 4)}`;
    }
    
    playerInfo.textContent = `${displayName} (${valueText})`;
    
    // Log the entry we're adding to the UI
    console.log(`Adding player entry: ${displayName} with value ${valueText} and color ${colorIndicator.style.backgroundColor}`);
    
    // Add elements to entry
    playerEntry.appendChild(colorIndicator);
    playerEntry.appendChild(playerInfo);
    playerListElement.appendChild(playerEntry);
}

// Get position from player object, with validation
function getPlayerPosition(player) {
    if (!player) return { x: 0, y: 0, z: 0 };
    return {
        x: player.x || 0,
        y: player.y || 0,
        z: player.z || 0,
        rotationY: player.rotationY || 0,
        pitch: player.pitch || 0
    };
}

// Set up key event listeners for player list toggle
function setupPlayerListKeyControls() {
    // Using keydown to capture Tab key
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Tab') {
            event.preventDefault(); // Prevent default tab behavior
            togglePlayerList(); // Use a dedicated toggle function
        }
    });
}

// Function to toggle player list visibility
function togglePlayerList() {
    const playerList = document.getElementById('player-list');
    const collapseIcon = document.getElementById('collapse-icon');
    
    if (!playerList || !collapseIcon) return;
    
    console.log("Toggling player list visibility");
    
    if (playerList.style.display === 'none') {
        playerList.style.display = 'block';
        collapseIcon.textContent = '▼';
    } else {
        playerList.style.display = 'none';
        collapseIcon.textContent = '▶';
    }
}

// Send player position updates to the server
window.sendPlayerUpdate = function(position, rotationY, pitch, value) {
    if (!room) {
        console.log("Room not connected, skipping position update");
        return;
    }
    
    try {
        let posX, posY, posZ;
        
        // Check if position is a Vector3 or a simple object
        if (position instanceof THREE.Vector3) {
            posX = position.x;
            posY = position.y;
            posZ = position.z;
        } else if (typeof position === 'object' && position !== null) {
            posX = position.x;
            posY = position.y;
            posZ = position.z;
        } else {
            console.error("Invalid position:", position);
            return;
        }
        
        // Validate data before sending
        if (isNaN(posX) || isNaN(posY) || isNaN(posZ)) {
            console.error("Position contains NaN values:", position);
            return;
        }
        
        // Send more detailed data to the server
        room.send("move", {
            x: posX,
            y: posY,
            z: posZ,
            rotationY: rotationY || 0,
            pitch: pitch || 0,
            value: value || 1
        });
        
        // Debug output for position updates
        if (window.DEBUG) {
            console.log(`Sent position: (${posX.toFixed(2)}, ${posY.toFixed(2)}, ${posZ.toFixed(2)}), rot: ${rotationY?.toFixed(2)}`);
        }
    } catch (error) {
        console.error("Error sending player update:", error);
    }
};

// Send operator collection message
function sendOperatorCollect(operatorId) {
    if (!room) return;
    
    room.send("collectOperator", {
        id: operatorId
    });
}

// Send numberblock collision message
function sendNumberblockCollision(targetId) {
    if (!room) return;
    
    room.send("numberblockCollision", {
        targetId: targetId
    });
}

// Define visual classes for each object type
window.PlayersVisual = class PlayersVisual {
    constructor(playerData) {
        console.log("Creating player visual with data:", playerData);
        
        this.value = playerData.value;
        this.color = playerData.color || getColorForValue(this.value);
        
        // Create a Numberblock for this player
        const NumberblockClass = window.Numberblock || Numberblock;
        
        try {
            this.numberblock = new NumberblockClass(this.value, this.color);
            this.mesh = this.numberblock.mesh;
            
            // Set initial position
            this.mesh.position.set(playerData.x, playerData.y, playerData.z);
            
            // Set rotation if available
            if (playerData.rotationY !== undefined) {
                this.mesh.rotation.y = playerData.rotationY;
            }
            
            // Add player name label above the numberblock
            if (playerData.name) {
                const nameDiv = document.createElement('div');
                nameDiv.className = 'player-name-label';
                nameDiv.textContent = playerData.name;
                nameDiv.style.color = 'white';
                nameDiv.style.backgroundColor = 'rgba(0,0,0,0.5)';
                nameDiv.style.padding = '2px 5px';
                nameDiv.style.borderRadius = '3px';
                nameDiv.style.userSelect = 'none';
                
                const nameLabel = new CSS2DObject(nameDiv);
                nameLabel.position.set(0, this.numberblock.getHeight() + 0.5, 0);
                this.mesh.add(nameLabel);
            }
        } catch (error) {
            console.error("Error creating player visual:", error);
            // Create a fallback placeholder mesh
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshBasicMaterial({ color: this.color });
            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.position.set(playerData.x, playerData.y, playerData.z);
        }
    }
    
    update(playerData) {
        console.log("Updating player visual with data:", playerData);
        
        // Skip update for null/undefined data
        if (!playerData) {
            console.warn("Received invalid player data");
            return;
        }
        
        // Update position
        if (this.mesh) {
            // Only update position if we have valid coordinates
            if (playerData.x !== undefined && playerData.y !== undefined && playerData.z !== undefined) {
                // Check if values are not NaN
                if (!isNaN(playerData.x) && !isNaN(playerData.y) && !isNaN(playerData.z)) {
                    this.mesh.position.set(playerData.x, playerData.y, playerData.z);
                } else {
                    console.warn("Received NaN position values", playerData);
                }
            }
            
            // Update rotation if available and valid
            if (playerData.rotationY !== undefined && !isNaN(playerData.rotationY)) {
                this.mesh.rotation.y = playerData.rotationY;
            }
            
            // Force the mesh to be visible
            this.mesh.visible = true;
        } else {
            console.warn("No mesh exists for this player visual");
        }
        
        // Update value if changed and we have an updateValue method
        if (this.value !== playerData.value && playerData.value !== undefined && !isNaN(playerData.value)) {
            console.log(`Player value changed from ${this.value} to ${playerData.value}`);
            this.value = playerData.value;
            
            if (this.numberblock && typeof this.numberblock.updateValue === 'function') {
                // Try the elegant update if available
                this.numberblock.updateValue(this.value);
            } else {
                // Fallback to recreate the mesh
                const oldMesh = this.mesh;
                const position = oldMesh.position.clone();
                const rotation = oldMesh.rotation.clone();
                
                // Remove old mesh
                if (window.scene) {
                    window.scene.remove(oldMesh);
                }
                
                // Create new mesh
                const NumberblockClass = window.Numberblock || Numberblock;
                this.numberblock = new NumberblockClass(this.value, this.color);
                this.mesh = this.numberblock.mesh;
                
                // Set position and rotation
                this.mesh.position.copy(position);
                this.mesh.rotation.copy(rotation);
                
                // Add to scene
                if (window.scene) {
                    window.scene.add(this.mesh);
                }
                
                // Dispose old resources
                if (oldMesh.geometry) oldMesh.geometry.dispose();
                if (oldMesh.material) {
                    if (Array.isArray(oldMesh.material)) {
                        oldMesh.material.forEach(m => m.dispose());
                    } else {
                        oldMesh.material.dispose();
                    }
                }
            }
        }
    }
};

window.OperatorsVisual = class OperatorsVisual {
    constructor(operatorData) {
        console.log("Creating operator visual with data:", operatorData);
        
        this.type = operatorData.type; // "+" or "-"
        this.value = operatorData.value || 1;
        
        // Create a mesh for this operator
        this.createOperatorMesh();
        
        // Set initial position
        this.mesh.position.set(operatorData.x, operatorData.y, operatorData.z);
        
        // Add a rotation animation
        this.rotationSpeed = 0.01;
        this.bounceHeight = 0.2;
        this.bounceSpeed = 0.5;
        this.initialY = operatorData.y;
        this.time = Math.random() * 1000; // Randomize starting point in animation
    }
    
    createOperatorMesh() {
        // Create operator text geometry
        const operatorSymbol = this.type === "add" ? "+" : "-";
        const color = this.type === "add" ? 0x00ff00 : 0xff0000; // Green for +, Red for -
        
        try {
            // Check if font loader is available in window
            if (window.fontLoader) {
                // Create text geometry for the operator
                window.fontLoader.load('/fonts/helvetiker_bold.typeface.json', (font) => {
                    const textGeometry = new THREE.TextGeometry(operatorSymbol, {
                        font: font,
                        size: 0.5,
                        height: 0.1,
                    });
                    
                    const textMaterial = new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    
                    // Center the text geometry
                    textGeometry.computeBoundingBox();
                    const textSize = textGeometry.boundingBox.getSize(new THREE.Vector3());
                    textMesh.position.set(-textSize.x/2, -textSize.y/2, -textSize.z/2);
                    
                    // Create a group to hold the text and allow for easier rotation
                    const group = new THREE.Group();
                    group.add(textMesh);
                    
                    // Add a glow effect (sphere with transparent material)
                    const glowGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.3
                    });
                    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                    group.add(glowMesh);
                    
                    // Replace placeholder if it exists
                    if (this.mesh && this.mesh.parent) {
                        const position = this.mesh.position.clone();
                        const parent = this.mesh.parent;
                        parent.remove(this.mesh);
                        this.mesh = group;
                        this.mesh.position.copy(position);
                        parent.add(this.mesh);
                    } else {
                        this.mesh = group;
                    }
                });
            } else {
                // Fallback if font loader is not available
                console.warn("Font loader not available, creating fallback operator mesh");
                this.createFallbackMesh(color);
            }
        } catch (error) {
            console.error("Error creating operator text mesh:", error);
            this.createFallbackMesh(color);
        }
    }
    
    createFallbackMesh(color) {
        // Create a simple shape as fallback
        const geometry = this.type === "add" ? 
            new THREE.OctahedronGeometry(0.3) : 
            new THREE.BoxGeometry(0.5, 0.2, 0.2);
        
        const material = new THREE.MeshStandardMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        
        // Add a glow effect
        const glowGeometry = new THREE.SphereGeometry(0.4, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.3
        });
        const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
        
        // Create a group to hold both meshes
        const group = new THREE.Group();
        group.add(this.mesh);
        group.add(glowMesh);
        
        this.mesh = group;
    }
    
    update(operatorData) {
        // Update position
        this.mesh.position.set(operatorData.x, operatorData.y, operatorData.z);
        this.initialY = operatorData.y; // Update initial Y for animation
        
        // Update type if changed
        if (this.type !== operatorData.type) {
            console.log(`Operator type changed from ${this.type} to ${operatorData.type}`);
            this.type = operatorData.type;
            
            // Recreate mesh with new type
            const oldMesh = this.mesh;
            const position = oldMesh.position.clone();
            const parent = oldMesh.parent;
            
            // Create new mesh
            this.createOperatorMesh();
            this.mesh.position.copy(position);
            
            // Add to scene/parent
            if (parent) {
                parent.remove(oldMesh);
                parent.add(this.mesh);
            } else if (window.scene) {
                window.scene.remove(oldMesh);
                window.scene.add(this.mesh);
            }
            
            // Dispose old resources (if possible)
            try {
                if (oldMesh.traverse) {
                    oldMesh.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }
            } catch (error) {
                console.error("Error disposing operator resources:", error);
            }
        }
    }
    
    // Animate the operator (rotation and floating effect)
    animate(deltaTime) {
        if (!this.mesh) return;
        
        // Increment time counter
        this.time += deltaTime;
        
        // Rotate around Y axis
        this.mesh.rotation.y += this.rotationSpeed;
        
        // Floating effect (sine wave)
        const yOffset = Math.sin(this.time * this.bounceSpeed) * this.bounceHeight;
        this.mesh.position.y = this.initialY + yOffset;
        
        // Always face camera if available
        if (window.camera) {
            // Only align in XZ plane, keeping Y rotation normal
            const cameraPos = window.camera.position.clone();
            const meshPos = this.mesh.position.clone();
            
            // Set the same Y coordinate for both positions to only align in XZ plane
            cameraPos.y = meshPos.y;
            
            // Look at camera
            // We're not using lookAt directly on the mesh to avoid flipping issues
            // Instead, we use a temporary vector to calculate the direction
            const direction = new THREE.Vector3().subVectors(cameraPos, meshPos).normalize();
            const angle = Math.atan2(direction.x, direction.z);
            
            // Apply rotation only to inner content if it's a group
            if (this.mesh.children && this.mesh.children.length > 0) {
                this.mesh.children.forEach(child => {
                    if (child.isText) {
                        child.rotation.y = angle;
                    }
                });
            } else {
                this.mesh.rotation.y = angle;
            }
        }
    }
};

window.StaticNumberblocksVisual = class StaticNumberblocksVisual {
    constructor(blockData) {
        this.value = blockData.value;
        this.color = blockData.color;
        
        // Create a Numberblock for this static block
        const NumberblockClass = window.Numberblock || Numberblock;
        this.mesh = new NumberblockClass(this.value, this.color).mesh;
        
        // Set initial position
        this.mesh.position.set(blockData.x, blockData.y, blockData.z);
        
        // Static blocks don't move, but may rotate or animate
        if (blockData.rotationY !== undefined) {
            this.mesh.rotation.y = blockData.rotationY;
        }
    }
    
    update(blockData) {
        // Update position if needed (should be rare for static blocks)
        this.mesh.position.set(blockData.x, blockData.y, blockData.z);
        
        // Update rotation if available
        if (blockData.rotationY !== undefined) {
            this.mesh.rotation.y = blockData.rotationY;
        }
        
        // Update value if changed
        if (this.value !== blockData.value) {
            console.log(`Static block value changed from ${this.value} to ${blockData.value}`);
            this.value = blockData.value;
            
            // Create a new Numberblock with the updated value
            const oldMesh = this.mesh;
            const position = oldMesh.position.clone();
            const rotation = oldMesh.rotation.clone();
            
            // Remove old mesh
            window.scene.remove(oldMesh);
            
            // Create new mesh
            const NumberblockClass = window.Numberblock || Numberblock;
            const numberblock = new NumberblockClass(this.value, this.color);
            this.mesh = numberblock.mesh;
            
            // Set position and rotation
            this.mesh.position.copy(position);
            this.mesh.rotation.copy(rotation);
            
            // Add to scene
            window.scene.add(this.mesh);
            
            // Dispose old resources
            if (oldMesh.geometry) oldMesh.geometry.dispose();
            if (oldMesh.material) {
                if (Array.isArray(oldMesh.material)) {
                    oldMesh.material.forEach(m => m.dispose());
                } else {
                    oldMesh.material.dispose();
                }
            }
        }
    }
};

// Make functions available globally
window.initNetworking = initNetworking;
window.updatePlayerListUI = updatePlayerListUI;
window.getPlayerPosition = getPlayerPosition;
window.sendPlayerUpdate = sendPlayerUpdate;
window.sendOperatorCollect = sendOperatorCollect;
window.sendNumberblockCollision = sendNumberblockCollision;
window.getColorForValue = getColorForValue;
window.togglePlayerList = togglePlayerList;
window.visuals = visuals; // Export for debugging
 
 
===================================================== 
FILE: client\js\numberblock.js 
===================================================== 
 
// Numberblocks game - Numberblock model implementation

class Numberblock {
    constructor(value = 1, color = null) {
        this.value = value;
        this.mesh = new THREE.Group();
        this.blockSize = 1; // Size of each cube
        this.blockSpacing = 0.01; // Small gap between blocks
        this.totalHeight = 0;
        
        // Set color based on the Numberblock value, following show colors if no color specified
        if (!color) {
            this.color = this.getColorForNumber(value);
        } else {
            this.color = color;
        }
        
        this.createNumberblock();
    }
    
    // Get the standard Numberblocks color based on value
    getColorForNumber(number) {
        const colors = {
            1: 0xFF0000,   // Red (One)
            2: 0xFFA500,   // Orange (Two)
            3: 0xFFFF00,   // Yellow (Three)
            4: 0x00FF00,   // Green (Four)
            5: 0x0000FF,   // Blue (Five)
            6: 0x800080,   // Purple (Six)
            7: 0xFFC0CB,   // Pink (Seven)
            8: 0xA52A2A,   // Brown (Eight)
            9: 0x808080    // Grey (Nine)
        };
        
        // For numbers greater than 9, cycle through the colors or use white
        return colors[number % 9] || 0xFFFFFF;
    }
    
    // Create the complete Numberblock with all features
    createNumberblock() {
        this.mesh.clear(); // Clear any existing meshes
        this.totalHeight = 0;
        
        // Create the stack of blocks
        for (let i = 0; i < this.value; i++) {
            const block = this.createBlock();
            
            // Position each block on top of the previous one
            block.position.y = this.totalHeight;
            this.totalHeight += this.blockSize + this.blockSpacing;
            
            this.mesh.add(block);
            
            // Add face only to the top block
            if (i === this.value - 1) {
                const face = this.createFace();
                block.add(face);
            }
            
            // Add feet to the bottom block
            if (i === 0) {
                const leftFoot = this.createFoot('left');
                const rightFoot = this.createFoot('right');
                block.add(leftFoot);
                block.add(rightFoot);
            }
        }
        
        // Add arms to the middle block or the second block from the bottom if more than 3 blocks
        const armBlockIndex = this.value <= 3 ? Math.floor(this.value / 2) : 1;
        if (this.value > 0 && armBlockIndex < this.value) {
            const leftArm = this.createArm('left');
            const rightArm = this.createArm('right');
            
            this.mesh.children[armBlockIndex].add(leftArm);
            this.mesh.children[armBlockIndex].add(rightArm);
        }
        
        // Set initial position to 0 - we'll handle positioning in the game logic
        this.mesh.position.y = 0;
    }
    
    // Get the height of the Numberblock (for physics calculations)
    getHeight() {
        // Return the total height calculated during creation
        // If value is 0, return a minimum height
        return this.value > 0 ? this.totalHeight - this.blockSpacing : this.blockSize;
    }
    
    // Update the color of the Numberblock
    updateColor(newColor) {
        this.color = newColor;
        
        // Update the color of all blocks in the Numberblock
        this.mesh.children.forEach(child => {
            // Only update the blocks, not other attachments like arms or face
            if (child.geometry && child.geometry.type === 'BoxGeometry') {
                child.material.color.set(newColor);
            }
        });
    }
    
    // Create a single block with the Numberblock's color
    createBlock() {
        const geometry = new THREE.BoxGeometry(this.blockSize, this.blockSize, this.blockSize);
        const material = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        return new THREE.Mesh(geometry, material);
    }
    
    // Create a face with eyes and mouth
    createFace() {
        const face = new THREE.Group();
        
        // Eyes (white spheres with black pupils)
        const eyeSize = this.blockSize * 0.15;
        const eyeSpacing = this.blockSize * 0.3;
        const eyeHeight = this.blockSize * 0.1;
        const eyeDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        
        // Create and position left eye
        const leftEye = this.createEye(eyeSize);
        leftEye.position.set(-eyeSpacing, eyeHeight, eyeDepth);
        face.add(leftEye);
        
        // Create and position right eye
        const rightEye = this.createEye(eyeSize);
        rightEye.position.set(eyeSpacing, eyeHeight, eyeDepth);
        face.add(rightEye);
        
        // Mouth (curved line or small cylinder)
        const mouthWidth = this.blockSize * 0.4;
        const mouthHeight = this.blockSize * 0.1;
        const mouthDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        const mouthY = -eyeHeight * 2; // Position below the eyes
        
        const mouthGeometry = new THREE.CylinderGeometry(
            mouthHeight/2, mouthHeight/2, mouthWidth, 16, 1, false, 0, Math.PI
        );
        mouthGeometry.rotateZ(Math.PI / 2); // Rotate to correct orientation
        
        const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, mouthY, mouthDepth);
        face.add(mouth);
        
        return face;
    }
    
    // Create an eye (white sphere with black pupil)
    createEye(size) {
        const eye = new THREE.Group();
        
        // White part of the eye
        const eyeWhiteGeometry = new THREE.SphereGeometry(size, 16, 16);
        const eyeWhiteMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const eyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
        eye.add(eyeWhite);
        
        // Black pupil
        const pupilSize = size * 0.5;
        const pupilGeometry = new THREE.SphereGeometry(pupilSize, 16, 16);
        const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        pupil.position.z = size * 0.6; // Position the pupil slightly in front of the eye
        eye.add(pupil);
        
        return eye;
    }
    
    // Create an arm (left or right)
    createArm(side) {
        const arm = new THREE.Group();
        
        // Arm dimensions
        const armLength = this.blockSize * 0.6;
        const armWidth = this.blockSize * 0.2;
        const armHeight = this.blockSize * 0.2;
        
        // Create the arm geometry
        const armGeometry = new THREE.BoxGeometry(armLength, armHeight, armWidth);
        const armMaterial = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        const armMesh = new THREE.Mesh(armGeometry, armMaterial);
        
        // Position the arm on the side of the block
        const xOffset = (this.blockSize / 2 + armLength / 2) * (side === 'left' ? -1 : 1);
        armMesh.position.set(xOffset, 0, 0);
        
        arm.add(armMesh);
        
        // Add a hand at the end of the arm
        const handRadius = armWidth * 0.8;
        const handGeometry = new THREE.SphereGeometry(handRadius, 16, 16);
        const handMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF, // White hands
            roughness: 0.7,
            metalness: 0.2
        });
        
        const hand = new THREE.Mesh(handGeometry, handMaterial);
        
        // Position the hand at the end of the arm
        const handX = armLength / 2 * (side === 'left' ? -1 : 1);
        hand.position.set(handX, 0, 0);
        
        // Name the hand for easy reference
        hand.name = side + 'Hand';
        
        armMesh.add(hand);
        
        return arm;
    }
    
    // Create a foot (left or right)
    createFoot(side) {
        const foot = new THREE.Group();
        
        // Foot dimensions
        const footLength = this.blockSize * 0.4;
        const footWidth = this.blockSize * 0.3;
        const footHeight = this.blockSize * 0.15;
        
        // Create the foot geometry
        const footGeometry = new THREE.BoxGeometry(footLength, footHeight, footWidth);
        const footMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000, // Black feet
            roughness: 0.7,
            metalness: 0.2
        });
        
        const footMesh = new THREE.Mesh(footGeometry, footMaterial);
        
        // Position the foot on the bottom of the block
        const xOffset = (this.blockSize / 4) * (side === 'left' ? -1 : 1);
        const yOffset = -this.blockSize / 2 - footHeight / 2;
        const zOffset = this.blockSize / 4; // Push feet slightly forward
        footMesh.position.set(xOffset, yOffset, zOffset);
        
        foot.add(footMesh);
        
        return foot;
    }
    
    // Update the Numberblock value and regenerate the model
    setValue(newValue) {
        if (newValue < 1) newValue = 1; // Ensure minimum value of 1
        if (newValue !== this.value) {
            this.value = newValue;
            this.color = this.getColorForNumber(newValue);
            this.createNumberblock();
        }
    }
    
    // Update value (used for network synchronization)
    updateValue(newValue) {
        return this.setValue(newValue);
    }
    
    // Update the position of the HTML number tag in render loop
    updateNumberTagPosition(camera, renderer) {
        // Previous functionality disabled - no longer using HTML elements for tags
        // Now fully using the HUD we created in index.html and main.js
    }
    
    // Dispose any allocated resources
    dispose() {
        // We no longer need to remove HTML elements since we aren't creating them
    }
}

// Function to create a player Numberblock and add it to the scene
function createPlayerNumberblock(scene, value = 1) {
    // Create the Numberblock
    const playerBlock = new Numberblock(value);
    
    // Position it slightly above the ground
    const totalHeight = playerBlock.totalHeight;
    playerBlock.mesh.position.y = totalHeight / 2;
    
    // Add to scene
    scene.add(playerBlock.mesh);
    
    return playerBlock;
}

// Export for use in other modules
if (typeof module !== 'undefined') {
    module.exports = {
        Numberblock,
        createPlayerNumberblock
    };
}

// Always make Numberblock available globally
window.Numberblock = Numberblock;
console.log('Numberblock class exported to window object'); 
 
===================================================== 
FILE: client\js\operator.js 
===================================================== 
 
// Numberblocks game - Operator implementation

// Class to represent mathematical operators (+ and -)
class Operator {
    constructor(type, scene) {
        this.type = type; // 'plus' or 'minus'
        this.scene = scene;
        this.mesh = this.createOperatorMesh();
        
        // Add the operator to the scene
        scene.add(this.mesh);
        
        // Set the radius for collision detection
        this.collisionRadius = 0.5;
    }
    
    // Create the 3D mesh for the operator
    createOperatorMesh() {
        const operatorGroup = new THREE.Group();
        
        // Create a semi-transparent white sphere as the base
        const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const sphereMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF, // White sphere
            roughness: 0.3,
            metalness: 0.2,
            transparent: true, // Make it transparent
            opacity: 0.6 // 60% opacity
        });
        
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        operatorGroup.add(sphere);
        
        // Create the symbol geometry (+ or -) and place it in the center
        const symbolColor = 0x000000; // Black symbol
        const symbolMaterial = new THREE.MeshBasicMaterial({ color: symbolColor });
        
        if (this.type === 'plus') {
            // Create a plus sign (+) using two cylinders
            // Horizontal bar
            const horizontalGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            horizontalGeometry.rotateZ(Math.PI / 2); // Rotate to make it horizontal
            const horizontalBar = new THREE.Mesh(horizontalGeometry, symbolMaterial);
            
            // Vertical bar
            const verticalGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            const verticalBar = new THREE.Mesh(verticalGeometry, symbolMaterial);
            
            operatorGroup.add(horizontalBar);
            operatorGroup.add(verticalBar);
        } else {
            // Create a minus sign (-) using a single cylinder
            const minusGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            minusGeometry.rotateZ(Math.PI / 2); // Rotate to make it horizontal
            const minusBar = new THREE.Mesh(minusGeometry, symbolMaterial);
            
            operatorGroup.add(minusBar);
        }
        
        // Add a soft glow effect
        const glowGeometry = new THREE.SphereGeometry(0.6, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF, // White glow
            transparent: true,
            opacity: 0.2
        });
        
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        operatorGroup.add(glow);
        
        // Add rotation animation that ensures the symbol stays visible
        this.animate = (deltaTime) => {
            // Instead of rotating around Y-axis, make the operator face the camera
            if (window.camera) {
                // Get direction to camera
                const direction = new THREE.Vector3();
                direction.subVectors(window.camera.position, operatorGroup.position).normalize();
                
                // Create a temporary up vector (world up)
                const up = new THREE.Vector3(0, 1, 0);
                
                // Create a look-at matrix
                const lookMatrix = new THREE.Matrix4();
                lookMatrix.lookAt(operatorGroup.position, 
                                  operatorGroup.position.clone().add(direction), 
                                  up);
                
                // Convert to quaternion and apply
                operatorGroup.quaternion.setFromRotationMatrix(lookMatrix);
            } else {
                // Default rotation if no camera
                operatorGroup.rotation.y += deltaTime * 1.5;
            }
            
            // Add a subtle floating animation
            operatorGroup.position.y = Math.sin(Date.now() * 0.002) * 0.1 + 0.6; // Float between 0.5 and 0.7
        };
        
        return operatorGroup;
    }
    
    // Position the operator in the scene
    setPosition(x, y, z) {
        this.mesh.position.set(x, y, z);
    }
    
    // Remove the operator from the scene
    remove() {
        this.scene.remove(this.mesh);
        
        // Clean up geometries and materials to prevent memory leaks
        this.mesh.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(material => material.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
    }
    
    // Create a smaller version of the operator for holding
    createHeldOperatorMesh() {
        // Create a smaller version of the operator for holding
        const scale = 0.4; // Smaller scale for held operator
        const heldMesh = this.createOperatorMesh();
        heldMesh.scale.set(scale, scale, scale);
        
        return heldMesh;
    }
}

// Class to manage all operators in the game
class OperatorManager {
    constructor(scene) {
        this.scene = scene;
        this.operators = [];
        this.spawnTimer = 0;
        this.spawnInterval = this.getRandomSpawnInterval();
        this.maxOperators = 10; // Maximum number of operators allowed at once
        this.groundY = 0; // Y position of the ground
        this.mapSize = 40; // Size of the playable area (40x40)
        
        // Player's held operator
        this.heldOperator = null;
        this.heldOperatorMesh = null;
        
        // Debug message to check initialization
        console.log("OperatorManager initialized");
    }
    
    // Get a random spawn interval between 5-10 seconds
    getRandomSpawnInterval() {
        return 5 + Math.random() * 5; // 5-10 seconds
    }
    
    // Update function to be called in animation loop
    update(deltaTime) {
        // Update existing operators
        this.operators.forEach(operator => {
            operator.animate(deltaTime);
        });
        
        // Check if it's time to spawn a new operator
        this.spawnTimer += deltaTime;
        if (this.spawnTimer >= this.spawnInterval && this.operators.length < this.maxOperators) {
            this.spawnOperator();
            this.spawnTimer = 0;
            this.spawnInterval = this.getRandomSpawnInterval();
        }
    }
    
    // Spawn a new operator at a random position
    spawnOperator() {
        // Randomly choose between plus and minus
        const type = Math.random() > 0.5 ? 'plus' : 'minus';
        
        // Create the operator
        const operator = new Operator(type, this.scene);
        
        // Set a random position on the ground
        const posX = (Math.random() * this.mapSize) - (this.mapSize / 2);
        const posZ = (Math.random() * this.mapSize) - (this.mapSize / 2);
        
        // Set the Y position slightly above the ground to prevent z-fighting
        operator.setPosition(posX, this.groundY + 0.6, posZ);
        
        // Add to the array of active operators
        this.operators.push(operator);
        
        console.log(`Spawned ${type} operator at (${posX.toFixed(2)}, ${this.groundY + 0.6}, ${posZ.toFixed(2)})`);
        
        return operator;
    }
    
    // Remove an operator from the scene and the operators array
    removeOperator(operator) {
        const index = this.operators.indexOf(operator);
        if (index !== -1) {
            operator.remove();
            this.operators.splice(index, 1);
        }
    }
    
    // Set the currently held operator
    setHeldOperator(operator, numberblock) {
        // Clear any previously held operator
        this.clearHeldOperator();
        
        // Store the operator type
        this.heldOperator = operator.type;
        console.log("Setting held operator type:", this.heldOperator); // Debug log
        
        // Create a smaller version of the operator for holding
        this.heldOperatorMesh = operator.createHeldOperatorMesh();
        
        // Attach the operator to the Numberblock's right hand
        if (numberblock && numberblock.mesh) {
            // Find the right hand in the Numberblock's mesh hierarchy
            let rightHand = null;
            
            // Look for the arm block (should be the second block for Numberblocks with more than 3 blocks)
            const armBlockIndex = numberblock.value <= 3 ? Math.floor(numberblock.value / 2) : 1;
            
            // Find the right hand if there are enough blocks
            if (numberblock.value > 0 && armBlockIndex < numberblock.value) {
                // Get the arm block
                const armBlock = numberblock.mesh.children[armBlockIndex];
                
                // Search for the rightHand in the arm block's children
                armBlock.traverse((child) => {
                    if (child.name === 'rightHand') {
                        rightHand = child;
                    }
                });
                
                // If we found the right hand, attach the operator to it
                if (rightHand) {
                    // Position the held operator slightly offset from the hand
                    this.heldOperatorMesh.position.set(0, 0.2, 0);
                    
                    // Add the held operator mesh to the right hand
                    rightHand.add(this.heldOperatorMesh);
                    
                    console.log(`Attached ${this.heldOperator} operator to Numberblock's right hand`);
                } else {
                    // Fallback: Add to the scene if we can't find the hand
                    console.warn("Could not find rightHand - adding operator to scene");
                    this.scene.add(this.heldOperatorMesh);
                }
            } else {
                // Fallback: Add to the scene if Numberblock doesn't have arms
                console.warn("Numberblock doesn't have enough blocks for arms - adding operator to scene");
                this.scene.add(this.heldOperatorMesh);
            }
        } else {
            // Add to the scene if no Numberblock is provided
            this.scene.add(this.heldOperatorMesh);
        }
        
        // Remove the original operator from the scene
        this.removeOperator(operator);
        
        console.log(`Now holding ${this.heldOperator} operator`); // Debug log
        return this.heldOperator;
    }
    
    // Clear the currently held operator
    clearHeldOperator() {
        if (this.heldOperatorMesh) {
            // Remove from parent (either scene or hand)
            if (this.heldOperatorMesh.parent) {
                this.heldOperatorMesh.parent.remove(this.heldOperatorMesh);
            } else {
                this.scene.remove(this.heldOperatorMesh);
            }
            
            this.heldOperatorMesh = null;
        }
        this.heldOperator = null;
        console.log("Cleared held operator"); // Debug log
    }
    
    // Get the currently held operator type
    getHeldOperator() {
        console.log("Getting held operator type:", this.heldOperator); // Debug log
        return this.heldOperator;
    }
    
    // Attach the held operator to a Numberblock
    attachOperatorToNumberblock(numberblock) {
        if (this.heldOperatorMesh && numberblock) {
            // The numberblock will handle the positioning
            return {
                type: this.heldOperator,
                mesh: this.heldOperatorMesh
            };
        }
        return null;
    }
    
    // Clear all operators
    clearAll() {
        while (this.operators.length > 0) {
            this.removeOperator(this.operators[0]);
        }
        this.clearHeldOperator();
    }
    
    // Get all operators for collision checking
    getOperators() {
        return this.operators;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined') {
    module.exports = {
        Operator,
        OperatorManager
    };
}
 
 
