===================================================== 
NUMBERBLOCKS GAME - COMPLETE CODE COMPILATION 
===================================================== 
 
===================================================== 
SECTION: MEMORY BANK 
===================================================== 
 
----------------------------------------------------- 
FILE: memory bank\architecture.md 
----------------------------------------------------- 
 
Root
├── index.html
├── package.json
├── README.md
├── assets
│   ├── images
│   ├── models
│   └── sounds
├── css
│   └── styles.css
├── js
│   ├── main.js
│   ├── controls.js
│   ├── numberblock.js
│   ├── player.js
│   ├── operators.js
│   ├── network.js
│   ├── hud.js
│   ├── gameModes.js
│   └── operator.js
└── lib
    └── three.min.js

    Explanation of the Structure
Root: The top-level directory containing essential project files:
index.html: The main HTML file that serves as the entry point for your application or game.

package.json: (Optional) A file for managing project dependencies if you're using Node.js or a package manager like npm.

README.md: A Markdown file for project documentation, instructions, and notes.

assets/: A folder for all static resources:
images/: Stores image files like textures, icons, or sprites.

models/: Holds 3D model files (if applicable, e.g., for a 3D game).

sounds/: Contains audio files such as sound effects or background music.

css/: A folder for styling:
styles.css: The primary CSS file for styling your UI, HUD, or other visual elements.

js/: A folder for all JavaScript files, each serving a specific purpose:
main.js: The core script that initializes the project (e.g., sets up the scene or game loop).

controls.js: Handles user input and controls (e.g., keyboard or mouse events). Features:
  - Robust fallback mechanisms for browser API compatibility
  - First-person camera controls with parent-child hierarchy for proper rotation
  - Separated yaw and pitch rotations for natural camera movement
  - Mouse locking within the game window with proper cursor disengagement
  - Event handler management for clean switching between locked/unlocked states
  - Support for WASD/Arrow keys movement and spacebar jumping

numberblock.js: Implements the Numberblock class for creating and managing Numberblock entities. Features:
  - Dynamic creation of block stacks based on numeric value
  - Face rendering with eyes and mouth on the top block
  - Arms with hands on the sides of blocks
  - Feet on the bottom block
  - Number tag display on top of the stack
  - Color mapping based on Numberblocks TV show aesthetics
  - HTML/CSS overlay for number display
  - Methods for updating and animating Numberblocks

player.js: Manages player-related logic (e.g., movement, health).

operators.js: Contains logic for operators or game entities (e.g., enemies, NPCs).

network.js: Implements networking features (e.g., multiplayer via WebSockets).

hud.js: Updates the heads-up display (e.g., score, health bar).

gameModes.js: Defines different game modes or rules.

operator.js: Manages operator-related logic (e.g., spawning, lifecycle).

lib/: A folder for external libraries:
three.min.js: The minified Three.js library for 3D rendering (you can add other libraries here as needed).

memory bank/: A folder for documentation and development notes:
implementation plan: Detailed steps for implementing the game features.
progress.md: Tracks completed steps and progress notes.
RULES.md: Contains development guidelines and best practices.
architecture.md: 
# Numberblocks Game Architecture

## Core Components

### 1. Scene Management (main.js)
- Scene initialization and setup
- Camera configuration
- Lighting setup
- Animation loop
- Asset loading
- Proper initialization order:
  1. Scene, camera, renderer setup
  2. Ground and environment
  3. Player Numberblock creation
  4. Operator system initialization
  5. Controls initialization

### 2. Controls System (controls.js)
- First-person camera controls using PointerLockControls
- Movement handling (WASD/Arrow keys)
  - W = Forward movement
  - S = Backward movement
  - A = Strafe left
  - D = Strafe right
- Rotation controls (Q/E keys)
  - Q = Turn left (counter-clockwise)
  - E = Turn right (clockwise)
- Jump mechanics (Spacebar)
- Gravity and ground collision
- Fallback controls for environments without Pointer Lock
- Delta time-based smooth movement
- Debug logging for control states

### 3. Numberblock System (numberblock.js)
#### Visual Components
- Stacked blocks based on numeric value
- Color-coded blocks following Numberblocks scheme
- Face on top block with eyes and mouth
- Arms on middle or second block
- Feet on bottom block
- No number display (shown in HUD instead)

#### Positioning System
- Base Y-position calculated from block size
- Consistent ground-level placement
- Proper collision boundaries
- Random placement with spawn area restrictions

### 4. Operator System (operator.js)
#### Visual Design
- Floating semi-transparent spheres
- Clear plus/minus symbols
- Color-coded feedback (green/red)
- Soft glow effect for visibility

#### Behavior
- Face camera for constant visibility
- Gentle floating animation
- Spawn randomly in valid areas
- Limited to maximum count
- Clear pickup and application feedback

## HUD System
The game features a minimalist HUD with two key elements:
1. Number Display (Top-Left)
   - Shows current Numberblock value
   - Color changes to match Numberblock color scheme
   - Uses semi-transparent background for visibility
   - Updates in real-time with player changes

2. Operator Display (Top-Right)
   - Shows current held operator ("+ Add" or "- Subtract")
   - Green for addition, red for subtraction
   - Shows "No operator" when none held
   - Semi-transparent background for visibility

## World System
- Large 200x200 unit ground plane
- Distributed landscape elements (120 decorative objects)
- Strategic landmarks with 40 trees for navigation
- Safe spawn area with buffer zone
- Ample exploration space for mathematical discoveries

## File Structure
```
/
├── index.html          # Main HTML file
├── js/
│   ├── main.js        # Main game logic
│   ├── controls.js    # Movement and camera controls
│   ├── numberblock.js # Numberblock implementation
│   └── operator.js    # Operator system
├── css/
│   └── style.css      # Game styles
└── memory bank/
    ├── progress.md    # Implementation progress
    └── architecture.md # This file
```

## Initialization Flow
1. Load Three.js and custom scripts
2. Initialize WebGL renderer
3. Create scene and setup lighting
4. Create ground and environment
5. Initialize player Numberblock
6. Setup operator system
7. Initialize controls
8. Start animation loop

## Control Flow
1. User input captured via event listeners
2. Movement state updated
3. Controls updated in animation loop
4. Player position updated
5. Numberblock follows camera with offset
6. Scene rendered
7. Collision detection checks performed
8. Operator interactions processed
9. HUD information updated to reflect current state
10. Camera position dynamically adjusted based on Numberblock size

## Implemented Components
- Collision system for detecting Numberblock-to-Numberblock collisions
- Operator application mechanics for mathematical operations
- Operator pickup and attachment to Numberblock's hand
- Number operations via bumping interaction (plus/minus)
- Visual number updating with dynamic reconstruction
- Heads-up display (HUD) showing current player number
- Dynamic camera positioning system that adjusts based on Numberblock height
- Transparent materials for better visual presentation

## Future Components
- UI system
- Score tracking
- Game state management
- Multiple interactive Numberblocks
- More complex mathematical operations
 
 
----------------------------------------------------- 
FILE: memory bank\game design document.md 
----------------------------------------------------- 
 
Numberblocks FPS Game Design Document
Introduction
This document outlines the design for a multiplayer, browser-based, first-person perspective game inspired by the Numberblocks TV show. Players take on the role of Numberblocks, collect mathematical operators, and interact with other players to change their numerical values, aiming to achieve specific objectives in a fun and engaging way.
Overview
In this game, players navigate a colorful 3D world as Numberblocks, each representing a number. By collecting floating plus (+) and minus (-) operators and bumping into other players, they can add or subtract the other player's number from their own, altering their value. The game offers various modes, such as reaching a target number or eliminating opponents by reducing them to zero.
Core Mechanics
Player Movement
Players move in a first-person perspective with standard FPS controls:
WASD or arrow keys: Move forward, backward, left, and right.

Mouse: Look around.

Spacebar: Jump 

Operator Collection
Plus (+) and minus (-) operators spawn randomly across the game world.

Players collect an operator by running into it and can hold only one at a time.

Operators are visually distinct (e.g., a glowing "+" or "−") and float slightly above the ground.

Bumping Interaction
When a player with an operator bumps into another player, the operator is applied:
Plus Operator (+): The initiating player's number becomes their current number plus the other player's number (e.g., 3 + 2 = 5).

Minus Operator (-): The initiating player's number becomes their current number minus the other player's number (e.g., 3 - 2 = 1).

The other player's number remains unchanged.

The operator is consumed after use, requiring the player to collect a new one.

Number Changes
As a player's number changes, their character model updates:
Larger numbers grow in size (e.g., a Numberblock of 10 is bigger than one of 1).  The player's avatar is blocks that amount to their number.

Optional balancing: Larger numbers move slower but resist displacement, while smaller numbers are faster but more vulnerable.

Game World
Visual Style
The environment is bright, blocky, and inspired by the Numberblocks aesthetic.

Features include platforms, ramps, hiding spots, and open areas for player interaction.

Maps
Multiple themed maps:
Number Forest: Trees and terrain shaped like numbers.

Block City: A city of colorful block buildings.

Mathematical Playground: A playful area with slides and obstacles.

Maps encourage exploration and strategic positioning.

Interactive Elements
Some areas may require a specific number to access (e.g., a gate that opens only for players ≥ 10).

Player Characters
Appearance
Players are Numberblocks, with a block count matching their current number.  Their shape may be straight up, or rows of several blocks, or even arms and legs as the numbers get bigger.  But they are always made of blocks and their number is always visible.

The model dynamically adjusts as the number changes (e.g., growing from 1 block to 10 blocks).

Size and Speed (Optional)
Larger Numbers: Slower movement speed, harder to push.

Smaller Numbers: Faster movement, easier to displace.

This adds a layer of strategy to growing or shrinking.

Operators
Spawning
Operators appear at random intervals and locations on the map.

Spawn rates are balanced to ensure availability without overwhelming players.

Collection
Players collect an operator by touching it.

Collecting a new operator replaces the current one if the player is already holding one.

Usage
Operators activate automatically upon bumping into another player.

After use, the operator is consumed.

Game Objectives
The game supports multiple modes:
1. Target Number Mode
Objective: Reach a specific number (e.g., 100) by adding to your value.

The first player to hit the target wins.

2. Elimination Mode
Objective: Reduce other players to zero or below using the minus operator.

Players at zero or negative are eliminated; the last one standing wins.

3. Score-Based Mode
Objective: Earn points for each operation performed (e.g., +1 point per addition/subtraction).

The player with the most points at the end wins, tracked via a leaderboard.

Multiplayer Features
Real-Time Interaction
Multiple players inhabit the same world, interacting in real time.

Players can see each other's numbers and operators for strategic planning.

Teams (Optional)
Team modes allow collaboration, such as achieving the highest combined team number.

Handling Edge Cases
Zero or Negative Numbers
If a player's number reaches zero or below:
Respawn Option: They are out for 10 seconds, then return as 1.

Elimination Option: They are removed from the round (used in Elimination Mode).

Maximum Number Limit
A cap (e.g., 100) prevents excessive growth.

Optional: Larger numbers face rarer plus operators to slow their progress.

User Interface (UI)
Heads-Up Display (HUD)
Shows:
Player's current number.

Held operator (if any).

Optional: Score or mini-map.

Menus
Main Menu: Choose game mode, map, and settings.

Lobby: Join or create multiplayer matches.

Controls
Movement: WASD or arrow keys.

Look: Mouse.

Jump: Spacebar (if implemented).

Interact: Automatic via bumping.

Audio
Background Music: Upbeat, Numberblocks-inspired tunes.

Sound Effects:
Operator collection (e.g., a cheerful "ding").

Bumping (e.g., a soft "thud").

Number change (e.g., a growing/shrinking sound).

Technical Considerations
Platform
Browser-based, using WebGL for 3D rendering (e.g., Three.js).

Networking
Real-time multiplayer requires server-side syncing of:
Player positions. 

Numbers.

Operator states and spawns.

Optimization
Must run smoothly on various devices/browsers.

Efficient collision detection is key for bumping mechanics.

Future Features
Power-Ups: Shields (block operators) or speed boosts.

Advanced Operators: Multiplication/division for complexity (optional).

Customization: Unlockable colors or accessories for Numberblocks.

Educational Mode: Single-player math puzzles for kids.

Conclusion
This game combines the playful, educational charm of Numberblocks with dynamic FPS gameplay. Its simple mechanics make it accessible to children, while strategic depth and multiplayer fun appeal to all ages. With proper balancing and optimization, it can become an entertaining and educational browser-based experience.

 
 
----------------------------------------------------- 
FILE: memory bank\implementation plan.md 
----------------------------------------------------- 
 
Step 1: Set up the basic project structure
Task: Create a new project and set up the files needed for a Three.js-based game.

Details: 
Create an index.html file with a canvas element.

Add a styles.css file for basic styling (e.g., full-screen canvas).

Create a main.js file for JavaScript code.

Include the Three.js library via a CDN (e.g., <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>).

Test: 
Open the project in a browser.

Check that there are no console errors and a blank canvas appears.

Step 2: Create a basic 3D scene
Task: Set up a simple 3D scene with a ground plane and a camera.

Details: 
In main.js, create a Three.js scene, camera, and renderer.

Add a flat plane (e.g., a large box) as the ground.

Position the camera above the ground and render the scene.

Test: 
Open the project in a browser.

See the ground plane rendered from the camera’s perspective.

Step 3: Implement first-person camera controls
Task: Add first-person movement controls to the camera.

Details: 
Use Three.js’s FirstPersonControls or a custom controller.

Enable WASD keys for movement and mouse for looking around.

Test: 
Use WASD keys to move and the mouse to look around.

Confirm the controls are smooth and responsive.

Step 4: Create a basic Numberblock model
Task: Add a simple Numberblock model to the scene.

Details: 
Create a single cube to represent a Numberblock with the number 1.

Position it slightly above the ground in the scene.

Test: 
Open the project and see the cube in the scene.

Ensure it’s correctly positioned relative to the ground.

Step 5: Implement player movement
Task: Attach the Numberblock model to the camera and add basic movement.

Details: 
Link the cube’s position to the camera so it moves with it.

Add jumping (spacebar) and gravity to prevent falling through the ground.

Test: 
Move with WASD keys and see the cube move.

Press spacebar to jump and watch the cube rise and fall back to the ground.

Step 6: Add operator spawning
Task: Create and spawn plus (+) and minus (-) operators in the scene.

Details: 
Make simple 3D models (e.g., spheres) for operators, colored differently (e.g., green for +, red for -).

Write a function to spawn them randomly on the ground every few seconds.

Test: 
See operators appear over time at different spots.

Verify they sit on the ground, not floating or underground.

Step 7: Implement operator collection
Task: Allow the player to collect operators by touching them.

Details: 
Detect when the player’s Numberblock collides with an operator.

Remove the operator from the scene and store it as the player’s held operator (limit to one).

Test: 
Walk into an operator and see it disappear.

Confirm the player holds it (e.g., log it to the console or show it on-screen).

Step 8: Implement bumping interaction
Task: Enable bumping into another Numberblock to apply the operator.

Details: 
Add a second, static Numberblock with a fixed number (e.g., 2).

Detect collision with it; if the player has an operator, apply it (e.g., 1 + 2 = 3).

Remove the operator after use.

Test: 
Bump into the static Numberblock with an operator.

Check that the player’s number updates (e.g., from 1 to 3) and the operator is consumed.

Step 9: Update Numberblock model based on number
Task: Change the Numberblock model when its number changes.

Details: 
Write a function to stack cubes vertically based on the player’s number (e.g., 3 cubes for 3).

Update the model after a number change.

Test: 
After bumping and changing the number, see the model update (e.g., from 1 cube to 3).

Ensure it doesn’t clip through the ground.

Step 10: Implement basic HUD
Task: Add a heads-up display showing the player’s number and operator.

Details: 
Use HTML elements (e.g., <div>) overlayed on the canvas.

Update the HUD whenever the number or operator changes.

Test: 
See the player’s current number and held operator on-screen.

Verify it updates in real-time after changes.

Step 11: Add multiple players (multiplayer)
Task: Enable basic multiplayer functionality.

Details: 
Use WebSockets or Socket.io for networking.

Allow multiple players to join and see each other’s Numberblocks.

Sync positions and numbers across clients.

Test: 
Open two browser tabs as different players.

See each Numberblock move and confirm numbers sync when changed.

Step 12: Implement game objectives
Task: Add the Target Number Mode.

Details: 
Set a target number (e.g., 10).

Display a win message when a player reaches it.

Test: 
Play and reach the target number.

See a win message appear when achieved.

Step 13: Add more game modes
Task: Implement Elimination Mode and Score-Based Mode.

Details: 
Elimination Mode: Remove players whose number reaches zero or below.

Score-Based Mode: Award points for each operation, shown on a leaderboard.

Test: 
Test Elimination Mode: Reach zero and get removed or respawn.

Test Score-Based Mode: Perform operations and see points increase.

Step 14: Polish and optimize
Task: Enhance visuals, add audio, and improve performance.

Details: 
Add basic textures or colors to models.

Include sound effects (e.g., “ding” for collecting operators).

Optimize rendering for smooth gameplay.

Test: 
Play and ensure no lag or glitches.

Hear sound effects and see improved visuals.

Step 15: Add advanced features (optional)
Task: Introduce power-ups or advanced operators.

Details: 
Add a power-up (e.g., speed boost) that spawns like operators.

Optionally, include multiplication operators (e.g., ×2).

Test: 
Collect a power-up and see its effect (e.g., faster movement).

Use an advanced operator and verify the number change.

Conclusion
This implementation plan provides a clear, step-by-step roadmap to develop the Numberblocks FPS game. Each step is simple enough to be handled with a single prompt in the Windsurf IDE, and the accompanying tests ensure that each feature works before moving forward. By following this plan, you can progressively build a fully functional browser-based multiplayer game that aligns with the game design document’s vision.

 
 
----------------------------------------------------- 
FILE: memory bank\progress.md 
----------------------------------------------------- 
 
# Numberblocks Game - Progress Log

## March 15, 2025
- Completed Step 1 of implementation plan: Set up basic project structure
  - Created index.html with canvas element
  - Added styles.css for basic styling (full-screen canvas)
  - Created main.js for JavaScript code
  - Included Three.js library via CDN
  - Created directory structure following the architecture document
  - Verified that the project loads in browser with no console errors
- Created comprehensive README.md file
- Set up Git repository and GitHub remote
- Added .gitignore file for the project
- Completed Step 2 of implementation plan: Created a basic 3D scene
  - Implemented Three.js scene, camera, and renderer in main.js
  - Added a flat green plane as the ground
  - Positioned the camera above the ground
  - Added proper lighting (ambient and directional)
  - Implemented window resize handling
  - Set up the animation loop
- Completed Step 3 of implementation plan: Implemented first-person camera controls
  - Created controls.js for camera movement functionality
  - Implemented Three.js PointerLockControls for first-person view
  - Added WASD and arrow key movement
  - Implemented jumping with spacebar
  - Added controls info overlay for user guidance
  - Added appropriate styles for the overlay UI
  - Implemented robust fallback mechanism for environments where Pointer Lock API is unavailable
  - Added error handling with try-catch blocks for browser API compatibility
  - Created mockControls object that mimics the PointerLockControls interface for seamless operation
  - Enhanced FPS camera controls:
    - Added parent-child object hierarchy for proper camera rotation
    - Separated yaw (horizontal) and pitch (vertical) rotations for natural camera movement
    - Implemented pitch clamping to prevent camera flipping
    - Added mouse locking within the game window using CSS and event handling
    - Ensured proper cursor disengagement when ESC key is pressed
    - Implemented proper event listener cleanup for complete mouse control disengagement
  - Updated RULES.md with browser API considerations based on implementation experience
- Completed Step 4 of implementation plan: Created a basic Numberblock model
  - Implemented Numberblock class in numberblock.js with all required features:
    - Created a stack of blocks representing the Numberblock's value
    - Added face with eyes and mouth to the top block
    - Added arms on the sides (positioned based on number of blocks)
    - Added feet to the bottom block
    - Added a number tag on top showing the Numberblock's value
  - Used appropriate colors matching the Numberblocks TV show aesthetic
  - Integrated the Numberblock model with the main game:
    - Added the Numberblock to follow the player's movement
    - Positioned it in front of the camera for a first-person view
    - Implemented smooth interpolation for natural movement
    - Added HTML/CSS-based number display that follows the 3D model
  - Added helper functions for creating and updating Numberblocks
  - Added proper resource cleanup methods to prevent memory leaks
- Completed Step 5 of implementation plan: Implemented player movement (partial collision)
  - Added getHeight method to Numberblock class for accurate height calculation
  - Improved jumping mechanics with physically accurate jump formula
  - Implemented basic ground collision detection to prevent falling through the ground
  - Created true first-person view where camera positioned from Numberblock's perspective
  - Ensured perfect synchronization between camera and Numberblock during all movements
  - Implemented two-way position binding to maintain consistent camera-Numberblock relationship
  - Note: Full collision system with other objects not implemented yet
- Completed Step 6 of implementation plan: Added operator spawning
  - Created Operator and OperatorManager classes
  - Implemented operator spawning system
  - Added proper positioning and rotation
  - Integrated with player controls
  - Fixed movement controls after operator integration
  - Ensured proper initialization order
- Completed Step 7 of implementation plan: Implemented operator collection
  - Added collision detection between player's Numberblock and operators
  - Created visual attachment system to make operators attach to Numberblock's hand
  - Modified Numberblock.createArm method to name hand objects for reference
  - Enhanced OperatorManager.setHeldOperator to attach operators to the Numberblock
  - Created smaller version (40% scale) of operator for holding
  - Added robust error handling in collision detection to prevent game freezes
  - Properly integrated collision.js with the rest of the codebase
  - Implemented fallback collision functions for improved stability
- Completed Step 8 of implementation plan: Implemented bumping interaction
  - Added a second static Numberblock to the scene with value 2
  - Implemented collision detection between player and static Numberblock
  - Created logic to apply held operators (plus/minus) when collision occurs
  - Added mathematical operations based on operator type:
    - Plus operator: player.value += staticNumberblock.value
    - Minus operator: player.value -= staticNumberblock.value (with minimum value check)
  - Added visual feedback with immediate Numberblock reconstruction
  - Implemented operator consumption after successful application
  - Added player pushback to prevent continuous collisions
  - Enhanced UI feedback with console logs and visual updates
  - Added error handling for collision detection to prevent game freezes

### Step 9: Update Numberblock Model & Add HUD (Completed March 15, 2025)
- **Updated Numberblock Model**
  - Verified that the Numberblock model correctly updates its visual representation after mathematical operations
  - Enhanced the camera positioning to dynamically adjust based on Numberblock size
  - Fixed visual artifacts and rendering issues with number tags
  - Implemented double-sided transparent materials for better visibility
  
- **Added Basic HUD**
  - Created a heads-up display showing the player's current number in the top-right corner
  - Styled the HUD with semi-transparent background and clear typography
  - Ensured the HUD updates in real-time when the player's number changes
  - Made the HUD non-intrusive with pointer-events set to none

## March 16, 2025
- Improved HUD display:
  - Added clear number display in top-left that changes color based on Numberblock value
  - Added operator display in top-right showing "+ Add" or "- Subtract"
  - Added semi-transparent backgrounds and text shadows for better visibility
  - Removed duplicate displays for cleaner UI
- Fixed Numberblock positioning:
  - All Numberblocks now properly stand on the ground
  - Fixed positioning for random shapes and objects
  - Improved Y-position calculations for consistent placement
- Removed redundant number tags from Numberblocks since value is shown in HUD
- Enhanced control system:
  - Added Q and E key functionality for turning left and right in first-person view
  - Set appropriate rotation speed for smooth turning experience
  - Maintained backward compatibility with mouse controls
- Expanded game world:
  - Increased ground size from 50x50 to 200x200 units (16x larger play area)
  - Added more decorative objects (from 30 to 120) to maintain visual density
  - Increased trees from 10 to 40 for better landmarks
  - Expanded spawn protection area for better player experience

## Next Steps
- Step 10: Add math puzzles and challenges 
 
----------------------------------------------------- 
FILE: memory bank\RULES.md 
----------------------------------------------------- 
 
# Development Rules and Notes

## PowerShell Command Issues

### Directory Creation
- When creating multiple directories at once with PowerShell's `mkdir` command, you must use quotes when specifying paths with spaces or multiple directories:
  ```
  # INCORRECT (will fail):
  mkdir css js assets assets\images assets\models assets\sounds
  
  # CORRECT (individual commands):
  mkdir css
  mkdir js
  mkdir assets
  mkdir "assets\images"
  mkdir "assets\models"
  mkdir "assets\sounds"
  ```

- PowerShell's `mkdir` doesn't support multiple directory arguments like in Linux/macOS. Create directories one by one or use a loop.

## Server Management and Development Workflow

### Restarting the Development Server
- When making changes to JavaScript files, use the following process to restart the server for clean testing:
  ```powershell
  # 1. Kill any running Node.js server instances (prevents port conflicts)
  taskkill /f /im node.exe
  
  # 2. Start the http-server with cache disabled
  npx http-server -c-1
  ```
- The `-c-1` flag disables caching, ensuring that file changes are immediately visible
- Always kill previous instances of the server to avoid potential port conflicts
- Using `taskkill /f /im node.exe` is more reliable than Ctrl+C which sometimes leaves orphaned processes

## Three.js Implementation Notes

- Always include the Three.js library before your own JavaScript files in the HTML
- When testing, make sure to run a local HTTP server rather than opening the HTML file directly due to CORS restrictions with resource loading
- Use a thin BoxGeometry instead of PlaneGeometry for the ground to ensure proper lighting on both sides
- Always implement window resize handling for responsive design (update camera aspect ratio and renderer size)
- For better performance, set renderer.setPixelRatio to match the device's pixel ratio

## Browser API Considerations

- The Pointer Lock API (used by PointerLockControls) may not work in some environments, especially in embedded preview browsers or when served through certain proxies
- Always implement a fallback mechanism for critical browser APIs in case they fail
- Use try-catch blocks around browser API calls that might not be supported in all environments
- Check browser console for API-related errors when testing in different environments
- When implementing mouse controls:
  - Proper event listener management is essential (add/remove listeners appropriately)
  - Always provide visual feedback when controls are locked/unlocked
  - Ensure complete disengagement of controls when user presses ESC

## JavaScript Considerations

- When using event handlers, store references to them for proper removal later to prevent memory leaks
- For event-based systems (like controls), implement a proper event dispatcher mechanism
- Use class-based or module patterns for complex components to keep code organized
- When dealing with 3D rotations:
  - Separate axes of rotation (yaw, pitch, roll) to prevent gimbal lock issues
  - Always clamp vertical rotation (pitch) to prevent camera flipping

## Git Workflow

- Always update the progress.md file after completing each implementation step
- Keep commit messages descriptive and related to the implementation plan steps

## Project Structure

- Follow the architecture document precisely to ensure consistency
- New JavaScript files should be placed in the js/ directory and then linked in index.html as needed 
 
----------------------------------------------------- 
FILE: memory bank\tech stack.md 
----------------------------------------------------- 
 
Tech Stack
Front-End
HTML5: Provides the structure for the game, including the canvas element for 3D rendering and UI components like the heads-up display (HUD) and menus.

CSS3: Styles the UI elements, such as the HUD, player stats, and overlays, ensuring they look polished and are positioned correctly over the game canvas.

JavaScript (ES6+): Drives the game logic, handling player movement, operator collection, real-time updates, and interactions between Numberblocks.

Three.js: A JavaScript library that simplifies WebGL for 3D rendering, used to create the game world, dynamic Numberblock models (e.g., stacks of cubes), and themed maps like Number Forest or Block City.

Web Audio API: Manages audio, including sound effects for actions like bumping into players or collecting operators, and optional background music for immersion.

Back-End
Node.js: Acts as the server-side runtime, serving static files (HTML, CSS, JavaScript) and managing game logic for multiplayer sessions, such as validating player actions and maintaining game state authority.

Socket.io: Facilitates real-time, bidirectional communication between players, syncing positions, numbers, and operator states for a seamless multiplayer experience.

Development Tools
Git: Version control system to track changes, collaborate with others (if applicable), and manage the project’s codebase effectively.

Local Server: A simple server like http-server or Node.js’s built-in http module for testing the game locally during development, simulating both single-player and multiplayer scenarios.

Jest (Optional): A JavaScript testing framework to verify game logic (e.g., operator interactions, collision detection), which can be added as the project scales.

Hosting
Heroku (or similar platforms like AWS, DigitalOcean): Hosts the Node.js application, serving both the front-end assets and WebSocket connections for multiplayer functionality, offering a straightforward deployment solution.

Why This Stack?
Front-End: HTML, CSS, and JavaScript are core web technologies, making them essential for a browser-based game. Three.js provides an accessible way to render 3D graphics, while the Web Audio API ensures robust audio support.

Back-End: Node.js integrates seamlessly with JavaScript and Socket.io, offering a lightweight yet powerful solution for real-time multiplayer features like position syncing and player interactions.

Development Tools: Git is a standard for version control, and a local server simplifies testing. Jest is optional but recommended for ensuring reliability as complexity grows.

Hosting: Heroku supports Node.js and WebSocket applications out of the box, making it an ideal choice for deploying the full game (front-end and back-end) in one place.

This tech stack aligns with your project’s needs: a browser-based, multiplayer 3D FPS game with dynamic Numberblock characters, real-time interactions, and themed environments. It’s lightweight, scalable, and leverages widely-used web technologies. Let me know if you’d like more details on any component!

 
 
===================================================== 
FILE: debug-test.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numberblocks Debug Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #debug-canvas { width: 100%; height: 100%; display: block; }
        #debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            z-index: 1000;
            max-width: 400px;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <canvas id="debug-canvas"></canvas>
    <div id="debug-info">Loading...</div>
    
    <!-- Load Three.js library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    
    <script>
        // Debug log function
        function log(message) {
            console.log(message);
            const debugInfo = document.getElementById('debug-info');
            debugInfo.innerHTML += `<div>${message}</div>`;
        }
        
        // Error handler
        window.onerror = function(message, source, lineno, colno, error) {
            log(`ERROR: ${message} at ${source}:${lineno}`);
            return false;
        };
        
        // Initialize everything
        window.addEventListener('load', () => {
            log('Page loaded, initializing Three.js');
            
            // Check if Three.js is available
            if (typeof THREE === 'undefined') {
                log('ERROR: THREE is not defined! Check network connection or CDN link.');
                return;
            }
            
            log(`THREE.js version ${THREE.REVISION} loaded successfully`);
            
            try {
                // Create scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue
                log('Scene created with blue background');
                
                // Create camera
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 0, 0);
                log(`Camera created at position (${camera.position.x}, ${camera.position.y}, ${camera.position.z})`);
                
                // Create renderer
                const canvas = document.getElementById('debug-canvas');
                if (!canvas) {
                    log('ERROR: Canvas element not found!');
                    return;
                }
                
                const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                log('Renderer created and attached to canvas');
                
                // Check if renderer is working properly
                if (!renderer.domElement) {
                    log('ERROR: Renderer domElement is not available!');
                    return;
                }
                
                // Create a simple ground plane
                const groundGeometry = new THREE.BoxGeometry(50, 0.1, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x7CFC00, // Green
                    roughness: 0.8, 
                    metalness: 0.2 
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.position.y = -0.05;
                scene.add(ground);
                log('Ground plane added to scene');
                
                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                // Add directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                scene.add(directionalLight);
                log('Lights added to scene');
                
                // Add a visible object to confirm rendering
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.set(0, 1, 0);
                scene.add(cube);
                log('Red cube added to center of scene for visibility test');
                
                // Testing WebGL capabilities
                log('WebGL Capabilities:');
                const gl = renderer.getContext();
                log(`Max texture size: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}`);
                log(`WebGL version: ${gl.getParameter(gl.VERSION)}`);
                log(`Renderer: ${gl.getParameter(gl.RENDERER)}`);
                log(`Vendor: ${gl.getParameter(gl.VENDOR)}`);
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    // Rotate the cube to make it obvious if rendering is working
                    cube.rotation.x += 0.01;
                    cube.rotation.y += 0.01;
                    
                    // Render the scene
                    renderer.render(scene, camera);
                }
                
                // Start animation
                animate();
                log('Animation loop started');
                
                // Add window resize handler
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    log('Window resized, canvas adjusted');
                });
                
                log('Debug test initialization complete, you should see a rotating red cube');
            } catch (e) {
                log(`CRITICAL ERROR: ${e.message}`);
                log(`Stack trace: ${e.stack}`);
            }
        });
    </script>
</body>
</html>
 
 
===================================================== 
FILE: index.html 
===================================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numberblocks Game</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <canvas id="game-canvas"></canvas>
    
    <div id="controls-info" class="overlay">
        <h2>Numberblocks Game</h2>
        <p>Click anywhere to enable controls</p>
        <ul>
            <li>Move: WASD or Arrow Keys</li>
            <li>Jump: Space</li>
            <li>Look: Mouse</li>
        </ul>
    </div>
    
    <!-- Game HUD -->
    <div id="game-hud" class="hud">
    </div>
    
    <!-- Three.js library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    
    <!-- Game JavaScript files -->
    <script src="js/collision.js"></script>
    <script src="js/controls.js"></script>
    <script src="js/numberblock.js"></script>
    <script src="js/operator.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
 
 
===================================================== 
FILE: css\styles.css 
===================================================== 
 
/* Reset default margins and padding */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
}

body, html {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background-color: #000;
}

/* Make the canvas fill the entire screen */
#game-canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* Fix for horizontal bar issue - ensuring no elements create unwanted artifacts */
canvas {
    position: fixed;
    top: 0;
    left: 0;
    outline: none;
}

/* Controls info overlay */
.overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    z-index: 100;
}

.overlay h2 {
    margin-bottom: 10px;
}

.overlay p {
    margin-bottom: 15px;
}

.overlay ul {
    list-style-type: none;
    text-align: left;
    margin: 0 auto;
    display: inline-block;
}

.overlay ul li {
    margin-bottom: 5px;
}

/* Game HUD */
.hud {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 10;
    color: white;
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.8);
    background-color: rgba(0, 0, 0, 0.5);
    padding: 10px 15px;
    border-radius: 8px;
    pointer-events: none; /* Allow clicking through the HUD */
}

#player-number-display {
    display: flex;
    align-items: center;
    justify-content: flex-end;
}

#player-value {
    margin-left: 5px;
    font-size: 32px;
}

/* Ensure no overflow elements */
body, html, canvas {
    overflow: hidden;
}
 
 
===================================================== 
FILE: js\collision.js 
===================================================== 
 
/**
 * Numberblocks AABB Collision System
 * Uses Axis-Aligned Bounding Boxes for efficient collision detection
 */

// Collection of collidable objects
let collidableObjects = [];
let debugMode = true; // Set to true to see debug logging

// Initialize collision system and collect collidable objects from the scene
function initCollisionSystem(scene) {
    console.log("Initializing collision system...");
    collidableObjects = [];
    
    // Traverse the scene to find all collidable objects
    scene.traverse((object) => {
        if (object.isMesh && object.userData && object.userData.collidable === true) {
            collidableObjects.push(object);
            if (debugMode) console.log(`Added collidable object: ${object.name || 'unnamed object'}`);
        }
    });
    
    console.log(`Collision system initialized with ${collidableObjects.length} collidable objects`);
    return collidableObjects.length;
}

// Add a single object to the collidable objects list
function addCollidableObject(object) {
    if (!object || !(object.isMesh || object.isGroup)) return;
    
    // Mark the object as collidable
    object.userData = object.userData || {};
    object.userData.collidable = true;
    
    // Add a name if it doesn't have one for easier debugging
    if (!object.name) {
        object.name = `collidable_${collidableObjects.length}`;
    }
    
    // Only add if not already in the list
    if (!collidableObjects.includes(object)) {
        collidableObjects.push(object);
        if (debugMode) console.log(`Added collidable object: ${object.name}`);
        
        // If it's a group, also make all children collidable
        if (object.isGroup && object.children) {
            object.children.forEach(child => {
                if (child.isMesh) {
                    child.userData = child.userData || {};
                    child.userData.collidable = true;
                    collidableObjects.push(child);
                    if (debugMode) console.log(`Added child collidable object: ${child.name || 'unnamed child'}`);
                }
            });
        }
    }
}

// Create or update a bounding box for a mesh
function updateAABB(mesh) {
    if (!mesh) return null;
    
    // Use Three.js Box3 to create a bounding box from the mesh
    const box = new THREE.Box3().setFromObject(mesh);
    return box;
}

// Check if two bounding boxes intersect
function checkCollision(boxA, boxB) {
    if (!boxA || !boxB) return false;
    return boxA.intersectsBox(boxB);
}

// Get the minimum translation vector to resolve a collision
function getCollisionResponse(boxA, boxB) {
    // Create a box that represents the intersection
    const intersection = new THREE.Box3();
    intersection.copy(boxA).intersect(boxB);
    
    // Get the size of the intersection
    const size = intersection.getSize(new THREE.Vector3());
    
    // Find the minimum penetration axis (x, y, or z)
    let axis, minSize;
    
    if (size.x <= size.y && size.x <= size.z) {
        axis = 'x';
        minSize = size.x;
    } else if (size.y <= size.x && size.y <= size.z) {
        axis = 'y';
        minSize = size.y;
    } else {
        axis = 'z';
        minSize = size.z;
    }
    
    // Return the direction and amount to move
    const response = {
        axis: axis,
        depth: minSize,
        direction: new THREE.Vector3()
    };
    
    // Calculate the direction to move (away from the obstacle)
    const centerA = boxA.getCenter(new THREE.Vector3());
    const centerB = boxB.getCenter(new THREE.Vector3());
    
    if (axis === 'x') {
        response.direction.x = centerA.x < centerB.x ? -1 : 1;
    } else if (axis === 'y') {
        response.direction.y = centerA.y < centerB.y ? -1 : 1;
    } else {
        response.direction.z = centerA.z < centerB.z ? -1 : 1;
    }
    
    return response;
}

// Check collisions for the player against all collidable objects
function checkPlayerCollisions(playerMesh, controlsObject) {
    if (!playerMesh || !controlsObject || collidableObjects.length === 0) {
        return { collision: false, grounded: false };
    }
    
    // Update player bounding box
    const playerBox = updateAABB(playerMesh);
    let hasCollision = false;
    let isGrounded = false;
    
    // Check against all collidable objects
    for (const obstacle of collidableObjects) {
        // Skip player's own mesh
        if (obstacle === playerMesh) continue;
        
        const obstacleBox = updateAABB(obstacle);
        if (checkCollision(playerBox, obstacleBox)) {
            hasCollision = true;
            if (debugMode) console.log(`Collision detected with ${obstacle.name || 'unnamed object'}`);
            
            // Handle the collision and check if we're standing on something
            const collisionResult = handleCollision(playerBox, obstacleBox, controlsObject);
            if (collisionResult.landedOnTop) {
                isGrounded = true;
            }
        }
    }
    
    return { collision: hasCollision, grounded: isGrounded };
}

// Apply collision response and return collision info
function handleCollision(playerBox, obstacleBox, controlsObject) {
    const response = getCollisionResponse(playerBox, obstacleBox);
    
    // Apply a small buffer to prevent getting stuck
    const buffer = 0.1;
    let landedOnTop = false;
    
    // Apply the collision response to the controls object
    if (response.axis === 'x') {
        controlsObject.position.x += (response.depth + buffer) * response.direction.x;
    } else if (response.axis === 'y') {
        // For Y-axis collisions, we need to determine if we landed on top
        if (response.direction.y > 0) {
            // We hit the bottom of something
            controlsObject.position.y += (response.depth + buffer) * response.direction.y;
        } else {
            // We landed on top of something
            controlsObject.position.y += (response.depth + buffer) * response.direction.y;
            landedOnTop = true;
            
            // Stop any downward velocity if we're using physics
            if (controlsObject.userData && controlsObject.userData.velocity) {
                controlsObject.userData.velocity.y = 0;
            }
        }
    } else {
        controlsObject.position.z += (response.depth + buffer) * response.direction.z;
    }
    
    return { landedOnTop };
}

// Mark objects in the scene as collidable
function markAllObjectsAsCollidable(scene) {
    scene.traverse(object => {
        // Skip the player, camera, lights, and ground
        if (object.name === 'ground' || 
            object.name === 'player' || 
            object.isLight || 
            object.isCamera) {
            return;
        }
        
        // Mark all meshes that aren't the player, lights, or ground as collidable
        if (object.isMesh) {
            object.userData = object.userData || {};
            object.userData.collidable = true;
            
            // Add it to our collidable objects array if not already there
            if (!collidableObjects.includes(object)) {
                collidableObjects.push(object);
                if (debugMode) console.log(`Auto-marked as collidable: ${object.name || 'unnamed mesh'}`);
            }
        }
    });
    
    console.log(`Total collidable objects after auto-marking: ${collidableObjects.length}`);
}

// No modules export - functions are accessible globally for traditional script inclusion
 
 
===================================================== 
FILE: js\controls.js 
===================================================== 
 
// Numberblocks game - First-person controls implementation

// Global variables
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let turnLeft = false;    // New variable for Q key turning
let turnRight = false;   // New variable for E key turning
let canJump = false;
let pitch = 0;  // Track vertical rotation separately
// isFirstPerson is a global variable attached to the window object in main.js

let prevTime = performance.now();
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();

// Player settings
const playerHeight = 2.0;             // Height of camera from ground
const moveSpeed = 5.0;                // Units per second
const turnSpeed = 2.0;                // Rotation speed for Q/E turning
const jumpHeight = 5.0;               // Jump impulse force
const gravity = 9.8;                  // Gravity force 

// Initialize controls for the camera
window.initControls = function(camera, domElement) {
    console.log("Initializing PointerLockControls properly...");

    const controls = new THREE.PointerLockControls(camera, domElement);

    domElement.addEventListener('click', () => {
        controls.lock();
    });

    controls.addEventListener('lock', () => {
        document.getElementById('controls-info').style.display = 'none';
    });

    controls.addEventListener('unlock', () => {
        document.getElementById('controls-info').style.display = 'block';
    });

    // Keyboard listeners for movement remain as-is
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    return controls;
}

// Key down event handler
function onKeyDown(event) {
    // Skip if we're in an input field or textarea
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
        return;
    }
    
    // Map key code to action
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = true;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = true;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = true;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            moveRight = true;
            break;
            
        case 'KeyQ':
            turnLeft = true;
            break;
            
        case 'KeyE':
            turnRight = true;
            break;
            
        case 'Space':
            if (canJump) {
                // Apply a physically accurate jump velocity
                velocity.y = Math.sqrt(jumpHeight * 2 * gravity);
                canJump = false;
            }
            break;
    }
}

// Key up event handler
function onKeyUp(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = false;
            break;
            
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = false;
            break;
            
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = false;
            break;
            
        case 'ArrowRight':
        case 'KeyD':
            moveRight = false;
            break;
            
        case 'KeyQ':
            turnLeft = false;
            break;
            
        case 'KeyE':
            turnRight = false;
            break;
    }
}

// Update controls - call this in the animation loop
window.updateControls = function(controls, delta) {
    if (!controls.isLocked) return;

    if (moveForward) controls.moveForward(moveSpeed * delta);
    if (moveBackward) controls.moveForward(-moveSpeed * delta);
    if (moveLeft) controls.moveRight(-moveSpeed * delta);
    if (moveRight) controls.moveRight(moveSpeed * delta);
    
    // Proper on-axis rotation using the PointerLockControls object's quaternion
    if (turnLeft || turnRight) {
        // Create rotation quaternion for Q/E rotation
        const rotationAngle = (turnLeft ? 1 : -1) * turnSpeed * delta;
        const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(0, 1, 0), // Rotate around y-axis only
            rotationAngle
        );
        
        // Apply rotation to controls object's quaternion
        controls.getObject().quaternion.premultiply(rotationQuaternion);
    }

    velocity.y -= gravity * delta;
    controls.getObject().position.y += velocity.y * delta;

    if (controls.getObject().position.y < playerHeight) {
        velocity.y = 0;
        controls.getObject().position.y = playerHeight;
        canJump = true;
    }
}
 
 
===================================================== 
FILE: js\main.js 
===================================================== 
 
// Numberblocks game - Three.js implementation
console.log('Numberblocks game initializing...');

// Import collision functions if they're not already globally available
if (typeof updateAABB !== 'function' || typeof checkCollision !== 'function') {
    console.log('Importing collision functions...');
    
    // Define the functions locally if they're not available globally
    function updateAABB(mesh) {
        if (!mesh) return null;
        
        // Use Three.js Box3 to create a bounding box from the mesh
        try {
            const box = new THREE.Box3().setFromObject(mesh);
            return box;
        } catch (error) {
            console.error("Error creating bounding box:", error);
            return null;
        }
    }

    function checkCollision(boxA, boxB) {
        if (!boxA || !boxB) return false;
        try {
            return boxA.intersectsBox(boxB);
        } catch (error) {
            console.error("Error checking collision:", error);
            return false;
        }
    }
}

// Global variables
let scene, camera, renderer, controls;
let ground;
let playerNumberblock; // Player's Numberblock
let staticNumberblock; // Static Numberblock for interaction
let operatorManager; // Operator system manager
let numberblocks = []; // Array to track random Numberblocks
let operatorDisplay; // Add operator display element
window.isFirstPerson = true; // Make isFirstPerson truly global by attaching to window

// Initialize the Three.js scene
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky blue background
    
    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    
    renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('game-canvas'),
        antialias: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    createGround();
    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);
    
    // Add landscape elements for perspective
    createLandscapeElements();
    
    // Create player's Numberblock
    playerNumberblock = createPlayerNumberblock(scene, 1);

    // Initialize the HUD display with the starting value
    updatePlayerDisplay(1);
    
    // Create static Numberblock for operator application
    staticNumberblock = createStaticNumberblock(2, { x: 0, z: -5 });
    console.log("Static Numberblock created with value: 2");

    // Initialize operator system
    window.camera = camera; // Make camera available for operator billboarding
    operatorManager = new OperatorManager(scene);

    // Initialize FPS controls with proper look
    controls = initControls(camera, renderer.domElement);
    
    // CRITICAL FIX: Explicitly set position on controls object (not camera directly)
    controls.getObject().position.set(0, 2, 5);
    scene.add(controls.getObject());
    
    // Initialize collision detection
    if (typeof addCollidableObject === 'function') {
        addCollidableObject(playerNumberblock.mesh);
        addCollidableObject(staticNumberblock.mesh);
        console.log("Collision objects registered");
    } else {
        console.error("Collision functions not available!");
    }
    
    clock = new THREE.Clock();
    window.addEventListener('resize', onWindowResize);
    
    // CRITICAL FIX: Explicitly call onWindowResize to ensure camera's projection matrix is correct initially
    onWindowResize();
    
    // Create HUD elements
    createHUD();
    
    // Create random Numberblocks around the map
    createRandomNumberblocks();
    
    animate();
}

// Create the ground plane
function createGround() {
    // Create a large flat plane for the ground
    const groundGeometry = new THREE.BoxGeometry(200, 0.1, 200);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x7CFC00, // Lawn green color
        roughness: 0.8,
        metalness: 0.2
    });
    
    ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.05; // Move it slightly down to center it
    scene.add(ground);
}

// Create random landscape elements for perspective
function createLandscapeElements() {
    // Define bright colors that match Numberblocks aesthetic
    const colors = [
        0xFF0000, // Red (One)
        0xFFA500, // Orange (Two)
        0xFFFF00, // Yellow (Three)
        0x00FF00, // Green (Four)
        0x0000FF, // Blue (Five)
        0x800080, // Purple (Six)
        0xFFC0CB, // Pink (Seven)
        0xA52A2A, // Brown (Eight)
        0x808080  // Grey (Nine)
    ];
    
    // Create 120 random objects (increased from 30 for the larger world)
    for (let i = 0; i < 120; i++) {
        let geometry, material, mesh;
        const shapeType = Math.floor(Math.random() * 4); // 0-3 for different shapes
        const colorIndex = Math.floor(Math.random() * colors.length);
        const color = colors[colorIndex];
        
        // Create different shapes
        switch (shapeType) {
            case 0: // Cube (like Numberblock parts)
                const size = 0.5 + Math.random() * 1.5;
                geometry = new THREE.BoxGeometry(size, size, size);
                break;
            case 1: // Cylinder
                const radius = 0.3 + Math.random() * 1;
                const height = 1 + Math.random() * 3;
                geometry = new THREE.CylinderGeometry(radius, radius, height, 16);
                break;
            case 2: // Sphere
                const sphereRadius = 0.5 + Math.random() * 1;
                geometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
                break;
            case 3: // Cone
                const coneRadius = 0.5 + Math.random() * 1;
                const coneHeight = 1 + Math.random() * 2;
                geometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
                break;
        }
        
        // Create material with random color
        material = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        // Create and position the mesh
        mesh = new THREE.Mesh(geometry, material);
        
        // Position randomly on the ground plane (within a 180x180 area)
        // Keep away from center where player spawns
        let posX, posZ;
        do {
            posX = (Math.random() * 180) - 90;
            posZ = (Math.random() * 180) - 90;
        } while (Math.abs(posX) < 8 && Math.abs(posZ) < 8); // Increased spawn area protection
        
        mesh.position.set(posX, 0, posZ);
        
        // Add random rotation for more variety
        mesh.rotation.y = Math.random() * Math.PI * 2;
        
        // Add to scene
        scene.add(mesh);
    }
    
    // Add some trees as landmarks
    createTrees();
}

// Create simple trees as landmarks
function createTrees() {
    for (let i = 0; i < 40; i++) {
        // Create trunk
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 2, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513, // Brown
            roughness: 0.9
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        
        // Create foliage (as a cone)
        const foliageGeometry = new THREE.ConeGeometry(1.5, 3, 8);
        const foliageMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22, // Forest green
            roughness: 0.8
        });
        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
        foliage.position.y = 2.5; // Position on top of trunk
        
        // Create tree group
        const tree = new THREE.Group();
        tree.add(trunk);
        tree.add(foliage);
        
        // Position randomly on the ground plane but away from center
        let posX, posZ, distance;
        do {
            posX = (Math.random() * 180) - 90;
            posZ = (Math.random() * 180) - 90;
            distance = Math.sqrt(posX * posX + posZ * posZ);
        } while (distance < 10); // Keep trees away from spawn point
        
        tree.position.set(posX, 1, posZ); // Position with trunk base on ground
        
        // Add to scene
        scene.add(tree);
    }
}

// Create HUD elements
function createHUD() {
    // Player's number display
    const valueDisplay = document.createElement('div');
    valueDisplay.id = 'value-display';
    valueDisplay.style.position = 'absolute';
    valueDisplay.style.bottom = '20px';
    valueDisplay.style.left = '20px';
    valueDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    valueDisplay.style.color = 'white';
    valueDisplay.style.padding = '10px 20px';
    valueDisplay.style.borderRadius = '5px';
    valueDisplay.style.fontFamily = 'Arial, sans-serif';
    valueDisplay.style.fontSize = '24px';
    valueDisplay.style.fontWeight = 'bold';
    valueDisplay.innerHTML = 'Value: 1';
    document.body.appendChild(valueDisplay);

    // Operator display
    operatorDisplay = document.createElement('div');
    operatorDisplay.id = 'operator-display';
    operatorDisplay.style.position = 'absolute';
    operatorDisplay.style.bottom = '20px';
    operatorDisplay.style.right = '20px';
    operatorDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    operatorDisplay.style.color = 'white';
    operatorDisplay.style.padding = '10px 20px';
    operatorDisplay.style.borderRadius = '5px';
    operatorDisplay.style.fontFamily = 'Arial, sans-serif';
    operatorDisplay.style.fontSize = '24px';
    operatorDisplay.style.fontWeight = 'bold';
    operatorDisplay.innerHTML = 'Current Operator: None';
    document.body.appendChild(operatorDisplay);
    
    // View mode display
    const viewModeDisplay = document.createElement('div');
    viewModeDisplay.id = 'view-mode-display';
    viewModeDisplay.style.position = 'absolute';
    viewModeDisplay.style.top = '20px';
    viewModeDisplay.style.left = '50%';
    viewModeDisplay.style.transform = 'translateX(-50%)';
    viewModeDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    viewModeDisplay.style.color = 'white';
    viewModeDisplay.style.padding = '10px 20px';
    viewModeDisplay.style.borderRadius = '5px';
    viewModeDisplay.style.fontFamily = 'Arial, sans-serif';
    viewModeDisplay.style.fontSize = '20px';
    viewModeDisplay.style.fontWeight = 'bold';
    viewModeDisplay.style.transition = 'opacity 1s';
    viewModeDisplay.style.opacity = '0';
    viewModeDisplay.innerHTML = 'First Person View';
    document.body.appendChild(viewModeDisplay);
}

// Update the player's number display in the HUD
function updatePlayerDisplay(value) {
    const valueDisplay = document.getElementById('value-display');
    if (valueDisplay) {
        valueDisplay.innerHTML = `Value: ${value}`;
    }
}

// Update operator display
function updateOperatorDisplay(operatorType) {
    if (operatorDisplay) {
        if (operatorType) {
            operatorDisplay.innerHTML = operatorType === 'plus' ? '+ Add' : '- Subtract';
            operatorDisplay.style.color = operatorType === 'plus' ? '#00FF00' : '#FF0000';
        } else {
            operatorDisplay.innerHTML = 'Current Operator: None';
            operatorDisplay.style.color = 'white';
        }
    }
}

// Create random Numberblocks around the map
function createRandomNumberblocks() {
    const numBlocks = 15; // Create 15 random Numberblocks
    
    for (let i = 0; i < numBlocks; i++) {
        // Create a Numberblock with random value between 1 and 20
        const value = Math.floor(Math.random() * 20) + 1;
        const numberblock = new Numberblock(value);
        
        // Position randomly, away from player spawn
        let posX, posZ;
        do {
            posX = (Math.random() * 40) - 20;
            posZ = (Math.random() * 40) - 20;
        } while (
            Math.abs(posX) < 5 && 
            Math.abs(posZ) < 5
        );
        
        // Position the Numberblock with its base at ground level
        numberblock.mesh.position.set(posX, numberblock.blockSize / 2, posZ);
        scene.add(numberblock.mesh);
        numberblocks.push(numberblock);
        
        if (typeof addCollidableObject === 'function') {
            addCollidableObject(numberblock.mesh);
        }
    }
}

// Create a static Numberblock for testing
function createStaticNumberblock(value = 2, position = { x: 0, z: -5 }) {
    const numberblock = new Numberblock(value);
    numberblock.mesh.position.set(position.x, numberblock.blockSize / 2, position.z);
    scene.add(numberblock.mesh);
    return numberblock;
}

// Create random shapes for the landscape
function createRandomShapes() {
    const numShapes = 30;
    const shapes = [];
    
    for (let i = 0; i < numShapes; i++) {
        let geometry, mesh;
        const shapeType = Math.floor(Math.random() * 4); // 0: cube, 1: cylinder, 2: sphere, 3: cone
        
        // Create random shape
        switch (shapeType) {
            case 0: // Cube
                geometry = new THREE.BoxGeometry(1, 1, 1);
                break;
            case 1: // Cylinder
                geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
                break;
            case 2: // Sphere
                geometry = new THREE.SphereGeometry(0.5, 16, 16);
                break;
            case 3: // Cone
                geometry = new THREE.ConeGeometry(0.5, 1, 16);
                break;
        }
        
        // Create material with random color
        const material = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xFFFFFF,
            roughness: 0.7,
            metalness: 0.3
        });
        
        mesh = new THREE.Mesh(geometry, material);
        
        // Position randomly on the ground plane (within a 40x40 area)
        // Keep away from center where player spawns
        let posX, posZ;
        do {
            posX = (Math.random() * 40) - 20;
            posZ = (Math.random() * 40) - 20;
        } while (
            Math.abs(posX) < 5 && 
            Math.abs(posZ) < 5
        );
        
        // Calculate Y position based on the shape's height
        let posY;
        if (shapeType === 0) { // Cube
            posY = mesh.geometry.parameters.height / 2;
        } else if (shapeType === 1) { // Cylinder
            posY = mesh.geometry.parameters.height / 2;
        } else if (shapeType === 2) { // Sphere
            posY = mesh.geometry.parameters.radius;
        } else { // Cone
            posY = mesh.geometry.parameters.height / 2;
        }
        
        mesh.position.set(posX, posY, posZ);
        
        // Add random rotation for more variety
        mesh.rotation.y = Math.random() * Math.PI * 2;
        
        scene.add(mesh);
        shapes.push(mesh);
        
        // Make it collidable
        if (typeof addCollidableObject === 'function') {
            addCollidableObject(mesh);
        }
    }
    
    return shapes;
}

// Create player Numberblock and add it to the scene
function createPlayerNumberblock(scene, value = 1) {
    const playerBlock = new Numberblock(value);
    playerBlock.mesh.position.set(0, playerBlock.blockSize / 2, 0); // Start at origin, on ground
    scene.add(playerBlock.mesh);
    return playerBlock;
}

// Handle window resize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Animation loop
function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    if (controls) updateControls(controls, delta);
    
    // In first-person, update Numberblock position to match camera
    // In third-person, handle camera following Numberblock
    if (window.isFirstPerson) {
        updatePlayerPosition();
    } else {
        // In third-person, update player position directly
        updatePlayerPositionThirdPerson(delta);
        updateThirdPersonCamera();
    }

    checkOperatorCollisions();
    checkNumberblockCollisions();

    renderer.render(scene, camera);
}

// Update player position and rotation based on controls - STANDARD FPS MECHANICS
function updatePlayerPosition() {
    if (!playerNumberblock || !controls) return;

    const controlsObject = controls.getObject();

    // Position Numberblock under camera based on height
    const numberblockHeight = playerNumberblock.getHeight();
    playerNumberblock.mesh.position.set(
        controlsObject.position.x,
        controlsObject.position.y - numberblockHeight / 2,
        controlsObject.position.z
    );

    // Get camera direction vector and calculate rotation
    // This addresses axis issues by deriving rotation from direction vector
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(controlsObject.quaternion);
    direction.y = 0; // Zero out vertical component
    direction.normalize();
    
    // Calculate rotation from direction vector
    const rotationY = Math.atan2(direction.x, direction.z);
    playerNumberblock.mesh.rotation.set(0, rotationY, 0);
}

// Update player position in third-person mode
function updatePlayerPositionThirdPerson(delta) {
    if (!playerNumberblock || !controls) return;
    
    // Get input states from global variables in controls.js
    const moveSpeed = 5.0 * delta;
    
    // Create a movement vector
    const movement = new THREE.Vector3(0, 0, 0);
    
    // Forward/backward movement
    if (window.moveForward) movement.z -= moveSpeed;
    if (window.moveBackward) movement.z += moveSpeed;
    
    // Left/right movement
    if (window.moveLeft) movement.x -= moveSpeed;
    if (window.moveRight) movement.x += moveSpeed;
    
    // Apply rotation to movement (match movement to camera orientation)
    const cameraDirection = new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion);
    cameraDirection.y = 0; // Keep movement on the horizontal plane
    cameraDirection.normalize();
    
    const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
    cameraRight.y = 0;
    cameraRight.normalize();
    
    // Calculate the final movement direction
    const finalMovement = new THREE.Vector3();
    finalMovement.addScaledVector(cameraDirection, -movement.z); // Forward is negative Z
    finalMovement.addScaledVector(cameraRight, movement.x);      // Right is positive X
    
    // Apply movement to Numberblock
    playerNumberblock.mesh.position.add(finalMovement);
    
    // Rotate Numberblock to face movement direction if moving
    if (finalMovement.lengthSq() > 0.001) {
        const targetRotation = Math.atan2(finalMovement.x, -finalMovement.z);
        
        // Smoothly rotate towards target direction (lerp rotation)
        const currentRotation = playerNumberblock.mesh.rotation.y;
        let rotationDifference = targetRotation - currentRotation;
        
        // Handle wraparound for angle difference
        if (rotationDifference > Math.PI) rotationDifference -= Math.PI * 2;
        if (rotationDifference < -Math.PI) rotationDifference += Math.PI * 2;
        
        // Apply smooth rotation
        playerNumberblock.mesh.rotation.y = currentRotation + rotationDifference * 0.1;
    }
    
    // Q and E rotation in third person rotates the camera around the player
    if (window.turnLeft || window.turnRight) {
        // This will be handled in updateThirdPersonCamera
    }
}

// Update camera position in third-person mode
function updateThirdPersonCamera() {
    if (!playerNumberblock || !playerNumberblock.mesh) return;
    
    // Third-person camera parameters
    const distance = 12;          // Distance behind player
    const height = 8;             // Height above player
    const smoothing = 0.1;        // Camera smoothing factor
    const rotationSpeed = 0.05;  // Manual camera rotation speed
    
    // Calculate the orbit angle for the camera
    if (typeof window.thirdPersonCameraAngle === 'undefined') {
        window.thirdPersonCameraAngle = playerNumberblock.mesh.rotation.y;
    }
    
    // Handle Q and E rotation (orbit camera around player)
    if (window.turnLeft) {
        window.thirdPersonCameraAngle += rotationSpeed;
    }
    if (window.turnRight) {
        window.thirdPersonCameraAngle -= rotationSpeed;
    }
    
    // Handle mouse input for camera rotation in third-person mode
    // This is handled by event listeners added in the view toggle
    
    // Calculate camera position based on orbit angle
    const playerPos = playerNumberblock.mesh.position.clone();
    const cameraOffset = new THREE.Vector3(
        Math.sin(window.thirdPersonCameraAngle) * distance,
        height,
        Math.cos(window.thirdPersonCameraAngle) * distance
    );
    
    // Calculate desired camera position
    const desiredPosition = playerPos.clone().sub(cameraOffset);
    
    // Smoothly move camera to desired position
    camera.position.lerp(desiredPosition, smoothing);
    
    // Look at the middle of the Numberblock
    const targetHeight = playerPos.y + playerNumberblock.getHeight() / 2;
    camera.lookAt(playerPos.x, targetHeight, playerPos.z);
}

// Check for collisions between player's Numberblock and other Numberblocks
function checkNumberblockCollisions() {
    if (!playerNumberblock || !playerNumberblock.mesh) return;
    
    const playerBox = new THREE.Box3().setFromObject(playerNumberblock.mesh);
    
    // Check collision with static Numberblock
    if (staticNumberblock && staticNumberblock.mesh) {
        const staticBox = new THREE.Box3().setFromObject(staticNumberblock.mesh);
        if (playerBox.intersectsBox(staticBox)) {
            // Only handle collision if we have an operator
            if (operatorManager && operatorManager.getHeldOperator()) {
                handleNumberblockCollision(staticNumberblock);
                
                // Remove the static Numberblock
                scene.remove(staticNumberblock.mesh);
                staticNumberblock = null;
                
                // Create a new static Numberblock
                const value = Math.floor(Math.random() * 20) + 1;
                staticNumberblock = createStaticNumberblock(value, { x: 0, z: -5 });
                
                // Position it randomly, away from the player
                let posX, posZ;
                do {
                    posX = (Math.random() * 40) - 20;
                    posZ = (Math.random() * 40) - 20;
                } while (
                    Math.abs(posX - playerNumberblock.mesh.position.x) < 5 && 
                    Math.abs(posZ - playerNumberblock.mesh.position.z) < 5
                );
                
                staticNumberblock.mesh.position.set(posX, staticNumberblock.blockSize / 2, posZ);
                scene.add(staticNumberblock.mesh);
                
                if (typeof addCollidableObject === 'function') {
                    addCollidableObject(staticNumberblock.mesh);
                }
            }
        }
    }
    
    // Check collisions with random Numberblocks
    for (let i = numberblocks.length - 1; i >= 0; i--) {
        const numberblock = numberblocks[i];
        if (!numberblock || !numberblock.mesh) continue;
        
        const blockBox = new THREE.Box3().setFromObject(numberblock.mesh);
        if (playerBox.intersectsBox(blockBox)) {
            // Only handle collision if we have an operator
            if (operatorManager && operatorManager.getHeldOperator()) {
                handleNumberblockCollision(numberblock);
                
                // Remove the collided Numberblock
                scene.remove(numberblock.mesh);
                numberblocks.splice(i, 1);
                
                // Create a new Numberblock to replace it
                const value = Math.floor(Math.random() * 20) + 1;
                const newBlock = new Numberblock(value);
                
                // Position it randomly, away from the player
                let posX, posZ;
                do {
                    posX = (Math.random() * 40) - 20;
                    posZ = (Math.random() * 40) - 20;
                } while (
                    Math.abs(posX - playerNumberblock.mesh.position.x) < 5 && 
                    Math.abs(posZ - playerNumberblock.mesh.position.z) < 5
                );
                
                newBlock.mesh.position.set(posX, newBlock.blockSize / 2, posZ);
                scene.add(newBlock.mesh);
                numberblocks.push(newBlock);
                
                if (typeof addCollidableObject === 'function') {
                    addCollidableObject(newBlock.mesh);
                }
            }
        }
    }
}

// Handle collision with a Numberblock
function handleNumberblockCollision(hitNumberblock) {
    // Only apply operation if we have an operator
    const operatorType = operatorManager.getHeldOperator();
    if (operatorType) {
        const oldValue = playerNumberblock.value;
        let newValue;
        
        if (operatorType === 'plus') {
            newValue = oldValue + hitNumberblock.value;
        } else {
            newValue = oldValue - hitNumberblock.value;
        }
        
        // Ensure value stays positive
        newValue = Math.max(1, newValue);
        
        // Update player's Numberblock
        playerNumberblock.setValue(newValue);
        updatePlayerDisplay(newValue);
        
        // Clear the held operator
        operatorManager.clearHeldOperator();
        updateOperatorDisplay(null);
        
        // Update camera position for new height
        updateCameraForNumberblockChange();
        
        console.log(`Applied ${operatorType} operation: ${oldValue} ${operatorType === 'plus' ? '+' : '-'} ${hitNumberblock.value} = ${newValue}`);
    }
}

// Update camera position after Numberblock changes size
function updateCameraForNumberblockChange() {
    if (controls && playerNumberblock) {
        const controlsObject = controls.getObject();
        const numberblockHeight = playerNumberblock.getHeight();
        
        // Calculate new appropriate camera height
        const verticalOffset = Math.max(1.5, numberblockHeight * 0.6);
        const desiredCameraHeight = playerNumberblock.mesh.position.y + verticalOffset;
        
        // Set camera to new height
        controlsObject.position.y = desiredCameraHeight;
        
        // Ensure camera doesn't go below minimum height
        const minCameraHeight = 1.0;
        if (controlsObject.position.y < minCameraHeight) {
            controlsObject.position.y = minCameraHeight;
        }
    }
}

// Check for collisions between player's Numberblock and operators
function checkOperatorCollisions() {
    try {
        if (!playerNumberblock || !operatorManager) return;
        
        const playerBox = new THREE.Box3().setFromObject(playerNumberblock.mesh);
        if (!playerBox) {
            console.warn("Could not create player's bounding box");
            return;
        }
        
        // Get all operators
        const operators = operatorManager.getOperators();
        
        // Check collision with each operator
        operators.forEach(operator => {
            const operatorBox = new THREE.Box3().setFromObject(operator.mesh);
            if (playerBox.intersectsBox(operatorBox)) {
                // Set the held operator and update display
                operatorManager.setHeldOperator(operator, playerNumberblock);
                updateOperatorDisplay(operator.type);
            }
        });
    } catch (error) {
        console.error("Error in checkOperatorCollisions:", error);
    }
}

// Add view toggle with V key
document.addEventListener('keydown', (event) => {
    if (event.code === 'KeyV') {
        window.isFirstPerson = !window.isFirstPerson;

        const controlsInfo = document.getElementById('controls-info');
        if (controlsInfo) controlsInfo.style.display = window.isFirstPerson ? 'block' : 'none';

        if (window.isFirstPerson) {
            // Switch to first-person view
            
            // Remove any third-person mouse control listeners if they exist
            if (window.thirdPersonMouseControlsActive) {
                document.removeEventListener('mousemove', window.thirdPersonMouseHandler);
                window.thirdPersonMouseControlsActive = false;
            }
            
            // Reset camera and attach to controls
            scene.remove(camera);
            controls.getObject().add(camera);
            camera.position.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);
            
            // Position controls at Numberblock's head position
            controls.getObject().position.copy(playerNumberblock.mesh.position);
            controls.getObject().position.y += playerNumberblock.getHeight() / 2;
            
            // Set rotation to match Numberblock exactly
            controls.getObject().rotation.y = playerNumberblock.mesh.rotation.y;
            
            // Lock pointer for first-person controls
            controls.lock();
        } else {
            // Switch to third-person view
            // Unlock and detach camera
            controls.unlock();
            controls.getObject().remove(camera);
            scene.add(camera);
            
            // Initialize third-person camera angle based on current player rotation
            window.thirdPersonCameraAngle = playerNumberblock.mesh.rotation.y + Math.PI; // Start behind player
            
            // Setup mouse controls for third-person camera rotation
            if (!window.thirdPersonMouseHandler) {
                window.thirdPersonMouseHandler = function(event) {
                    // Only handle mouse if not in pointer lock mode
                    if (!controls.isLocked) {
                        // Rotate camera around player based on mouse X movement
                        window.thirdPersonCameraAngle -= event.movementX * 0.002;
                    }
                };
            }
            
            // Activate third-person mouse controls
            document.addEventListener('mousemove', window.thirdPersonMouseHandler);
            window.thirdPersonMouseControlsActive = true;
            
            // Immediately update camera position for third-person view
            updateThirdPersonCamera();
        }

        camera.updateProjectionMatrix();

        // Update HUD view mode display
        const viewModeDisplay = document.getElementById('view-mode-display');
        if (viewModeDisplay) {
            viewModeDisplay.textContent = window.isFirstPerson ? 'First Person View' : 'Third Person View';
            viewModeDisplay.style.opacity = '1';
            setTimeout(() => viewModeDisplay.style.opacity = '0', 2000);
        }
    }
});

// Initialize the scene when the page loads
document.addEventListener('DOMContentLoaded', init);
 
 
===================================================== 
FILE: js\numberblock.js 
===================================================== 
 
// Numberblocks game - Numberblock model implementation

class Numberblock {
    constructor(value = 1, color = null) {
        this.value = value;
        this.mesh = new THREE.Group();
        this.blockSize = 1; // Size of each cube
        this.blockSpacing = 0.01; // Small gap between blocks
        this.totalHeight = 0;
        
        // Set color based on the Numberblock value, following show colors if no color specified
        if (!color) {
            this.color = this.getColorForNumber(value);
        } else {
            this.color = color;
        }
        
        this.createNumberblock();
    }
    
    // Get the standard Numberblocks color based on value
    getColorForNumber(number) {
        const colors = {
            1: 0xFF0000,   // Red (One)
            2: 0xFFA500,   // Orange (Two)
            3: 0xFFFF00,   // Yellow (Three)
            4: 0x00FF00,   // Green (Four)
            5: 0x0000FF,   // Blue (Five)
            6: 0x800080,   // Purple (Six)
            7: 0xFFC0CB,   // Pink (Seven)
            8: 0xA52A2A,   // Brown (Eight)
            9: 0x808080    // Grey (Nine)
        };
        
        // For numbers greater than 9, cycle through the colors or use white
        return colors[number % 9] || 0xFFFFFF;
    }
    
    // Create the complete Numberblock with all features
    createNumberblock() {
        this.mesh.clear(); // Clear any existing meshes
        this.totalHeight = 0;
        
        // Create the stack of blocks
        for (let i = 0; i < this.value; i++) {
            const block = this.createBlock();
            
            // Position each block on top of the previous one
            block.position.y = this.totalHeight;
            this.totalHeight += this.blockSize + this.blockSpacing;
            
            this.mesh.add(block);
            
            // Add face only to the top block
            if (i === this.value - 1) {
                const face = this.createFace();
                block.add(face);
            }
            
            // Add feet to the bottom block
            if (i === 0) {
                const leftFoot = this.createFoot('left');
                const rightFoot = this.createFoot('right');
                block.add(leftFoot);
                block.add(rightFoot);
            }
        }
        
        // Add arms to the middle block or the second block from the bottom if more than 3 blocks
        const armBlockIndex = this.value <= 3 ? Math.floor(this.value / 2) : 1;
        if (this.value > 0 && armBlockIndex < this.value) {
            const leftArm = this.createArm('left');
            const rightArm = this.createArm('right');
            
            this.mesh.children[armBlockIndex].add(leftArm);
            this.mesh.children[armBlockIndex].add(rightArm);
        }
        
        // Set initial position to 0 - we'll handle positioning in the game logic
        this.mesh.position.y = 0;
    }
    
    // Get the height of the Numberblock (for physics calculations)
    getHeight() {
        // Return the total height calculated during creation
        // If value is 0, return a minimum height
        return this.value > 0 ? this.totalHeight - this.blockSpacing : this.blockSize;
    }
    
    // Create a single block with the Numberblock's color
    createBlock() {
        const geometry = new THREE.BoxGeometry(this.blockSize, this.blockSize, this.blockSize);
        const material = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        return new THREE.Mesh(geometry, material);
    }
    
    // Create a face with eyes and mouth
    createFace() {
        const face = new THREE.Group();
        
        // Eyes (white spheres with black pupils)
        const eyeSize = this.blockSize * 0.15;
        const eyeSpacing = this.blockSize * 0.3;
        const eyeHeight = this.blockSize * 0.1;
        const eyeDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        
        // Create and position left eye
        const leftEye = this.createEye(eyeSize);
        leftEye.position.set(-eyeSpacing, eyeHeight, eyeDepth);
        face.add(leftEye);
        
        // Create and position right eye
        const rightEye = this.createEye(eyeSize);
        rightEye.position.set(eyeSpacing, eyeHeight, eyeDepth);
        face.add(rightEye);
        
        // Mouth (curved line or small cylinder)
        const mouthWidth = this.blockSize * 0.4;
        const mouthHeight = this.blockSize * 0.1;
        const mouthDepth = this.blockSize / 2 + 0.01; // Slightly in front of the face
        const mouthY = -eyeHeight * 2; // Position below the eyes
        
        const mouthGeometry = new THREE.CylinderGeometry(
            mouthHeight/2, mouthHeight/2, mouthWidth, 16, 1, false, 0, Math.PI
        );
        mouthGeometry.rotateZ(Math.PI / 2); // Rotate to correct orientation
        
        const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, mouthY, mouthDepth);
        face.add(mouth);
        
        return face;
    }
    
    // Create an eye (white sphere with black pupil)
    createEye(size) {
        const eye = new THREE.Group();
        
        // White part of the eye
        const eyeWhiteGeometry = new THREE.SphereGeometry(size, 16, 16);
        const eyeWhiteMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const eyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
        eye.add(eyeWhite);
        
        // Black pupil
        const pupilSize = size * 0.5;
        const pupilGeometry = new THREE.SphereGeometry(pupilSize, 16, 16);
        const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        pupil.position.z = size * 0.6; // Position the pupil slightly in front of the eye
        eye.add(pupil);
        
        return eye;
    }
    
    // Create an arm (left or right)
    createArm(side) {
        const arm = new THREE.Group();
        
        // Arm dimensions
        const armLength = this.blockSize * 0.6;
        const armWidth = this.blockSize * 0.2;
        const armHeight = this.blockSize * 0.2;
        
        // Create the arm geometry
        const armGeometry = new THREE.BoxGeometry(armLength, armHeight, armWidth);
        const armMaterial = new THREE.MeshStandardMaterial({
            color: this.color,
            roughness: 0.7,
            metalness: 0.2
        });
        
        const armMesh = new THREE.Mesh(armGeometry, armMaterial);
        
        // Position the arm on the side of the block
        const xOffset = (this.blockSize / 2 + armLength / 2) * (side === 'left' ? -1 : 1);
        armMesh.position.set(xOffset, 0, 0);
        
        arm.add(armMesh);
        
        // Add a hand at the end of the arm
        const handRadius = armWidth * 0.8;
        const handGeometry = new THREE.SphereGeometry(handRadius, 16, 16);
        const handMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF, // White hands
            roughness: 0.7,
            metalness: 0.2
        });
        
        const hand = new THREE.Mesh(handGeometry, handMaterial);
        
        // Position the hand at the end of the arm
        const handX = armLength / 2 * (side === 'left' ? -1 : 1);
        hand.position.set(handX, 0, 0);
        
        // Name the hand for easy reference
        hand.name = side + 'Hand';
        
        armMesh.add(hand);
        
        return arm;
    }
    
    // Create a foot (left or right)
    createFoot(side) {
        const foot = new THREE.Group();
        
        // Foot dimensions
        const footLength = this.blockSize * 0.4;
        const footWidth = this.blockSize * 0.3;
        const footHeight = this.blockSize * 0.15;
        
        // Create the foot geometry
        const footGeometry = new THREE.BoxGeometry(footLength, footHeight, footWidth);
        const footMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000, // Black feet
            roughness: 0.7,
            metalness: 0.2
        });
        
        const footMesh = new THREE.Mesh(footGeometry, footMaterial);
        
        // Position the foot on the bottom of the block
        const xOffset = (this.blockSize / 4) * (side === 'left' ? -1 : 1);
        const yOffset = -this.blockSize / 2 - footHeight / 2;
        const zOffset = this.blockSize / 4; // Push feet slightly forward
        footMesh.position.set(xOffset, yOffset, zOffset);
        
        foot.add(footMesh);
        
        return foot;
    }
    
    // Update the Numberblock value and regenerate the model
    setValue(newValue) {
        if (newValue < 1) newValue = 1; // Ensure minimum value of 1
        if (newValue !== this.value) {
            this.value = newValue;
            this.color = this.getColorForNumber(newValue);
            this.createNumberblock();
        }
    }
    
    // Update the position of the HTML number tag in render loop
    updateNumberTagPosition(camera, renderer) {
        // Previous functionality disabled - no longer using HTML elements for tags
        // Now fully using the HUD we created in index.html and main.js
    }
    
    // Dispose any allocated resources
    dispose() {
        // We no longer need to remove HTML elements since we aren't creating them
    }
}

// Function to create a player Numberblock and add it to the scene
function createPlayerNumberblock(scene, value = 1) {
    // Create the Numberblock
    const playerBlock = new Numberblock(value);
    
    // Position it slightly above the ground
    const totalHeight = playerBlock.totalHeight;
    playerBlock.mesh.position.y = totalHeight / 2;
    
    // Add to scene
    scene.add(playerBlock.mesh);
    
    return playerBlock;
}

// Export for use in other modules
if (typeof module !== 'undefined') {
    module.exports = {
        Numberblock,
        createPlayerNumberblock
    };
} 
 
===================================================== 
FILE: js\operator.js 
===================================================== 
 
// Numberblocks game - Operator implementation

// Class to represent mathematical operators (+ and -)
class Operator {
    constructor(type, scene) {
        this.type = type; // 'plus' or 'minus'
        this.scene = scene;
        this.mesh = this.createOperatorMesh();
        
        // Add the operator to the scene
        scene.add(this.mesh);
        
        // Set the radius for collision detection
        this.collisionRadius = 0.5;
    }
    
    // Create the 3D mesh for the operator
    createOperatorMesh() {
        const operatorGroup = new THREE.Group();
        
        // Create a semi-transparent white sphere as the base
        const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const sphereMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF, // White sphere
            roughness: 0.3,
            metalness: 0.2,
            transparent: true, // Make it transparent
            opacity: 0.6 // 60% opacity
        });
        
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        operatorGroup.add(sphere);
        
        // Create the symbol geometry (+ or -) and place it in the center
        const symbolColor = 0x000000; // Black symbol
        const symbolMaterial = new THREE.MeshBasicMaterial({ color: symbolColor });
        
        if (this.type === 'plus') {
            // Create a plus sign (+) using two cylinders
            // Horizontal bar
            const horizontalGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            horizontalGeometry.rotateZ(Math.PI / 2); // Rotate to make it horizontal
            const horizontalBar = new THREE.Mesh(horizontalGeometry, symbolMaterial);
            
            // Vertical bar
            const verticalGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            const verticalBar = new THREE.Mesh(verticalGeometry, symbolMaterial);
            
            operatorGroup.add(horizontalBar);
            operatorGroup.add(verticalBar);
        } else {
            // Create a minus sign (-) using a single cylinder
            const minusGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            minusGeometry.rotateZ(Math.PI / 2); // Rotate to make it horizontal
            const minusBar = new THREE.Mesh(minusGeometry, symbolMaterial);
            
            operatorGroup.add(minusBar);
        }
        
        // Add a soft glow effect
        const glowGeometry = new THREE.SphereGeometry(0.6, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF, // White glow
            transparent: true,
            opacity: 0.2
        });
        
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        operatorGroup.add(glow);
        
        // Add rotation animation that ensures the symbol stays visible
        this.animate = (deltaTime) => {
            // Instead of rotating around Y-axis, make the operator face the camera
            if (window.camera) {
                // Get direction to camera
                const direction = new THREE.Vector3();
                direction.subVectors(window.camera.position, operatorGroup.position).normalize();
                
                // Create a temporary up vector (world up)
                const up = new THREE.Vector3(0, 1, 0);
                
                // Create a look-at matrix
                const lookMatrix = new THREE.Matrix4();
                lookMatrix.lookAt(operatorGroup.position, 
                                  operatorGroup.position.clone().add(direction), 
                                  up);
                
                // Convert to quaternion and apply
                operatorGroup.quaternion.setFromRotationMatrix(lookMatrix);
            } else {
                // Default rotation if no camera
                operatorGroup.rotation.y += deltaTime * 1.5;
            }
            
            // Add a subtle floating animation
            operatorGroup.position.y = Math.sin(Date.now() * 0.002) * 0.1 + 0.6; // Float between 0.5 and 0.7
        };
        
        return operatorGroup;
    }
    
    // Position the operator in the scene
    setPosition(x, y, z) {
        this.mesh.position.set(x, y, z);
    }
    
    // Remove the operator from the scene
    remove() {
        this.scene.remove(this.mesh);
        
        // Clean up geometries and materials to prevent memory leaks
        this.mesh.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(material => material.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
    }
    
    // Create a smaller version of the operator for holding
    createHeldOperatorMesh() {
        // Create a smaller version of the operator for holding
        const scale = 0.4; // Smaller scale for held operator
        const heldMesh = this.createOperatorMesh();
        heldMesh.scale.set(scale, scale, scale);
        
        return heldMesh;
    }
}

// Class to manage all operators in the game
class OperatorManager {
    constructor(scene) {
        this.scene = scene;
        this.operators = [];
        this.spawnTimer = 0;
        this.spawnInterval = this.getRandomSpawnInterval();
        this.maxOperators = 10; // Maximum number of operators allowed at once
        this.groundY = 0; // Y position of the ground
        this.mapSize = 40; // Size of the playable area (40x40)
        
        // Player's held operator
        this.heldOperator = null;
        this.heldOperatorMesh = null;
        
        // Debug message to check initialization
        console.log("OperatorManager initialized");
    }
    
    // Get a random spawn interval between 5-10 seconds
    getRandomSpawnInterval() {
        return 5 + Math.random() * 5; // 5-10 seconds
    }
    
    // Update function to be called in animation loop
    update(deltaTime) {
        // Update existing operators
        this.operators.forEach(operator => {
            operator.animate(deltaTime);
        });
        
        // Check if it's time to spawn a new operator
        this.spawnTimer += deltaTime;
        if (this.spawnTimer >= this.spawnInterval && this.operators.length < this.maxOperators) {
            this.spawnOperator();
            this.spawnTimer = 0;
            this.spawnInterval = this.getRandomSpawnInterval();
        }
    }
    
    // Spawn a new operator at a random position
    spawnOperator() {
        // Randomly choose between plus and minus
        const type = Math.random() > 0.5 ? 'plus' : 'minus';
        
        // Create the operator
        const operator = new Operator(type, this.scene);
        
        // Set a random position on the ground
        const posX = (Math.random() * this.mapSize) - (this.mapSize / 2);
        const posZ = (Math.random() * this.mapSize) - (this.mapSize / 2);
        
        // Set the Y position slightly above the ground to prevent z-fighting
        operator.setPosition(posX, this.groundY + 0.6, posZ);
        
        // Add to the array of active operators
        this.operators.push(operator);
        
        console.log(`Spawned ${type} operator at (${posX.toFixed(2)}, ${this.groundY + 0.6}, ${posZ.toFixed(2)})`);
        
        return operator;
    }
    
    // Remove an operator from the scene and the operators array
    removeOperator(operator) {
        const index = this.operators.indexOf(operator);
        if (index !== -1) {
            operator.remove();
            this.operators.splice(index, 1);
        }
    }
    
    // Set the currently held operator
    setHeldOperator(operator, numberblock) {
        // Clear any previously held operator
        this.clearHeldOperator();
        
        // Store the operator type
        this.heldOperator = operator.type;
        console.log("Setting held operator type:", this.heldOperator); // Debug log
        
        // Create a smaller version of the operator for holding
        this.heldOperatorMesh = operator.createHeldOperatorMesh();
        
        // Attach the operator to the Numberblock's right hand
        if (numberblock && numberblock.mesh) {
            // Find the right hand in the Numberblock's mesh hierarchy
            let rightHand = null;
            
            // Look for the arm block (should be the second block for Numberblocks with more than 3 blocks)
            const armBlockIndex = numberblock.value <= 3 ? Math.floor(numberblock.value / 2) : 1;
            
            // Find the right hand if there are enough blocks
            if (numberblock.value > 0 && armBlockIndex < numberblock.value) {
                // Get the arm block
                const armBlock = numberblock.mesh.children[armBlockIndex];
                
                // Search for the rightHand in the arm block's children
                armBlock.traverse((child) => {
                    if (child.name === 'rightHand') {
                        rightHand = child;
                    }
                });
                
                // If we found the right hand, attach the operator to it
                if (rightHand) {
                    // Position the held operator slightly offset from the hand
                    this.heldOperatorMesh.position.set(0, 0.2, 0);
                    
                    // Add the held operator mesh to the right hand
                    rightHand.add(this.heldOperatorMesh);
                    
                    console.log(`Attached ${this.heldOperator} operator to Numberblock's right hand`);
                } else {
                    // Fallback: Add to the scene if we can't find the hand
                    console.warn("Could not find rightHand - adding operator to scene");
                    this.scene.add(this.heldOperatorMesh);
                }
            } else {
                // Fallback: Add to the scene if Numberblock doesn't have arms
                console.warn("Numberblock doesn't have enough blocks for arms - adding operator to scene");
                this.scene.add(this.heldOperatorMesh);
            }
        } else {
            // Add to the scene if no Numberblock is provided
            this.scene.add(this.heldOperatorMesh);
        }
        
        // Remove the original operator from the scene
        this.removeOperator(operator);
        
        console.log(`Now holding ${this.heldOperator} operator`); // Debug log
        return this.heldOperator;
    }
    
    // Clear the currently held operator
    clearHeldOperator() {
        if (this.heldOperatorMesh) {
            // Remove from parent (either scene or hand)
            if (this.heldOperatorMesh.parent) {
                this.heldOperatorMesh.parent.remove(this.heldOperatorMesh);
            } else {
                this.scene.remove(this.heldOperatorMesh);
            }
            
            this.heldOperatorMesh = null;
        }
        this.heldOperator = null;
        console.log("Cleared held operator"); // Debug log
    }
    
    // Get the currently held operator type
    getHeldOperator() {
        console.log("Getting held operator type:", this.heldOperator); // Debug log
        return this.heldOperator;
    }
    
    // Attach the held operator to a Numberblock
    attachOperatorToNumberblock(numberblock) {
        if (this.heldOperatorMesh && numberblock) {
            // The numberblock will handle the positioning
            return {
                type: this.heldOperator,
                mesh: this.heldOperatorMesh
            };
        }
        return null;
    }
    
    // Clear all operators
    clearAll() {
        while (this.operators.length > 0) {
            this.removeOperator(this.operators[0]);
        }
        this.clearHeldOperator();
    }
    
    // Get all operators for collision checking
    getOperators() {
        return this.operators;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined') {
    module.exports = {
        Operator,
        OperatorManager
    };
}
 
 
